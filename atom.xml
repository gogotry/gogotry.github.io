<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xupengfly</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-02-26T04:21:48.510Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>angiter</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>gulp构建工程化项目(angular-gulp-demo)</title>
    <link href="http://yoursite.com/2016/09/15/gulp%E6%9E%84%E5%BB%BA%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%A1%B9%E7%9B%AE(angular-gulp-demo)/"/>
    <id>http://yoursite.com/2016/09/15/gulp构建工程化项目(angular-gulp-demo)/</id>
    <published>2016-09-15T12:34:36.000Z</published>
    <updated>2017-02-26T04:21:48.510Z</updated>
    
    <content type="html"><![CDATA[<p><strong>这里就不再说gulp的API与插件了，直接上demo,(看不明白的请看–gulp构建工程化项目(API/插件))</strong></p>
<p><strong>数据结构</strong><br>这里只是简单的demo案例，项目中的数据结构比这要复杂。<br><img src="http://olyo5zdej.bkt.clouddn.com/blog/20170226/120126583.png" alt="mark"><br><a id="more"></a><br><strong>以下所有代码均在 gulpfile.js 文件</strong><br>1&gt; 引包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;)</div><div class="line">const gulp = require(&apos;gulp&apos;)</div><div class="line">const less = require(&apos;gulp-less&apos;)</div><div class="line">const cssnano = require(&apos;gulp-cssnano&apos;)</div><div class="line">const gulpif = require(&apos;gulp-if&apos;)</div><div class="line">const argv = require(&apos;yargs&apos;).argv</div><div class="line">const concat = require(&apos;gulp-concat&apos;)</div><div class="line">const uglify = require(&apos;gulp-uglify&apos;)</div><div class="line">const imagemin = require(&apos;gulp-imagemin&apos;) // Minify PNG, JPEG, GIF and SVG images</div><div class="line">const templateCache = require(&apos;gulp-angular-templatecache&apos;)</div><div class="line">const htmlmin = require(&apos;gulp-htmlmin&apos;)</div><div class="line">const browserSync = require(&apos;browser-sync&apos;).create()</div></pre></td></tr></table></figure></p>
<p>2&gt; 路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const paths = &#123;</div><div class="line">  less: &apos;./src/less/main.less&apos;,</div><div class="line">  vendors: [</div><div class="line">    &apos;./node_modules/angular/angular.js&apos;,</div><div class="line">    &apos;./node_modules/angular-route/angular-route.js&apos;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3&gt; 编辑 less<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gulp.task(&apos;less&apos;, () =&gt; &#123;</div><div class="line">  return gulp.src(&apos;./src/less/main.less&apos;)</div><div class="line">    .pipe(less())</div><div class="line">    .pipe(gulpif(argv.deploy, cssnano()))</div><div class="line">    .pipe(gulp.dest(&apos;./dist/css&apos;))</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>4&gt; 提取第三方 js 文件，合并压缩处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//将所有的项目第三方依赖的客户端 js 打包压缩成 vendor.js 到 dist/js/vendor.js</div><div class="line">gulp.task(&apos;vendor&apos;, () =&gt; &#123;</div><div class="line">  return gulp.src(paths.vendors)</div><div class="line">    .pipe(concat(&apos;vendor.js&apos;))</div><div class="line">    .pipe(gulpif(argv.deploy, uglify()))</div><div class="line">    .pipe(gulp.dest(&apos;./dist/js&apos;))</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>5&gt; 提取 img ，压缩处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//压缩 img 中的图片写入 dist/img</div><div class="line">gulp.task(&apos;img&apos;, () =&gt; &#123;</div><div class="line">  return gulp.src(&apos;./src/img/**/*.&#123;jpg,jpeg,png,gif&#125;&apos;)</div><div class="line">    .pipe(imagemin())</div><div class="line">    .pipe(gulp.dest(&apos;./dist/img&apos;))</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>6&gt; 生成一个 templates.js 模板文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">gulp.task(&apos;template&apos;, () =&gt; &#123;</div><div class="line">  return gulp.src(&apos;./src/app/**/*.html&apos;)</div><div class="line">    .pipe(templateCache(&apos;templates.js&apos;, &#123;</div><div class="line">      module: &apos;templates&apos;,</div><div class="line">      standalone: true,</div><div class="line">      transformUrl: function (url) &#123;</div><div class="line">        return `./$&#123;path.basename(url)&#125;`</div><div class="line">      &#125;</div><div class="line">    &#125;))</div><div class="line">    .pipe(gulp.dest(&apos;./&apos;))</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>7&gt; 提取自己的 js 文件，合并压缩处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">gulp.task(&apos;scripts&apos;, [&apos;template&apos;], () =&gt; &#123;</div><div class="line">  return gulp.src([</div><div class="line">      &apos;./templates.js&apos;,</div><div class="line">      &apos;./src/app/**/*.js&apos;</div><div class="line">    ])</div><div class="line">    .pipe(concat(&apos;bundle.js&apos;))</div><div class="line">    .pipe(gulpif(argv.deploy, uglify()))</div><div class="line">    .pipe(gulp.dest(&apos;./dist/js&apos;))</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>7&gt; 提取视图模板文件，合并压缩处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gulp.task(&apos;html&apos;, () =&gt; &#123;</div><div class="line">  return gulp.src(&apos;./src/index.html&apos;)</div><div class="line">    .pipe(gulpif(argv.deploy, htmlmin(&#123; collapseWhitespace: true &#125;)))</div><div class="line">    .pipe(gulp.dest(&apos;./dist/&apos;))</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p> 8&gt; 监视文件变动，实时更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">gulp.task(&apos;watch-html&apos;, [&apos;html&apos;], (callback) =&gt; &#123;</div><div class="line">  browserSync.reload()</div><div class="line">  callback()</div><div class="line">&#125;)</div><div class="line"></div><div class="line">gulp.task(&apos;watch-less&apos;, [&apos;less&apos;], (callback) =&gt; &#123;</div><div class="line">  browserSync.reload()</div><div class="line">  callback()</div><div class="line">&#125;)</div><div class="line"></div><div class="line">gulp.task(&apos;watch-scripts&apos;, [&apos;scripts&apos;], (callback) =&gt; &#123;</div><div class="line">  browserSync.reload()</div><div class="line">  callback()</div><div class="line">&#125;)</div><div class="line"></div><div class="line"></div><div class="line">gulp.task(&apos;serve&apos;, [&apos;less&apos;, &apos;scripts&apos;, &apos;html&apos;, &apos;vendor&apos;, &apos;img&apos;], () =&gt; &#123;</div><div class="line">  browserSync.init(&#123;</div><div class="line">    server: &#123;</div><div class="line">      baseDir: &quot;./dist/&quot;</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  gulp.watch(&apos;./src/index.html&apos;, [&apos;watch-html&apos;])</div><div class="line">  gulp.watch(&apos;./src/less/**/*.less&apos;, [&apos;watch-less&apos;])</div><div class="line">  gulp.watch([&apos;./src/app/**/*.js&apos;, &apos;./src/app/**/*.html&apos;], [&apos;watch-scripts&apos;])</div><div class="line">&#125;)</div><div class="line"></div><div class="line">gulp.task(&apos;default&apos;, [&apos;serve&apos;])</div></pre></td></tr></table></figure></p>
<p>9&gt;开发与上线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//实时开发与视图展示</div><div class="line">gulp serve</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//代码压缩</div><div class="line">gulp serve --deploy</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;这里就不再说gulp的API与插件了，直接上demo,(看不明白的请看–gulp构建工程化项目(API/插件))&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据结构&lt;/strong&gt;&lt;br&gt;这里只是简单的demo案例，项目中的数据结构比这要复杂。&lt;br&gt;&lt;img src=&quot;http://olyo5zdej.bkt.clouddn.com/blog/20170226/120126583.png&quot; alt=&quot;mark&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技能" scheme="http://yoursite.com/categories/%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="gulp" scheme="http://yoursite.com/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>gulp构建工程化项目(API/插件)</title>
    <link href="http://yoursite.com/2016/09/06/gulp%E6%9E%84%E5%BB%BA%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%A1%B9%E7%9B%AE(API%E4%B8%8E%E6%8F%92%E4%BB%B6)/"/>
    <id>http://yoursite.com/2016/09/06/gulp构建工程化项目(API与插件)/</id>
    <published>2016-09-06T02:34:36.000Z</published>
    <updated>2017-02-26T03:29:55.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gulp-Tutorial"><a href="#Gulp-Tutorial" class="headerlink" title="Gulp Tutorial"></a>Gulp Tutorial</h1><blockquote>
<p>Gulp: The streaming build system<br><img src="http://olyo5zdej.bkt.clouddn.com/blog/20170226/105637897.png" alt="mark"></p>
</blockquote>
<p>gulp是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；<br><a id="more"></a><br>她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；<br>使用她，不仅可以很愉快的编写代码，而且大大提高我们的工作效率。</p>
<p>项目构建是指项目上线之前对项目源代码进行一系列处理，使其以最佳的形式运行于线上服务器。<br>常见处理任包括以下几方面：</p>
<ol>
<li>模块化开发可以实现功能的复用并解决模块间的依赖关系，但带来好处的同时也使得功能代码的碎片化（若干文件）程度增加。</li>
<li>使用less、sass等预处理器，可以降低CSS的维护成本，最终需要将这些预处理器编译成css文件；</li>
<li>对静态资源（css、js、html、images）压缩合并可以提升网页打开速度，提高性能；</li>
</ol>
<p>以上任务完如果完全靠手动来完成是非常耗时耗力的且容易出错，实际开发通常借助构建工具来实现。<br>所谓构建工具是指通过一系简单配置就可以帮我们实现合并、压缩、校验、预处理等一系列任务的软件工具。<br>常见的构建工具包括：<code>Grunt、Gulp、F.I.S（百度出品）、webpack</code>等。</p>
<p>Gulp是基于Nodejs开发的一个构建工具，借助gulp插件可以实现不同的构建任务，<br>其以简洁的配置和卓越的性能成为目前主流的构建工具。</p>
<p><img src="http://olyo5zdej.bkt.clouddn.com/blog/20170226/105739832.jpg" alt="mark"></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul>
<li>官方：<a href="http://gulpjs.com/" target="_blank" rel="external">http://gulpjs.com/</a></li>
<li>中文官网：<a href="http://www.gulpjs.com.cn/" target="_blank" rel="external">http://www.gulpjs.com.cn/</a></li>
<li>npm：<a href="https://www.npmjs.com/package/gulp" target="_blank" rel="external">https://www.npmjs.com/package/gulp</a></li>
<li>Github：<a href="https://github.com/gulpjs/gulp" target="_blank" rel="external">https://github.com/gulpjs/gulp</a></li>
<li>Gitbook：<a href="https://wizardforcel.gitbooks.io/gulp-doc/content/2.html" target="_blank" rel="external">https://wizardforcel.gitbooks.io/gulp-doc/content/2.html</a></li>
</ul>
<hr>
<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><blockquote>
<p>官方文档：<a href="https://github.com/gulpjs/gulp/blob/master/docs/getting-started.md" target="_blank" rel="external">https://github.com/gulpjs/gulp/blob/master/docs/getting-started.md</a></p>
</blockquote>
<p>一：Install the gulp command</p>
<p>在项目中使用 gulp 首先需要确保全局有 gulp-cli 环境，如果有就不需要执行下面的命令了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># npm install --global gulp-cli</span></div><div class="line">yarn global add gulp-cli</div></pre></td></tr></table></figure>
<p>二：Install gulp in your devDependencies</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># npm install --save-dev gulp</span></div><div class="line">yarn add -D gulp</div></pre></td></tr></table></figure>
<p>三：Create a file called gulpfile.js in your project root with these contents:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var gulp = require(<span class="string">'gulp'</span>);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'default'</span>, <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">  console.log(<span class="string">'hello gulp'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>四：Test it out: Run the gulp command in your project directory:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gulp</div></pre></td></tr></table></figure>
<hr>
<h2 id="API-Documentation"><a href="#API-Documentation" class="headerlink" title="API Documentation"></a>API Documentation</h2><blockquote>
<p>官方文档：<a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md" target="_blank" rel="external">https://github.com/gulpjs/gulp/blob/master/docs/API.md</a></p>
</blockquote>
<ul>
<li>gulp.task</li>
<li>gulp.src</li>
<li>gulp.dest</li>
<li>gulp.watch</li>
</ul>
<h3 id="gulp-task-name-deps-fn"><a href="#gulp-task-name-deps-fn" class="headerlink" title="gulp.task(name [, deps] [, fn])"></a>gulp.task(name [, deps] [, fn])</h3><p>作用：定义各种不同的任务</p>
<ul>
<li>gulp.task(name, fn)</li>
<li>gulp.task(name, deps, fn)</li>
<li>gulp.task(name, fn(cb))</li>
<li>gulp.task(name, deps, fn(cb))</li>
</ul>
<p>一：普通任务</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'1 aaa'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'b'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'2 bbb'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>二：任务之间的依赖</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'1 aaa'</span>)</div><div class="line">    cb()</div><div class="line">  &#125;, <span class="number">1000</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// b 任务依赖的 a 任务中的回调函数如果不调用，b 任务是不会执行的</span></div><div class="line">gulp.task(<span class="string">'b'</span>, [<span class="string">'a'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'2 bbb'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>三：gulp 流控制</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 当任务中是一个 gulp 流的时候则需要通过 return 来保证依赖中的执行顺序</span></div><div class="line">  <span class="keyword">return</span> gulp.src()</div><div class="line">    .pipe()</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'b'</span>, [<span class="string">'a'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// doSomething</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="gulp-src-globs-options"><a href="#gulp-src-globs-options" class="headerlink" title="gulp.src(globs[, options])"></a>gulp.src(globs[, options])</h3><blockquote>
<p>gulp教程之gulp中文API：<a href="http://www.ydcss.com/archives/424" target="_blank" rel="external">http://www.ydcss.com/archives/424</a></p>
</blockquote>
<p>作用：根据路径（字符串或数组）读取需要构建的资源</p>
<h4 id="globs"><a href="#globs" class="headerlink" title="globs"></a>globs</h4><p>需要处理的源文件匹配符路径。</p>
<p>类型(必填)：String or StringArray，通配符路径匹配示例：</p>
<ul>
<li><code>src/a.js</code> 指定具体文件；</li>
<li><code>*</code> 匹配所有文件    例：<code>src/*.js</code> (包含src下的所有js文件)；</li>
<li><code>**</code> 匹配0个或多个子文件夹    例：<code>src/**/*.js</code> (包含src的0个或多个子文件夹下的js文件)；</li>
<li><code>{}</code> 匹配多个属性    例：<code>src/{a,b}.js</code> (包含a.js和b.js文件)  src/*.{jpg,png,gif}(src下的所有jpg/png/gif文件)；</li>
<li><code>!</code> 排除文件    例：<code>!src/a.js</code> (不包含src下的a.js文件)；</li>
</ul>
<h4 id="options-base"><a href="#options-base" class="headerlink" title="options.base"></a>options.base</h4><p>options.base：类型：String  设置输出路径以某个路径的某个组成部分为基础向后拼接，具体看下面示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">gulp.src(<span class="string">'client/js/**/*.js'</span>) </div><div class="line">  .pipe(minify())</div><div class="line">  .pipe(gulp.dest(<span class="string">'build'</span>))  <span class="comment">// Writes 'build/somedir/somefile.js'</span></div><div class="line"> </div><div class="line">gulp.src(<span class="string">'client/js/**/*.js'</span>, &#123; <span class="attr">base</span>: <span class="string">'client'</span> &#125;)</div><div class="line">  .pipe(minify())</div><div class="line">  .pipe(gulp.dest(<span class="string">'build'</span>))  <span class="comment">// Writes 'build/js/somedir/somefile.js'</span></div></pre></td></tr></table></figure>
<h3 id="gulp-dest-path-options"><a href="#gulp-dest-path-options" class="headerlink" title="gulp.dest(path[, options])"></a>gulp.dest(path[, options])</h3><p>作用：构建任务完成后资源存放的路径</p>
<h3 id="gulp-watch-glob-opts-tasks"><a href="#gulp-watch-glob-opts-tasks" class="headerlink" title="gulp.watch(glob[, opts], tasks)"></a>gulp.watch(glob[, opts], tasks)</h3><blockquote>
<p>监视指定资源的改动，然后可以调用响应的任务处理</p>
</blockquote>
<h3 id="gulp-watch-glob-opts-cb"><a href="#gulp-watch-glob-opts-cb" class="headerlink" title="gulp.watch(glob [, opts, cb])"></a>gulp.watch(glob [, opts, cb])</h3><hr>
<h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><table>
<thead>
<tr>
<th>插件名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>del</td>
<td>删除文件或文件夹</td>
</tr>
<tr>
<td>gulp-less</td>
<td>编译LESS文件</td>
</tr>
<tr>
<td>gulp-rname</td>
<td>重命名文件</td>
</tr>
<tr>
<td>gulp-imagemin</td>
<td>图片压缩</td>
</tr>
<tr>
<td>gulp-uglify</td>
<td>压缩Javascript</td>
</tr>
<tr>
<td>gulp-concat</td>
<td>合并 js 文件</td>
</tr>
<tr>
<td>gulp-concat-css</td>
<td>合并 css 文件</td>
</tr>
<tr>
<td>gulp-cssnano</td>
<td>压缩 css</td>
</tr>
<tr>
<td>gulp-htmlmin</td>
<td>压缩HTML</td>
</tr>
<tr>
<td>gulp-rev</td>
<td>添加版本号</td>
</tr>
<tr>
<td>gulp-rev-collector</td>
<td>内容替换</td>
</tr>
<tr>
<td>gulp-useref</td>
<td>gulp-if</td>
</tr>
<tr>
<td>gulp-load-plugins</td>
<td>依赖自动加载</td>
</tr>
<tr>
<td>gulp-useref</td>
<td>自动合并打包处理</td>
</tr>
<tr>
<td>gulp-wrap</td>
<td>包装内容</td>
</tr>
<tr>
<td>gulp-angular-templatecache</td>
<td>AngularJS 模板缓存</td>
</tr>
<tr>
<td>browser-sync</td>
<td>和 gulp 配合使用实现文件改变执行某个任务后自动刷新</td>
</tr>
<tr>
<td>yargs</td>
<td>获取命令行参数</td>
</tr>
<tr>
<td>gulp-if</td>
<td>根据判断执行某个插件</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Gulp-Tutorial&quot;&gt;&lt;a href=&quot;#Gulp-Tutorial&quot; class=&quot;headerlink&quot; title=&quot;Gulp Tutorial&quot;&gt;&lt;/a&gt;Gulp Tutorial&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Gulp: The streaming build system&lt;br&gt;&lt;img src=&quot;http://olyo5zdej.bkt.clouddn.com/blog/20170226/105637897.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;gulp是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；&lt;br&gt;
    
    </summary>
    
      <category term="技能" scheme="http://yoursite.com/categories/%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="gulp" scheme="http://yoursite.com/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>angular跨域问题分析</title>
    <link href="http://yoursite.com/2016/08/23/angular%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2016/08/23/angular跨域问题分析/</id>
    <published>2016-08-23T13:27:58.000Z</published>
    <updated>2017-02-24T17:51:06.607Z</updated>
    
    <content type="html"><![CDATA[<p><span style="color: #ff0000">跨域，前端开发中经常遇到的问题，AngularJS实现跨域方式类似于Ajax，下面是AngularJS中使用$http实现跨域请求数据</span></p>
<p><strong>AngularJS XMLHttpRequest：</strong>$http用于读取远程服务器的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$http.post(url, data, [config]).success(function()&#123; ... &#125;);</div><div class="line">$http.get(url, [config]).success(function()&#123; ... &#125;);</div><div class="line">$http.get(url, [config]).success(function()&#123; ... &#125;);</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><span style="color: #ff0000"><strong>一、$http.jsonp【实现跨域】</strong></span></p>
<p>1.指定<code>callback</code>和回调函数名，函数名为<code>JSON_CALLBACK</code>时，会调用success回调函数，<code>JSON_CALLBACK</code>必须全为大写。</p>
<p>2.指定其它回调函数，但必须是定义在window下的全局函数。url中必须加上<code>callback</code>。</p>
<p><span style="color: #ff0000"><strong>二、$http.get【实现跨域】</strong></span></p>
<p>1.在服务器端设置允许在其他域名下访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); //允许所有域名访问</div><div class="line">response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://www.123.com&quot;); //允许www.123.com访问</div></pre></td></tr></table></figure>
<p>2.AngularJS端使用<code>$http.get()</code></p>
<p><span style="color: #ff0000"><strong>三、$http.post【实现跨域】</strong></span></p>
<p>1.在服务器端设置允许在其他域名下访问，及响应类型、响应头设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</div><div class="line">response.setHeader(&quot;Access-Control-Allow-Methods&quot;,&quot;POST&quot;);</div><div class="line">response.setHeader(&quot;Access-Control-Allow-Headers&quot;,&quot;x-requested-with,content-type&quot;);</div></pre></td></tr></table></figure>
<p>2.AngularJS端使用<code>$http.post()</code> ，同时设置请求头信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$http.post(&apos;http://localhost/ajax/getAllIndustryCategoty.pt&apos;,&#123;languageColumn:&apos;name_eu&apos;&#125;,&#123;&apos;Content-Type&apos;:&apos;application/x-www-form-urlencoded&apos;&#125;).success(function(data)&#123;</div><div class="line">  $scope.industries = data;</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
<p><span style="color: #ff0000"><strong>四、实现方式</strong></span></p>
<p><strong>跨域方式一</strong>【<code>JSONP</code>】：</p>
<p>方法一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$http.jsonp(&quot;http://localhost/sitesettings/getBadgeInfo.pt?jsonp=JSON_CALLBACK&amp;siteid=137bd406&quot;).success(function(data)&#123; ... &#125;);</div><div class="line">// The name of the callback should be the string JSON_CALLBACK.</div></pre></td></tr></table></figure>
<p>方法二【返回值，需要使用对应callback方法接收，但如何置于<code>$scope</code>?】：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$http.jsonp(&quot;http://localhost/sitesettings/getBadgeInfo.pt?jsonp=badgeabc&amp;siteid=137bd406&quot;);</div><div class="line">function badgeabc(data)&#123; ... &#125;</div><div class="line"></div><div class="line">public String execute() throws Exception &#123; </div><div class="line"> String result = FAIL;</div><div class="line"> response.setHeader(&quot;&quot;, &quot;&quot;);</div><div class="line"> SiteHandlerAction siteHandlerAction = (SiteHandlerAction)BeansFactory.getBean(SiteHandlerAction.class);</div><div class="line"> BadgeHandlerAction badgeHandlerAction = (BadgeHandlerAction)BeansFactory.getBean(BadgeHandlerAction.class);</div><div class="line"> if(&quot;&quot;.equals(siteid) || siteid == null || StringUtils.isBlank(&quot;jsonp&quot;))&#123;</div><div class="line">  result = FAIL;</div><div class="line"> &#125;else&#123;</div><div class="line">  Site site = siteHandlerAction.find(siteid);</div><div class="line">  UserBadgeStatus userBadgeStatus = badgeHandlerAction.getUserBadgeStatus(site.getId());</div><div class="line">  if(userBadgeStatus != null)&#123;</div><div class="line">   result = &quot;&#123;\&quot;t\&quot;:&quot;+userBadgeStatus.getStyle()+&quot;,\&quot;l\&quot;:&quot;+userBadgeStatus.getSuspend_location()+&quot;,\&quot;s\&quot;:&quot;+site.getId()+&quot;&#125;&quot;;</div><div class="line">   JSONObject jsonObj = JSONObject.fromObject(result);</div><div class="line">   String json = jsonObj.toString();</div><div class="line">   result = jsonp + &quot;(&quot; + json + &quot;)&quot;;</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line"> PrintWriter write = response.getWriter();</div><div class="line"> write.print(result);</div><div class="line"> write.flush();</div><div class="line"> write.close();</div><div class="line"> return NONE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>跨域方式二</strong>【<code>$http.get()</code> 】：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function getAdustryController($scope,$http)&#123;</div><div class="line"> $http.get(&apos;http://localhost/ajax/getAllIndustryCategoty.pt?languageColumn=name_eu&apos;).success(function(data)&#123;</div><div class="line">  $scope.industries = data;</div><div class="line"> &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>跨域方式三</strong>【<code>$http.post()</code>】：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function getAdustryController($scope,$http)&#123;</div><div class="line"> $http.post(&apos;http://localhost/ajax/getAllIndustryCategoty.pt&apos;,&#123;languageColumn:&apos;name_eu&apos;&#125;,&#123;&apos;Content-Type&apos;:&apos;application/x-www-form-urlencoded&apos;&#125;).success(function(data)&#123;</div><div class="line">  $scope.industries = data;</div><div class="line"> &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// java端支持跨域请求</div><div class="line">public String execute()&#123;</div><div class="line"> response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); //允许哪些url可以跨域请求到本域</div><div class="line"> response.setHeader(&quot;Access-Control-Allow-Methods&quot;,&quot;POST&quot;); //允许的请求方法，一般是GET,POST,PUT,DELETE,OPTIONS</div><div class="line"> response.setHeader(&quot;Access-Control-Allow-Headers&quot;,&quot;x-requested-with,content-type&quot;); //允许哪些请求头</div></pre></td></tr></table></figure>
<p>可以跨域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SiteHandlerAction SiteHandler = (SiteHandlerAction) BeansFactory.getBean(SiteHandlerAction.class);</div><div class="line">List list = SiteHandler.getAllIndustryCategory(); //所有的分类集合</div><div class="line">JSONArray jsonArray = JSONArray.fromObject(list); //将list转为json</div><div class="line">String json = jsonArray.toString(); //转为json字符串</div><div class="line">try &#123;</div><div class="line"> PrintWriter write = response.getWriter();</div><div class="line"> write.print(json);</div><div class="line"> write.close();</div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line"> e.printStackTrace();</div><div class="line">&#125;</div><div class="line">return NONE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;span style=&quot;color: #ff0000&quot;&gt;跨域，前端开发中经常遇到的问题，AngularJS实现跨域方式类似于Ajax，下面是AngularJS中使用$http实现跨域请求数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AngularJS XMLHttpRequest：&lt;/strong&gt;$http用于读取远程服务器的数据&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$http.post(url, data, [config]).success(function()&amp;#123; ... &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$http.get(url, [config]).success(function()&amp;#123; ... &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$http.get(url, [config]).success(function()&amp;#123; ... &amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="angular" scheme="http://yoursite.com/categories/angular/"/>
    
    
      <category term="angular" scheme="http://yoursite.com/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>利用node搭建简单代理服务器</title>
    <link href="http://yoursite.com/2016/08/12/%E8%BD%BB%E6%9D%BE%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2016/08/12/轻松搭建简单代理服务器/</id>
    <published>2016-08-12T12:12:56.000Z</published>
    <updated>2017-02-24T17:51:53.941Z</updated>
    
    <content type="html"><![CDATA[<p><strong>环境</strong><br>安装node<br>菜鸟教程：<a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="external">http://www.runoob.com/nodejs/nodejs-install-setup.html</a></p>
<p><strong>开始搭建</strong><br>安装依赖框架<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install --save express</div><div class="line">npm install --save express-http-proxy</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>开始搭建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//第一步引包</div><div class="line">const express = require(&apos;express&apos;);</div><div class="line">const path = require(&apos;path&apos;);</div><div class="line">const http = require(&apos;http&apos;);</div><div class="line">const proxy = require(&apos;express-http-proxy&apos;);</div><div class="line"></div><div class="line">const app = express();</div><div class="line"></div><div class="line">//第二步处理路由</div><div class="line">app.use(express.static(path.join(__dirname, &apos;../&apos;)));</div><div class="line"></div><div class="line">const proxyUrl = &apos;http://127.0.0.1:3000&apos;;</div><div class="line"></div><div class="line">// 只要是以 /api/** 开头的请求路径</div><div class="line">// 则直接通过 proxy 中间件代理将请求原封不动的转发到指令的 API 服务器</div><div class="line">// 然后将接收到 API 服务器的响应数据原封不动的响应给自己的当前这个请求</div><div class="line">app.use(&apos;/api&apos;, proxy(proxyUrl));</div><div class="line"></div><div class="line">app.listen(5000, () =&gt; &#123;</div><div class="line">  console.log(&apos;Proxy Server is running at port 5000...&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;环境&lt;/strong&gt;&lt;br&gt;安装node&lt;br&gt;菜鸟教程：&lt;a href=&quot;http://www.runoob.com/nodejs/nodejs-install-setup.html&quot;&gt;http://www.runoob.com/nodejs/nodejs-install-setup.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开始搭建&lt;/strong&gt;&lt;br&gt;安装依赖框架&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm install --save express&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;npm install --save express-http-proxy&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技能" scheme="http://yoursite.com/categories/%E6%8A%80%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>ajax跨域问题处理</title>
    <link href="http://yoursite.com/2016/06/23/ajax%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2016/06/23/ajax跨域问题处理/</id>
    <published>2016-06-23T04:24:22.000Z</published>
    <updated>2017-02-24T17:54:20.707Z</updated>
    
    <content type="html"><![CDATA[<p><strong>浏览器不允许Ajax跨站请求，所以存在Ajax跨域问题，下面是两种办法解决</strong></p>
<p>1、在请求页面上使用Access-Control-Allow-Origin标头。</p>
<p>　　使用如下标头可以接受全部网站请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">header(&apos;Access-Control-Allow-Origin:*&apos;)</div></pre></td></tr></table></figure>
<p>使用如下标头可以接受指定网站请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">header(&apos;Access-Control-Allow-Origin:http://www.abc.com&apos;)</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>所以，服务器写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">header(&apos;Access-Control-Allow-Origin:*&apos;);</div><div class="line"></div><div class="line">die( json_encode(array(&apos;msg&apos;=&gt;&apos;msg....&apos;)) );</div></pre></td></tr></table></figure>
<p>　　ajax写法和平常一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot; class=&quot;&quot;&gt;</div><div class="line">&lt;head&gt;http://i.cnblogs.com/EditPosts.aspx?opt=1</div><div class="line">&lt;meta charset=&quot;utf-8&quot; /&gt;</div><div class="line">&lt;title&gt;测试&lt;/title&gt;</div><div class="line">&lt;script src=&quot;http://www.ysont.cn/plugs/cookie/js/jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;script&gt;</div><div class="line">  $.ajax(&#123;</div><div class="line">    url:&apos;http://192.168.1.124/homekoo.com/zde/cors_1.php&apos;,</div><div class="line">    dataType:&apos;json&apos;,</div><div class="line">    success:function(data)&#123;</div><div class="line">      alert(data.msg);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>2、使用jsonp跨域请求。</p>
<p>　　服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$data = json_encode(array(&apos;msg&apos;=&gt;&apos;msg....&apos;));</div><div class="line">die( $_REQUEST[&apos;function_name_index&apos;].&apos;(&apos;.$data.&apos;)&apos; );</div></pre></td></tr></table></figure>
<p> 　　ajax请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot; class=&quot;&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;meta charset=&quot;utf-8&quot; /&gt;</div><div class="line">&lt;title&gt;测试&lt;/title&gt;</div><div class="line">&lt;script src=&quot;http://www.ysont.cn/plugs/cookie/js/jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;script&gt;</div><div class="line">  $.ajax(&#123;</div><div class="line">    url:&apos;http://192.168.1.124/homekoo.com/zde/cors_1.php&apos;,</div><div class="line">    dataType:&apos;jsonp&apos;,</div><div class="line">    jsonp:&apos;function_name_index&apos;,</div><div class="line">    jsonpCallback:&apos;function_name&apos;,</div><div class="line">    success:function(data)&#123;</div><div class="line">      alert(data.msg);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>在ajax请求中，使用jsonp数据格式，所以讲dataType参数设置为jsonp，平常，还加到了jsonp和jsonpCallback两个参数，结合代码，不难看出这两个参数作用：<br><strong>jsonp的作用是设置服务器获取回调函数名称参数的下标参数，jsonpCallback的作用就是设置回调函数，相当于input标签中name和value，jsonp对应name，value对应jsonpCallback。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;浏览器不允许Ajax跨站请求，所以存在Ajax跨域问题，下面是两种办法解决&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、在请求页面上使用Access-Control-Allow-Origin标头。&lt;/p&gt;
&lt;p&gt;　　使用如下标头可以接受全部网站请求：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;header(&amp;apos;Access-Control-Allow-Origin:*&amp;apos;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用如下标头可以接受指定网站请求：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;header(&amp;apos;Access-Control-Allow-Origin:http://www.abc.com&amp;apos;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技能" scheme="http://yoursite.com/categories/%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="技巧" scheme="http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>闭包与缓存</title>
    <link href="http://yoursite.com/2016/06/15/%E9%97%AD%E5%8C%85%E4%B8%8E%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2016/06/15/闭包与缓存/</id>
    <published>2016-06-14T16:23:14.000Z</published>
    <updated>2017-02-24T17:54:40.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>闭包就是指可以访问独立的数据的函数！！！</p>
<h3 id="闭包要解决的问题"><a href="#闭包要解决的问题" class="headerlink" title="闭包要解决的问题"></a>闭包要解决的问题</h3><p>函数内部声明的变量无法再函数外部使用</p>
<a id="more"></a>
<h3 id="闭包的基本模型"><a href="#闭包的基本模型" class="headerlink" title="闭包的基本模型"></a>闭包的基本模型</h3><p>function outer(){</p>
<p>var data = “”;</p>
<p>function inner(){</p>
<p>return data;</p>
<p>}</p>
<p>return inner;</p>
<p>}</p>
<p>var fn = outer();</p>
<p>fn();</p>
<h3 id="如何使用闭包返回多个函数"><a href="#如何使用闭包返回多个函数" class="headerlink" title="如何使用闭包返回多个函数"></a>如何使用闭包返回多个函数</h3><p>在函数内部创建一个对象，在对象中封装多个函数，返回对象，在外部就可以使用对象，访问各个方法</p>
<h3 id="闭包的原理"><a href="#闭包的原理" class="headerlink" title="闭包的原理"></a>闭包的原理</h3><p>上级作用域无法访问下级作用域中的变量，但是下级作用域可以访问上级作用域的变量</p>
<h3 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h3><ol>
<li><p>可以用来保护数据，<br>就是变量被保护在外部函数中，想要修改变量只能通过闭包函数，可以在闭包函数中添加一些校验逻辑，以保证数据的合理性以及安全性</p>
</li>
<li><p>可以为函数新增私有的变量</p>
</li>
</ol>
<h3 id="使用闭包解决for循环中注册点击事件的问题"><a href="#使用闭包解决for循环中注册点击事件的问题" class="headerlink" title="使用闭包解决for循环中注册点击事件的问题"></a>使用闭包解决for循环中注册点击事件的问题</h3><p><strong>\@问题</strong></p>
<p>点击事件在触发的时候，访问的i变量已经变成了最后一个值！！</p>
<p><strong>\@解决方案</strong></p>
<p>通过闭包来创建一个函数，该函数拥有自己独立的一个变量j，在循环的时候，将当前的i的值保存一份交给j，再将该闭包函数注册给点击事件，这样在点击事件触发的时候，就不会去访问全局的i，而是使用自己的j</p>
<h3 id="使用闭包解决for循环中setTimeout代码执行的问题"><a href="#使用闭包解决for循环中setTimeout代码执行的问题" class="headerlink" title="使用闭包解决for循环中setTimeout代码执行的问题"></a>使用闭包解决for循环中setTimeout代码执行的问题</h3><p><strong>\@setTimeout</strong></p>
<p>延时器<br>:至少t毫秒后(t秒前在执行主逻辑代码,必须全部执行完在执行回调函数)执行callback函数的代码<br>语法: setTimeout(callback,t)</p>
<p>setTimeout 的特性: JS是单线程的 同时只能处理一件事情</p>
<p>JS中任务分为<br>主要任务(js的只逻辑代码)<br>次要任务(setTimeout和setInterval的回调函数)</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>将数据临时的存储起来以提高访问效率</p>
<h3 id="重要的几种缓存"><a href="#重要的几种缓存" class="headerlink" title="重要的几种缓存"></a>重要的几种缓存</h3><p><strong>\@浏览器缓存</strong></p>
<p>将网站资源，在浏览器端进行保存，用户请求服务器的时候，这些被保存的资源就直接从本地读取，而不会去服务器请求，这样就可以提升用户的访问速率</p>
<p><strong>\@硬件缓存</strong></p>
<p>现将数据从硬盘读取到内存中，再由cpu直接从内存中读取数据，避免了直接让cpu去硬盘中读数据导致系统效率低下的问题</p>
<p><strong>\@CDN Content Delivery Network</strong></p>
<p>在距用户最近的网络节点上缓存一份数据，当用户在去请求数据的时候，就不去较远的服务器获取，而直接在CDN服务器获取，会提升访问效率</p>
<p><strong>\@缓存型数据库</strong></p>
<p>硬盘型数据库（关系型数据库） MySQL Oracle SQLSEVER</p>
<p>内存型数据库（非关系型数据库） Redis MongoDB</p>
<h3 id="使用缓存解决递归实现的斐波那契数列存在的性能问题"><a href="#使用缓存解决递归实现的斐波那契数列存在的性能问题" class="headerlink" title="使用缓存解决递归实现的斐波那契数列存在的性能问题"></a>使用缓存解决递归实现的斐波那契数列存在的性能问题</h3><p><strong>\@性能问题</strong></p>
<p>由于递归实现的斐波那契数列中，存在大量的重复计算，导致性能低下</p>
<p><strong>\@如何解决</strong></p>
<p>使用缓存，将每次计算后的结果进行保存，在下次获取该数据的时候，就直接去缓存中拿，而避免了重复的计算</p>
<h3 id="闭包优化缓存解决递归实现的斐波那契数列存在的性能问题"><a href="#闭包优化缓存解决递归实现的斐波那契数列存在的性能问题" class="headerlink" title="闭包优化缓存解决递归实现的斐波那契数列存在的性能问题"></a>闭包优化缓存解决递归实现的斐波那契数列存在的性能问题</h3><p>function createFib(){</p>
<p>var arr = [];</p>
<p>function fib(n){</p>
<p>var num = arr[n];</p>
<p>if(!num){</p>
<p>if(n \&lt;= 2){</p>
<p>num = 1;</p>
<p>}else{</p>
<p>num = fib(n - 1) + fib(n -2);</p>
<p>}</p>
<p>arr[n] = num;</p>
<p>}</p>
<p>return num;</p>
<p>}</p>
<p>}</p>
<h3 id="JQ缓存实现猜想"><a href="#JQ缓存实现猜想" class="headerlink" title="JQ缓存实现猜想"></a>JQ缓存实现猜想</h3><p>function createCache(){</p>
<p>var cache = {};</p>
<p>var keys = [];</p>
<p>return function(key, value){</p>
<p>if(value != undefined){</p>
<p>cache[key] = value;</p>
<p>if(keys.push(key) > 20){</p>
<p>delete cache[keys.shift()];</p>
<p>}</p>
<p>}</p>
<p>return cache[key];</p>
<p>}</p>
<p>}</p>
<h3 id="jQuery缓存源码分析"><a href="#jQuery缓存源码分析" class="headerlink" title="jQuery缓存源码分析"></a>jQuery缓存源码分析</h3><p>function createCache(){</p>
<p>var keys = [];</p>
<p>function cache(key, value){</p>
<p>if(keys.push(key + “ “) > 20){</p>
<p>delete cache[keys.shift()];</p>
<p>}</p>
<p>return (cache[key + “ “] = value);</p>
<p>}</p>
<p>return cache;</p>
<p>}</p>
<h3 id="沙箱模式"><a href="#沙箱模式" class="headerlink" title="沙箱模式"></a>沙箱模式</h3><blockquote>
<p>  一个封闭的隔离的环境！在JS中通过函数来创建沙箱</p>
</blockquote>
<p>(function(window){</p>
<p>//变量的声明</p>
<p>//主要的功能代码</p>
<p>//如果需要，就通过window对象向外界暴露接口</p>
<p>})(window)</p>
<p><strong>\@沙箱的应用</strong></p>
<ol>
<li><p>框架</p>
</li>
<li><p>组件</p>
</li>
<li><p>插件</p>
</li>
</ol>
<h3 id="函数的调用模式"><a href="#函数的调用模式" class="headerlink" title="函数的调用模式"></a>函数的调用模式</h3><p><strong>\@ 函数调用模式</strong></p>
<p>语法: 函数名()</p>
<p>This的指向: window</p>
<p><strong>\@ 方法调用模式</strong></p>
<p>语法: 对象.方法名()</p>
<p>This的指向: 谁调用就是谁</p>
<p><strong>\@ 构造函数调用模式</strong></p>
<p>语法: new 函数名()</p>
<p>This的指向: new 创建出来的对象</p>
<p><strong>\@ 上下文调用模式</strong></p>
<p>要区分一个函数中的this到底是谁，只需要看他是什么调用模式就好了,<br>函数调用模式就是window, 方法调用模式就是调用方法的对象, 构造函数调用模式就是<br>new创建出来的对象！</p>
<h3 id="两种创建对象的方式"><a href="#两种创建对象的方式" class="headerlink" title="两种创建对象的方式"></a>两种创建对象的方式</h3><p><strong>\@工厂模式</strong></p>
<p>function createObj(name, age){</p>
<p>var obj = new Object();</p>
<p>obj.name = name;</p>
<p>obj.age = age;</p>
<p>return obj;</p>
<p>}</p>
<p>var p = createObj(“郑天羊”, 18);</p>
<p><strong>\@寄生模式</strong></p>
<p>function Person(name, age){</p>
<p>var obj = new Object();</p>
<p>obj.name = name;</p>
<p>obj.age = age;</p>
<p>return obj;</p>
<p>}</p>
<p>var p = new Person(“郑天羊”, 18);</p>
<p><strong>工厂模式和寄生模式都可以用来创建对象，但是调用模式不一样，工厂模式是函数调用模式，寄生模式是构造函数调用模式！</strong></p>
<h3 id="上下文调用模式-call与apply"><a href="#上下文调用模式-call与apply" class="headerlink" title="上下文调用模式(call与apply)"></a>上下文调用模式(call与apply)</h3><p>在前三种调用模式中，this的值都是固定的，无法修改的！上下文（context）调用模式<br>（可以用来改变this的指向, 指的就是函数的调用的环境, this的指向</p>
<p><strong>\@左值和右值</strong></p>
<p>lvalue left value 左值: 左值就是指能够正常的在等号的左边被赋值的值</p>
<p>rvalue right value 右值: 右值就是指能够正常的在等号的右边给别人赋值的值</p>
<p><strong>\@ call</strong></p>
<p>函数名.call(obj, arg1…argN);</p>
<p>//功能：</p>
<p>//1. 调用函数</p>
<p>//2. 改变this指向为第一个参数中的对象</p>
<p>//3. 将第二个及以后的所有参数，依次的传递给函数作为实参</p>
<p><strong>\@ apply</strong></p>
<p>函数名.apply(obj, 数组or伪数组);</p>
<p>//功能：</p>
<p>//1. 调用函数</p>
<p>//2. 改变this指向为第一个参数中的对象</p>
<p>//3. 将第二个参数的数组或者伪数组，中的元素一一拆解，依次传递给函数作为实参</p>
<p><strong>\@注意事项</strong></p>
<ol>
<li>如果call和apply的第一个参数为null或者undefined,this将会指向window</li>
</ol>
<p>2.<br>如果call和apply的第一个参数为值类型的数据，会将值类型的数据转换成其对应的引用类型的数据，this指向该引用类型的数据</p>
<p>tips: 一般情况下apply的传参特性会被使用的居多（转换伪数组为真数组，求最大值）</p>
<h3 id="forEach和map的使用"><a href="#forEach和map的使用" class="headerlink" title="forEach和map的使用"></a>forEach和map的使用</h3><p>都可以用来遍历数组</p>
<p><strong>\@ forEach</strong></p>
<p>数组.forEach(function(value, index, arr){})</p>
<p>//value：正在遍历的数组元素</p>
<p>//index: 正在遍历的数组元素的索引</p>
<p>//arr: 正在遍历的数组</p>
<p><strong>\@ map</strong></p>
<p>数组.map(function(value, index, arr){})</p>
<p>//value：正在遍历的数组元素</p>
<p>//index: 正在遍历的数组元素的索引</p>
<p>//arr: 正在遍历的数组</p>
<p><strong>map是有返回值的，他的返回值是，将每次调用回调函数之后的返回值拼接成一个新的数组，将这个数组返回，作为map的返回值！</strong></p>
<p><strong>\@ map的练习</strong></p>
<ol>
<li>将数组中的元素转成字符串</li>
</ol>
<p>var arr = [1, 2, 3, 4];</p>
<p>var strArr = arr.map(String);</p>
<p>console.log(strArr);</p>
<ol>
<li>生成随机数</li>
</ol>
<p>var arr = [1, 2, 3, 4];</p>
<p>var strArr = arr.map(Math.random);</p>
<p>console.log(strArr);</p>
<h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p>平时在给对象添加属性的时候，使用的都是点语法，或者关联数组语法,<br>通过这两种方式添加的属性，不能手动去设置属性的特性</p>
<p>特性: 就是属性的描述信息，包括能否修改，能否删除，能否遍历等等</p>
<p><strong>\@Object.defineProperty用来给对象添加属性的</strong></p>
<p>Object.defineProperty(obj, propertyName, descriptor);</p>
<p>//obj 就是要给谁添加属性</p>
<p>//propertyName 要添加的属性名</p>
<p>//descriptor 属性的描述信息，也就是特性集合，是一个对象哦~</p>
<p><strong>\@descriptor对象中的属性</strong></p>
<p>* writable 默认为false，表示属性是否可写</p>
<p>* configurable 默认为false， 表示属性是否可以配置（删除）</p>
<p>* enumerable 默认为false， 表示属性是否可以被遍历（for-in）</p>
<p>* value 用来设置属性的值</p>
<p>* get和set方法，和writable一样都可以用来设置属性是否可以写</p>
<p>Object.defineProperty(obj, “name”, {</p>
<p>writable: true,</p>
<p>configurable: true,</p>
<p>enumerable: true,</p>
<p>value: 1888,</p>
<p>set: function(value) {</p>
<p>this.nameValue = value;</p>
<p>},</p>
<p>get: function() {</p>
<p>return this.nameValue;</p>
<p>}</p>
<p>});</p>
<p>属性的设置器setter和访问器getter，分别是两个方法，一个用来设置属性的值，一个用来获取属性的值,<br>setter和getter一般情况下不和writbale一起使用,<br>如果只有set方法没有get方法，那么这个属性就是一个只写属性,<br>如果只有get方法没有set方法，那么这个属性就是一个只读属性</p>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>严格模式的开启</p>
<p>“use strict”</p>
<p>‘use strict’</p>
<p><strong>\@严格模式中的特点</strong></p>
<ol>
<li><p>声明变量必须使用var</p>
</li>
<li><p>对象的属性不能重名</p>
</li>
<li><p>函数的形参名不能重复</p>
</li>
<li><p>八进制常量不允许使用</p>
</li>
<li><p>eval有自己的作用域</p>
</li>
</ol>
<h3 id="事件兼容性处理"><a href="#事件兼容性处理" class="headerlink" title="事件兼容性处理"></a>事件兼容性处理</h3><p><strong>\@三种注册事件的方式</strong></p>
<ol>
<li>onclick简单形式</li>
</ol>
<p>onclick(function(){})</p>
<ol>
<li>addEventListener(type, handler, useCapture) type: 事件类型, handler:<br>事件处理函数, useCapture: 是否使用捕获</li>
</ol>
<p>addEventListener(type, eventHandler, useCapture)</p>
<p>//type:指的就是事件的类型，不带on</p>
<p>//eventHandler: 事件的处理程序，回调函数</p>
<p>//useCapture: 是否在捕获阶段触发事件 默认是false</p>
<ol>
<li>attachEvent(type, handler)</li>
</ol>
<p>attachEvent(type, eventHandler)</p>
<p>//type:指的就是事件类型，带on</p>
<p>//eventHandler：事件处理程序，回调函数</p>
<p><strong>\@ addEventListener和attachEvent的区别</strong></p>
<p>1.<br>回调函数中获取事件对象的方式不一样，addEventListener通过回调函数的参数获取，attachEvent通过window.event获取</p>
<p>2.<br>回调函数中的this指向不一致，addEventListener中this指向当前dom对象，attachEvent中this指向window</p>
<p><strong>\@兼容性处理的通用函数</strong></p>
<p>function registerEvent(ele, type, handler){</p>
<p>if(ele.addEventListener){</p>
<p>ele.addEventListener(type, handler);</p>
<p>}else if(ele.attachEvent){</p>
<p>如果使用下面的代码，那么，在事件触发的时候,回调函数中拿不到事件对象，回调函数中的this也会指向window</p>
<p>//ele.attachEvent(“on”+type,handler)</p>
<p>解决上面问题的关键，就在于，不让系统去调这个回调函数了,而是我们自己去调<br>调用的时候，将事件对象window.event作为实参传递给这个回调函数,<br>this的指向需要更改，改成当前的元素 ele 使用call</p>
<p>ele.attachEvent(“on” + type, function(){</p>
<p>handler.call(ele, window.event);</p>
<p>})</p>
<p>}else{</p>
<p>ele[“on” + type] = handler;</p>
<p>}</p>
<p>}</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h2&gt;&lt;h3 id=&quot;什么是闭包&quot;&gt;&lt;a href=&quot;#什么是闭包&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包&quot;&gt;&lt;/a&gt;什么是闭包&lt;/h3&gt;&lt;p&gt;闭包就是指可以访问独立的数据的函数！！！&lt;/p&gt;
&lt;h3 id=&quot;闭包要解决的问题&quot;&gt;&lt;a href=&quot;#闭包要解决的问题&quot; class=&quot;headerlink&quot; title=&quot;闭包要解决的问题&quot;&gt;&lt;/a&gt;闭包要解决的问题&lt;/h3&gt;&lt;p&gt;函数内部声明的变量无法再函数外部使用&lt;/p&gt;
    
    </summary>
    
      <category term="面向对象" scheme="http://yoursite.com/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>http服务与ajax编程</title>
    <link href="http://yoursite.com/2016/06/09/http%E6%9C%8D%E5%8A%A1%E4%B8%8Eajax%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/06/09/http服务与ajax编程/</id>
    <published>2016-06-08T16:31:30.000Z</published>
    <updated>2017-02-26T03:15:06.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><blockquote>
<p>前言：通俗的讲，能够提供某种服务的机器（计算机）称为服务器</p>
</blockquote>
<h3 id="服务器类型"><a href="#服务器类型" class="headerlink" title="服务器类型"></a>服务器类型</h3><p>按照不同的划分标准，服务可划分为以下类型：</p>
<ol>
<li>按<strong>服务类型</strong>可分为：文件服务器、数据库服务器、邮件服务器、Web服务器等；</li>
<li>按<strong>操作系统</strong>可分为：Linux服务器、Windows服务器等；</li>
</ol>
<a id="more"></a>
<ol>
<li>按<strong>应用软件</strong>可分为 Apache服务器、Nginx 服务器、IIS服务器、Tomcat服务器、<br>weblogic服务器、WebSphere服务器、boss服务器、 Node服务器等；</li>
</ol>
<h3 id="服务器软件"><a href="#服务器软件" class="headerlink" title="服务器软件"></a>服务器软件</h3><p>使计算机具备提供某种服务能力的应用软件，称为服务器软件，<br>通过安装相应的服务软件，然后进行配置后就可以使计算具备了提供某种服务的能力。</p>
<p>常见的服务器软件有：</p>
<ol>
<li>文件服务器：Server-U、FileZilla、VsFTP等（FTP是File Transfer Protocol文件传输协议）；</li>
<li>数据库服务器：oracle、mysql、SQL server、DB2、ACCESS等；</li>
<li>邮件服务器：Postfix、Sendmail等；</li>
<li><strong>HTTP服务器</strong>：Apache、Nginx、IIS、Tomcat、NodeJS等；</li>
</ol>
<h4 id="HTTP服务器"><a href="#HTTP服务器" class="headerlink" title="HTTP服务器"></a>HTTP服务器</h4><p>即网站服务器，主要提供文档(文本、图片、视频、音频)浏览服务，一般安装Apache、Nginx服务器软件。</p>
<p>HTTP服务器可以结合某一编程语言处理业务逻辑，由此进行的开发，通常称之为<strong>服务端开发</strong>。 </p>
<p>常见的运行在服务端的编程语言包括 php、java、.net、Python、Ruby、Perl等。  </p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>具有向服务器<strong>索取服务</strong>能力的终端，如比如 手机、电脑等，通过安装不同的客户端软件，<br>可以获取不同的服务，比如通过QQ获得即时通讯服务、通过迅雷获得下载服务等。</p>
<p>常见的客户端软件：浏览器、QQ、迅雷、Foxmail等。</p>
<p>以浏览器为宿主环境，结合 HTML、CSS、Javascript等技术，而进行的一系列开发，通常称之为<strong>前端开发</strong>。</p>
<h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>所谓IP地址就是给每个连接在互联网上的主机分配的一个32位地址。(就像每部手机能正常通话需要一个号码一样)</p>
<p>查看本机IP地址 ping、ipconfig、ifconfig（linux）</p>
<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>由于IP地址基于数字，不方便记忆，于是便用域名来代替IP地址，域名是一个IP地址的“面具”  </p>
<p>查看域名对应的IP地址 ping</p>
<h3 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h3><p>DNS（Domain Name System）因特网上作为域名和IP地址相互映射的一个分布式数据库，<br>能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p>
<p>简单的说就是记录IP地址和域名之间对应关系的服务。</p>
<p>查找优先级 本机hosts文件、DNS服务器</p>
<p>ipconfig /flushdns 刷新DNS</p>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>端口号是计算机与外界通讯交流的出口，每个端口对应不同的服务。</p>
<p><em>现实生活中，银行不同的窗口办理不同的业务。</em></p>
<p>查看端口占用情况 netstat -an</p>
<p>常见端口号 80、8080、3306、21、22</p>
<h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><h3 id="C-S结构"><a href="#C-S结构" class="headerlink" title="C/S结构"></a>C/S结构</h3><p>即<strong>C</strong>lient、<strong>S</strong>erver</p>
<p>C/S工作流程图</p>
<p><img src="http://olyo5zdej.bkt.clouddn.com/blog/20170226/110652089.png" alt="mark"></p>
<p>在C/S结构的情况下，不同的服务需要安装不同的客户端软件，</p>
<p>比如QQ、迅雷、Foxmail这种情况下安装的软件会越来越多，同时也有许多弊端，</p>
<p>比如A出差，需要在B电脑上查收邮件，但是B电脑并未安装Foxmail等类似的客户端软件，</p>
<p>这样不得不先去下载Foxmail，非常不方便。</p>
<h3 id="B-S结构"><a href="#B-S结构" class="headerlink" title="B/S结构"></a>B/S结构</h3><p>B/S（即<strong>B</strong>roswer、<strong>S</strong>erver）解决了C/S所带来的不便，</p>
<p>将所有的服务都可以通过浏览器来完成（因为基本所有浏览器都安装了浏览器），</p>
<p>但B/S也有一些不利，比如操作稳定性、流畅度等方面相对较弱。</p>
<h2 id="搭建HTTP服务"><a href="#搭建HTTP服务" class="headerlink" title="搭建HTTP服务"></a>搭建HTTP服务</h2><blockquote>
<p>Windows + Apache + Mysql + PHP，首字母组合。</p>
</blockquote>
<h3 id="安装WampServer"><a href="#安装WampServer" class="headerlink" title="安装WampServer"></a>安装WampServer</h3><p>安装wampserver，和普通软件安装无差别，除指定安装路径外，其它默认安装。</p>
<h3 id="管理HTTP服务"><a href="#管理HTTP服务" class="headerlink" title="管理HTTP服务"></a>管理HTTP服务</h3><p>任务图标<strong>绿色为正常启动</strong>状态<br>通过图形控制台可以启动、重启、停止所有服务<br><img src="http://olyo5zdej.bkt.clouddn.com/blog/20170226/110733625.png" alt="mark"></p>
<p>或者单独启动、重启、停止特定服务<br><img src="http://olyo5zdej.bkt.clouddn.com/blog/20170226/110747938.png" alt="mark"></p>
<p><strong>注意事项：</strong><br>1、检查网络是不是通的 ping 对方IP<br>2、检查防火墙是否开启，如果开启将不能正常被访问<br>3、检查访问权限 <strong>Allow from all</strong><br>4、理解默认索引<br>5、确保端口没有被<strong>其它程序</strong>占用<br>6、“#”表示注释<br>7、修改配置要格外小心，禁止<strong>无意修改</strong>其它内容  </p>
<h3 id="配置根目录"><a href="#配置根目录" class="headerlink" title="配置根目录"></a>配置根目录</h3><p>网站根目录是Web服务器上存放网站程序的空间，可通过修改配置文件自定义，如E:/www</p>
<p><strong>具体步骤如下：</strong><br>1、打开配置文件，控制台选择<br><img src="http://olyo5zdej.bkt.clouddn.com/blog/20170226/110818359.png" alt="mark"><br>或者 wampserver安装目录下bin\apache\Apache2.2.21\conf\httpd.conf</p>
<p>2、设定根目录，查找并修改<br><img src="http://olyo5zdej.bkt.clouddn.com/blog/20170226/110835360.png" alt="mark"><br>例如：<br><img src="http://olyo5zdej.bkt.clouddn.com/blog/20170226/110851081.png" alt="mark"><br>这样就指定了 “E:/www/“为存放网站的根目录。</p>
<p>3、配置根目录，查找<br><img src="http://olyo5zdej.bkt.clouddn.com/blog/20170226/110932227.png" alt="mark"><br>修改成<br><img src="http://olyo5zdej.bkt.clouddn.com/blog/20170226/110945411.png" alt="mark"></p>
<p>4、修改完后，并不能立即生效，需要  <strong>重启Apache</strong><br>   <strong>注：可以指定任意目录为根目录</strong></p>
<h3 id="网站部署"><a href="#网站部署" class="headerlink" title="网站部署"></a>网站部署</h3><p>将我们制作好的网页<strong>拷贝</strong>到配置好的根目录下，浏览器访问127.0.0.1即可。</p>
<h3 id="配置虚拟主机"><a href="#配置虚拟主机" class="headerlink" title="配置虚拟主机"></a>配置虚拟主机</h3><p>在一台Web服务器上，我们可以通过配置虚拟主机，然后分别设定根目录，实现对多个网站的管理。</p>
<p>具体步骤如下：  </p>
<p>1、开启虚拟主机辅配置，在httpd.conf 中找到  </p>
<p><img src="http://olyo5zdej.bkt.clouddn.com/blog/20170226/111000305.png" alt="mark"></p>
<p>去掉前面的#号注释，开启虚拟主机配置</p>
<p>2、配置虚拟主机，打开conf/extra/httpd-vhosts.conf   </p>
<p><img src="http://olyo5zdej.bkt.clouddn.com/blog/20170226/111017050.png" alt="mark"></p>
<p>分别修改以下三项  </p>
<p>DocumentRoot “E:/www/example”<br>ServerName “example.com “<br>ServerAlias “www.example.com”  </p>
<p>其它项无需指定。</p>
<p>3、修改DNS（hosts）文件<br>打开C:\Windows\System32\drivers\etc\hosts<br>目录是固定的<br><img src="http://olyo5zdej.bkt.clouddn.com/blog/20170226/111034867.png" alt="mark"><br>注：修改hosts文件权限</p>
<p>4、重启Apache</p>
<p>5、浏览器访问www.example.com</p>
<h2 id="PHP基础"><a href="#PHP基础" class="headerlink" title="PHP基础"></a>PHP基础</h2><blockquote>
<p>文件以.php后缀结尾，所有程序包含在&lt;?php <strong> 这里是代码 </strong> ?&gt;<br>避免使用中文目录和中文文件名<br>php页面无法直接打开需要运行在服务器环境当中</p>
</blockquote>
<h3 id="最简单的php程序"><a href="#最简单的php程序" class="headerlink" title="最简单的php程序"></a>最简单的php程序</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">  <span class="comment">// 用来指定编码集</span></div><div class="line">  header(<span class="string">'Content-Type:text/html; charset=utf-8'</span>);</div><div class="line">  <span class="comment">/*这是一个最简单的php程序*/</span></div><div class="line">  <span class="keyword">echo</span> <span class="string">'hello world!'</span>;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>1、变量以$开头 字母/数字/下划线 不能以数字开头<br>2、大小写敏感（区分大小写）</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">// 声明一个变量$a并赋值为10</span></div><div class="line">  $a = <span class="number">10</span>;</div><div class="line"><span class="comment">// 输出一个变量$a</span></div><div class="line">  <span class="keyword">echo</span> $a;</div><div class="line">  <span class="comment">// 声明一个变量$b并赋值为10</span></div><div class="line">  $b = <span class="number">10</span>;</div><div class="line">  <span class="comment">// 输出一个变量$b</span></div><div class="line">  <span class="keyword">echo</span> $b;</div><div class="line">  </div><div class="line">  <span class="comment">// 输出顺序是自上向下的</span></div><div class="line">  <span class="comment">// 相当于 js dcoument.write()</span></div></pre></td></tr></table></figure>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><strong>字符型</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$str = <span class="string">'hello world!'</span>;</div></pre></td></tr></table></figure></p>
<p><strong>整型</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$num = <span class="number">10</span>;</div></pre></td></tr></table></figure></p>
<p><strong>浮点型</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$float = <span class="number">10.5</span>;</div></pre></td></tr></table></figure></p>
<p><strong>布尔型</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$bool = <span class="keyword">true</span>;</div></pre></td></tr></table></figure></p>
<p><strong>数组</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Javascript 数组定义方式 var arr = [1, 2, 3]</span></div><div class="line"><span class="comment">// arr[0]、arr[1]、arr[1]</span></div><div class="line"></div><div class="line"><span class="comment">// PHP 是这样定义数组的</span></div><div class="line"><span class="comment">// 这种方式叫做**索引数组**</span></div><div class="line">$arr = <span class="keyword">array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);  </div><div class="line"></div><div class="line"><span class="comment">// echo $arr[0];</span></div><div class="line"><span class="comment">// echo $arr[2];</span></div><div class="line"></div><div class="line"><span class="comment">// 定义方式和Javascript有区别，但是访问方式是一样的</span></div></pre></td></tr></table></figure></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// var obj = &#123;name: itcast, age: 10&#125;</span></div><div class="line"></div><div class="line"><span class="comment">// PHP另一种定定数组的方式，所表达的意义和Javascript一样，</span></div><div class="line"><span class="comment">// 只是语法格式不一样</span></div><div class="line"><span class="comment">// 这种方式叫做**关联数组**</span></div><div class="line">$arr1 = <span class="keyword">array</span>(<span class="string">'name'</span>=&gt;<span class="string">'itcast'</span>, <span class="string">'age'</span>=&gt;<span class="number">10</span>);</div><div class="line"></div><div class="line"><span class="comment">// echo $arr1['name'];</span></div><div class="line"><span class="comment">// echo $arr1['age'];</span></div></pre></td></tr></table></figure>
<p><strong>对象</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Javascript var obj = &#123;name: itcast, age: 10&#125;</span></div><div class="line"><span class="comment">// PHP需要先创建一个类，下面就是创建过程</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> $name = <span class="string">'itcast'</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> $age = <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$person = <span class="keyword">new</span> Person;</div><div class="line"></div><div class="line"><span class="comment">// PHP访问一个对象属性的语法是不一样的</span></div><div class="line"><span class="keyword">echo</span> $person-&gt;name;</div><div class="line"></div><div class="line"><span class="comment">// obj['name']; obj.name 不行</span></div></pre></td></tr></table></figure></p>
<p><strong>NULL</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//PHP中一种特殊的数据类型，表示空值，即表示没有为该变量设置任何值null(空值)不区分大小写，null和NULL是一样的。</span></div></pre></td></tr></table></figure></p>
<p><strong>单引号&amp;双引号区别： </strong> 单引号内部的变量不会执行双引号会执行<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$name = <span class="string">'小明'</span>;</div><div class="line"></div><div class="line"><span class="keyword">echo</span> <span class="string">'name is $name'</span>;<span class="comment">//输出 name is $name</span></div><div class="line"><span class="keyword">echo</span> <span class="string">'&lt;br&gt;'</span>;</div><div class="line"><span class="keyword">echo</span> <span class="string">"name is $name"</span>;<span class="comment">//输出 name is 小明</span></div></pre></td></tr></table></figure></p>
<p>索引数组、关联数组（了解即可）</p>
<h3 id="运算符-amp-内容输出"><a href="#运算符-amp-内容输出" class="headerlink" title="运算符&amp;内容输出"></a>运算符&amp;内容输出</h3><pre><code>基本与Javascript语法一致  
. 号表示字符串拼接符，Javascript中为+号
</code></pre><p>echo：输出简单数据类型，如字符串、数值<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 连接符</div><div class="line">* Javascript中用+号表示连接符</div><div class="line">* PHP中使用.点号</div><div class="line">*/</div><div class="line"></div><div class="line">$hello = <span class="string">'hello'</span>;</div><div class="line"></div><div class="line">$world = <span class="string">'world!'</span>;</div><div class="line"></div><div class="line"><span class="comment">// PHP连接符用.号</span></div><div class="line"><span class="keyword">echo</span> $hello . <span class="string">' '</span> .$world;</div></pre></td></tr></table></figure></p>
<p>print_r()：输出复杂数据类型，如数组<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$arr = <span class="keyword">array</span>(<span class="string">'itcast'</span>, <span class="string">'今年'</span>, <span class="string">'10岁了'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 只能输出简单类型</span></div><div class="line"><span class="keyword">echo</span> $arr;</div><div class="line"></div><div class="line"><span class="comment">// 可以打印数组，但是输出的是一个数组的结构</span></div><div class="line">print_r($arr);</div></pre></td></tr></table></figure></p>
<p>var_dump()：输出详细信息，如对象、数组（了解）<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$arr = <span class="keyword">array</span>(<span class="string">'itcast'</span>, <span class="string">'今年'</span>, <span class="string">'10岁了'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 只能输出简单类型</span></div><div class="line"><span class="keyword">echo</span> $arr;</div><div class="line"></div><div class="line"><span class="comment">// 输出详细信息</span></div><div class="line">var_dump($arr);</div><div class="line"></div><div class="line">$hello = <span class="string">'hello'</span>;</div><div class="line"><span class="comment">// 输出详细信息</span></div><div class="line">var_dump($hello);</div></pre></td></tr></table></figure></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>基本与Javascript基本一致  </p>
<p>函数名对大小写不敏感<br>默认参数（了解即可）  </p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">// 1、PHP中函数不可以省略参数</span></div><div class="line"><span class="comment">// 2、PHP可以设置默认参数</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span><span class="params">($name=<span class="string">'web developer'</span>)</span> </span>&#123;</div><div class="line">  <span class="keyword">echo</span> $name . <span class="string">'你好!'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sayHello();</div></pre></td></tr></table></figure>
<h3 id="分支，循环语句"><a href="#分支，循环语句" class="headerlink" title="分支，循环语句"></a>分支，循环语句</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 分支控制语句、循环语句</div><div class="line"> * 与Javascript一样</div><div class="line"> * foreach 数组遍历函数，类似Javascript中的 for in</div><div class="line"> */</div><div class="line"> $name = <span class="string">'itcast1'</span>;</div><div class="line"> </div><div class="line"> <span class="keyword">if</span>($name == <span class="string">'itcast'</span>) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">'我已经在'</span> . $name . <span class="string">'学习'</span>;</div><div class="line"> &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">'我还没有学习过编程'</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 分支控制语句、循环语句</div><div class="line"> * 与Javascript一样</div><div class="line"> * foreach 数组遍历函数，类似Javascript中的 for in</div><div class="line"> */</div><div class="line"><span class="comment">// 索引数组</span></div><div class="line">$arr = <span class="keyword">array</span>(<span class="string">'itcast'</span>, <span class="string">'今年'</span>, <span class="string">'10岁了'</span>);</div><div class="line"> </div><div class="line"><span class="comment">// PHP函数，计算数组的长度</span></div><div class="line">$length = count($arr);</div><div class="line"> </div><div class="line"><span class="comment">// echo $length;</span></div><div class="line"> </div><div class="line"><span class="comment">// 和Javascript是一样的</span></div><div class="line"><span class="comment">// for($i=0; $i&lt;$length; $i++) &#123;</span></div><div class="line"><span class="comment">//  echo $arr[$i];</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"> </div><div class="line"><span class="keyword">foreach</span>($arr <span class="keyword">as</span> $k=&gt;$v) &#123;</div><div class="line">    <span class="keyword">echo</span> $k . <span class="string">'~~~'</span> . $v;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="comment">// 关联数组</span></div><div class="line">$arr1 = <span class="keyword">array</span>(<span class="string">'name'</span>=&gt;<span class="string">'itcast'</span>, <span class="string">'age'</span>=&gt;<span class="string">'10'</span>);</div><div class="line"> </div><div class="line"><span class="comment">// 验证关联数组不可以按索引下标来访问</span></div><div class="line"><span class="comment">// echo $arr1[0];</span></div><div class="line"> </div><div class="line"> <span class="comment">//PHP遍历一个关联数组</span></div><div class="line"> <span class="keyword">foreach</span>($arr1 <span class="keyword">as</span> $key=&gt;$val) &#123;</div><div class="line">    <span class="keyword">echo</span> $key . <span class="string">'~~~'</span> . $val;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="comment">// 实际开发都是用foreach来遍历数组的</span></div></pre></td></tr></table></figure>
<h3 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h3><p>表单name属性的是用来提供给服务端接收所传递数据而设置的 </p>
<p>表单action属性设置接收数据的处理程序</p>
<p>表单method属性设置发送数据的方式</p>
<p>当上传文件是需要设置 enctype=”multipart/form-data”，且只能post方式</p>
<p>$_GET接收 get 传值</p>
<p>$_POST接收 post 传值</p>
<p>$_FILES接收文件上传  </p>
<pre><code>move_uploaded_file($_FILES[&apos;image&apos;][&apos;tmp_name&apos;], &apos;test.jpg&apos;);
</code></pre><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"login.php"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>用户：<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"login.php"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>图片：<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"image"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="文件导入-amp-amp-常用php函数"><a href="#文件导入-amp-amp-常用php函数" class="headerlink" title="文件导入&amp;&amp;常用php函数"></a>文件导入&amp;&amp;常用php函数</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">include</span> <span class="string">'07.form.html'</span>;</div><div class="line"></div><div class="line"><span class="keyword">require</span> <span class="string">'07.form.php'</span></div></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$array = <span class="keyword">array</span>(</div><div class="line">    <span class="string">'username'</span>=&gt;<span class="string">'itcast'</span>,</div><div class="line">    <span class="string">'password'</span>=&gt;<span class="string">'123456'</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">echo</span> <span class="string">'获取数组的长度：'</span>.count($array);</div><div class="line"><span class="keyword">echo</span> <span class="string">'&lt;br&gt;'</span>;</div><div class="line"><span class="keyword">echo</span> <span class="string">'判断是否在数组中：'</span>.in_array(<span class="string">'itcast'</span>,$array);</div><div class="line"><span class="keyword">echo</span> <span class="string">'&lt;br&gt;'</span>;</div><div class="line"><span class="keyword">echo</span> <span class="string">'检测数组中是否存在key：'</span>.array_key_exists(<span class="string">'username'</span>,$array);</div><div class="line"><span class="keyword">echo</span> <span class="string">'&lt;br&gt;'</span>;</div></pre></td></tr></table></figure>
<h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>1、用户登录  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"login.php"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>用户：<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">    header(<span class="string">'Content-Type:text/html; charset=utf-8'</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*数据库当中的数据*/</span></div><div class="line">    $userInfo = <span class="keyword">array</span>(</div><div class="line">        <span class="string">'username'</span>=&gt;<span class="string">'itcast'</span>,</div><div class="line">        <span class="string">'password'</span>=&gt;<span class="string">'123456'</span></div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="comment">/*拿到提交过来的数据*/</span></div><div class="line">    $username = $_POST[<span class="string">'username'</span>];</div><div class="line">    $password = $_POST[<span class="string">'password'</span>];</div><div class="line"></div><div class="line">    <span class="comment">/*去匹配数据库当中的数据*/</span></div><div class="line">    <span class="keyword">if</span>($userInfo[<span class="string">'username'</span>] == $username &amp;&amp; $userInfo[<span class="string">'password'</span>] == $password)&#123;</div><div class="line">        header(<span class="string">'refresh:0;url=jdMsite/'</span>);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        header(<span class="string">'refresh:0;url=login.html'</span>);</div><div class="line">    &#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>2、动态网站   </p>
<p><strong>京东首页</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">    header(<span class="string">'Content-Type:text/html; charset=utf-8'</span>);</div><div class="line"></div><div class="line">    $product_list = <span class="keyword">array</span>(</div><div class="line">        <span class="keyword">array</span>(</div><div class="line">        <span class="string">'imgUrl'</span>=&gt;<span class="string">'images/detail01.jpg'</span>,</div><div class="line">        <span class="string">'newPrice'</span>=&gt;<span class="string">'15.00'</span>,</div><div class="line">        <span class="string">'oldPrice'</span>=&gt;<span class="string">'19.00'</span></div><div class="line">        ),</div><div class="line">        <span class="keyword">array</span>(</div><div class="line">        <span class="string">'imgUrl'</span>=&gt;<span class="string">'images/detail02.jpg'</span>,</div><div class="line">        <span class="string">'newPrice'</span>=&gt;<span class="string">'133.00'</span>,</div><div class="line">        <span class="string">'oldPrice'</span>=&gt;<span class="string">'234.00'</span></div><div class="line">        ),</div><div class="line">        <span class="keyword">array</span>(</div><div class="line">        <span class="string">'imgUrl'</span>=&gt;<span class="string">'images/detail01.jpg'</span>,</div><div class="line">        <span class="string">'newPrice'</span>=&gt;<span class="string">'340.00'</span>,</div><div class="line">        <span class="string">'oldPrice'</span>=&gt;<span class="string">'1432.00'</span></div><div class="line">        )</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">include</span> <span class="string">'index.html'</span>;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!--掌上秒杀的内容是会更新的而且是后台更新--&gt;</div><div class="line">&lt;ul class="sk_product"&gt;</div><div class="line">    &lt;?php foreach($product_list as $key =&gt; $val)&#123; ?&gt;</div><div class="line">        &lt;li&gt;</div><div class="line">            &lt;a href="#"&gt;&lt;img src="&lt;?php echo $val['imgUrl'] ?&gt;" alt=""/&gt;&lt;/a&gt;</div><div class="line">            &lt;p class="new_price"&gt;&amp;yen;&lt;?php echo $val['newPrice'] ?&gt;&lt;/p&gt;</div><div class="line">            &lt;p class="old_price"&gt;&amp;yen;&lt;?php echo $val['oldPrice'] ?&gt;&lt;/p&gt;</div><div class="line">        &lt;/li&gt;</div><div class="line">    &lt;?php &#125; ?&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure>
<p><strong>京东分类</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">    header(<span class="string">'Content-Type:text/html; charset=utf-8'</span>);</div><div class="line"></div><div class="line">    $category = <span class="keyword">array</span>(</div><div class="line">        <span class="string">'热门推荐'</span>,</div><div class="line">        <span class="string">'潮流女装'</span>,</div><div class="line">        <span class="string">'品牌男装'</span>,</div><div class="line">        <span class="string">'内衣配饰'</span>,</div><div class="line">        <span class="string">'家用电器'</span>,</div><div class="line">        <span class="string">'电脑办公'</span>,</div><div class="line">        <span class="string">'手机数码'</span>,</div><div class="line">        <span class="string">'母婴频道'</span>,</div><div class="line">        <span class="string">'图书'</span>,</div><div class="line">        <span class="string">'家居家纺'</span>,</div><div class="line">        <span class="string">'居家生活'</span>,</div><div class="line">        <span class="string">'家具建材'</span>,</div><div class="line">        <span class="string">'热门推荐'</span>,</div><div class="line">        <span class="string">'潮流女装'</span>,</div><div class="line">        <span class="string">'品牌男装'</span>,</div><div class="line">        <span class="string">'内衣配饰'</span>,</div><div class="line">        <span class="string">'家用电器'</span>,</div><div class="line">        <span class="string">'电脑办公'</span>,</div><div class="line">        <span class="string">'手机数码'</span>,</div><div class="line">        <span class="string">'母婴频道'</span>,</div><div class="line">        <span class="string">'居家生活'</span>,</div><div class="line">        <span class="string">'手机数码'</span>,</div><div class="line">        <span class="string">'母婴频道'</span>,</div><div class="line">        <span class="string">'图书'</span>,</div><div class="line">        <span class="string">'家居家纺'</span>,</div><div class="line">        <span class="string">'居家生活'</span>,</div><div class="line">        <span class="string">'潮流女装'</span>,</div><div class="line">        <span class="string">'家具建材'</span>,</div><div class="line">        <span class="string">'热门推荐'</span>,</div><div class="line">        <span class="string">'潮流女装'</span>,</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="comment">//echo count($category);</span></div><div class="line"></div><div class="line">    <span class="keyword">include</span> <span class="string">'category.html'</span>;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;!--左侧分类--&gt;</div><div class="line">&lt;div class="jd_cate_left"&gt;</div><div class="line">    &lt;ul&gt;</div><div class="line">        &lt;?php foreach($category as $key=&gt;$val)&#123; ?&gt;</div><div class="line">            &lt;li class="&lt;?php echo $key==1?'now':'' ?&gt;"&gt;&lt;a href="javascript:;"&gt;&lt;?php echo $val ?&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">        &lt;?php &#125; ?&gt;</div><div class="line">    &lt;/ul&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h2 id="网络传输协议"><a href="#网络传输协议" class="headerlink" title="网络传输协议"></a>网络传输协议</h2><h3 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h3><p>1、HTTP、HTTPS 超文本传输协议 </p>
<p>2、FTP 文件传输协议</p>
<p>3、SMTP 简单邮件传输协议</p>
<h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h3><p>超文本传输协议（HTTP，HyperText Transfer Protocol) 网站是基于HTTP协议的，<br>例如网站的图片、CSS、JS等都是基于HTTP协议进行传输的。</p>
<p>HTML  Hypertext Markup Language</p>
<p>HTTP协议是由从客户机到服务器的请求(Request)和从服务器到客户机的响应(Response)进行了约束和规范。</p>
<p>即HTTP协议主要由请求和响应构成。</p>
<p><img src="http://olyo5zdej.bkt.clouddn.com/blog/20170226/111248174.png" alt="mark"></p>
<p>常用请求方法 <strong>POST</strong>、<strong>GET</strong>、PUT、DELETE</p>
<p>我们通过浏览器插件 FireFox httpFox  调试。ctrl shift f2 调用</p>
<h3 id="请求和请求报文"><a href="#请求和请求报文" class="headerlink" title="请求和请求报文"></a>请求和请求报文</h3><p>请求由客户端发起，其规范格式为：请求行、请求头、请求主体。</p>
<ul>
<li><strong>1、请求行</strong></li>
</ul>
<p>由请求方式、请求URL和协议版本构成</p>
<pre><code>GET /day01/code/login.php?username=123&amp;password=123 HTTP/1.1

POST /day01/code/login.php HTTP/1.1
</code></pre><ul>
<li><strong>2、请求头</strong></li>
</ul>
<p>Host：localhost请求的主机</p>
<p>Cache-Control：max-age=0控制缓存</p>
<p>Accept：<em>/</em> 接受的文档MIME类型</p>
<p>User-Agent：很重要</p>
<p>Referer：从哪个URL跳转过来的</p>
<p>Accept-Encoding：可接受的压缩格式</p>
<p>If-None-Match：记录服务器响应的ETag值，用于控制缓存</p>
<p>此值是由服务器自动生成的</p>
<p>If-Modified-Since：记录服务器响应的Last-Modified值</p>
<p>此值是由服务器自动生成的</p>
<ul>
<li><strong>3、请求主体</strong></li>
</ul>
<p>即传递给服务端的数据</p>
<p>注：当以post形式提交表单的时候，请求头里会设置</p>
<p>Content-Type: application/x-www-form-urlencoded，以get形式当不需要</p>
<h3 id="响应和响应报文"><a href="#响应和响应报文" class="headerlink" title="响应和响应报文"></a>响应和响应报文</h3><p>响应由服务器发出，其规范格式为：状态行、响应头、响应主体。</p>
<ul>
<li><strong>1、状态行</strong></li>
</ul>
<p>由协议版本号、状态码和状态信息构成<br>    HTTP/1.1 200 OK</p>
<ul>
<li><strong>2、响应头</strong></li>
</ul>
<p>Date：响应时间</p>
<p>Server：服务器信息</p>
<p>Last-Modified：资源最后修改时间 由服务器自动生成</p>
<p>ETag：资源修改后生成的唯一标识</p>
<p>由服务器自动生成</p>
<p>Content-Length：响应主体长度</p>
<p>Content-Type：响应资源的类型</p>
<ul>
<li><strong>3、响应主体</strong></li>
</ul>
<p>即服务端返回给客户端的内容；</p>
<ul>
<li>状态码</li>
</ul>
<p>常见的有200代表成功、304文档未修改、403没有权限、404未找到、500服务器错误</p>
<p><img src="http://olyo5zdej.bkt.clouddn.com/blog/20170226/111327964.png" alt="mark"><br><img src="http://olyo5zdej.bkt.clouddn.com/blog/20170226/111340331.png" alt="mark"></p>
<h2 id="AJAX编程"><a href="#AJAX编程" class="headerlink" title="AJAX编程"></a>AJAX编程</h2><blockquote>
<p>即 Asynchronous [e’sɪŋkrənəs] Javascript And XML，<br>AJAX 不是一门的新的语言，而是对现有技术的综合利用。<br>本质是在HTTP协议的基础上以异步的方式与服务器进行通信。</p>
</blockquote>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>指某段程序执行时不会阻塞其它程序执行，其表现形式为程序的执行顺序不依赖程序本身的书写顺序，相反则为同步。</p>
<p><strong>其优势在于不阻塞程序的执行，从而提升整体执行效率。</strong></p>
<p>XMLHttpRequest可以以异步方式的处理程序。</p>
<h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h3><p>浏览器内建对象，用于在后台与服务器通信(交换数据) ，<br>由此我们便可实现对网页的部分更新，而不是刷新整个页面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*js 内置的 http 请求对象  XMLHttpRequest*/</span></div><div class="line"></div><div class="line"><span class="comment">/*1.怎么使用 这个内置对象*/</span></div><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest;</div><div class="line"></div><div class="line"><span class="comment">/*2.怎么样去组请求*/</span></div><div class="line"><span class="comment">/*请求的行*/</span></div><div class="line">xhr.open(<span class="string">'post'</span>,<span class="string">'01.php'</span>);</div><div class="line"></div><div class="line"><span class="comment">/*请求头*/</span></div><div class="line"><span class="comment">//get  没有必要设置</span></div><div class="line"><span class="comment">//post 必须设置 Content-Type: application/x-www-form-urlencoded</span></div><div class="line">xhr.setRequestHeader(<span class="string">'Content-Type'</span>,<span class="string">'application/x-www-form-urlencoded'</span>);</div><div class="line"></div><div class="line"><span class="comment">/*请内容*/</span></div><div class="line"><span class="comment">/*3.发送请求*/</span></div><div class="line">xhr.send(<span class="string">"name=xjj&amp;age=10"</span>);</div></pre></td></tr></table></figure>
<h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><p>HTTP请求3个组成部分与XMLHttpRequest方法的对应关系</p>
<p>1、请求行</p>
<pre><code>xhr.open(&apos;post&apos;,&apos;01.php&apos;);
</code></pre><p>2、请求头</p>
<pre><code>xhr.setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;);
get请求可以不设置
</code></pre><p>3、请求主体</p>
<pre><code>xhr.send(&quot;name=xjj&amp;age=10&quot;);
get可以传空
</code></pre><p><strong>注意书写顺序</strong></p>
<h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><p>HTTP响应是由服务端发出的，作为客户端更应关心的是响应的结果。</p>
<p>HTTP响应3个组成部分与XMLHttpRequest方法或属性的对应关系。</p>
<p>由于服务器做出响应需要时间（比如网速慢等原因），所以我们需要监听服务器响应的状态，然后才能进行处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'ok'</span>);</div><div class="line">    <span class="built_in">console</span>.log(xhr.responseText);</div><div class="line">    <span class="comment">/*把内容渲染在页面当中*/</span></div><div class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'#result'</span>).innerHTML = xhr.responseText;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>**readyState**
0：请求未初始化（还没有调用 open()）。  
1：请求已经建立，但是还没有发送（还没有调用 send()）。  
2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。  
3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。  
4：响应已完成；您可以获取并使用服务器的响应了。
</code></pre><p>onreadystatechange是Javascript的事件的一种，其意义在于监听XMLHttpRequest的状态</p>
<p>1、获取状态行（包括状态码&amp;状态信息）</p>
<pre><code>xhr.status 状态码

xhr.statusText 状态码信息
</code></pre><p>2、获取响应头</p>
<pre><code>xhr.getResponseHeader(&apos;Content-Type&apos;);
xhr.getAllResponseHeaders();
</code></pre><p>3、响应主体  </p>
<pre><code>xhr.responseText
xhr.responseXML
</code></pre><p>我们需要检测并判断响应头的MIME类型后确定使用request.responseText或者request.responseXML</p>
<h4 id="API详解"><a href="#API详解" class="headerlink" title="API详解"></a>API详解</h4><pre><code>xhr.open() 发起请求，可以是get、post方式
xhr.setRequestHeader() 设置请求头
xhr.send() 发送请求主体get方式使用xhr.send(null)
xhr.onreadystatechange = function () {} 监听响应状态
xhr.status表示响应码，如200
xhr.statusText表示响应信息，如OK
xhr.getAllResponseHeaders() 获取全部响应头信息
xhr.getResponseHeader(&apos;key&apos;) 获取指定头信息
xhr.responseText、xhr.responseXML都表示响应主体
</code></pre><p> 注：GET和POST请求方式的差异（面试题）</p>
<p> 1、GET没有请求主体，使用xhr.send(null)</p>
<p> 2、GET可以通过在请求URL上添加请求参数</p>
<p> 3、POST可以通过xhr.send(‘name=itcast&amp;age=10’)</p>
<p> 4、POST需要设置</p>
<p> 5、GET效率更好（应用多）</p>
<p> 6、GET大小限制约4K，POST则没有限制</p>
<p> 问题？如何获取复杂数据呢？</p>
<h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><p>1、必须有一个根元素<br>2、不可有空格、不可以数字或.开头、大小写敏感<br>3、不可交叉嵌套<br>4、属性双引号（浏览器自动修正成双引号了）<br>5、特殊符号要使用实体<br>6、注释和HTML一样<br>虽然可以描述和传输复杂数据，但是其解析过于复杂并且体积较大，所以实现开发已经很少使用了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">arrayList</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">src</span>&gt;</span>images/banner.jpg<span class="tag">&lt;/<span class="name">src</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">newPirce</span>&gt;</span>12.00<span class="tag">&lt;/<span class="name">newPirce</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">oldPrice</span>&gt;</span>30.00<span class="tag">&lt;/<span class="name">oldPrice</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">src</span>&gt;</span>images/banner.jpg<span class="tag">&lt;/<span class="name">src</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">newPirce</span>&gt;</span>12.00<span class="tag">&lt;/<span class="name">newPirce</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">oldPrice</span>&gt;</span>30.00<span class="tag">&lt;/<span class="name">oldPrice</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">arrayList</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> </div><div class="line">    header(<span class="string">'Content-Type:text/xml;charset=utf-8'</span>);</div><div class="line">    <span class="comment">/*以xml格式传输数据的时候要求响应内容格式是   text/xml*/</span></div><div class="line"></div><div class="line">    <span class="comment">/*file_get_contents 获取文件内容*/</span></div><div class="line">    $xml = file_get_contents(<span class="string">'01.xml'</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*输出xml内容*/</span></div><div class="line">    <span class="keyword">echo</span> $xml;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest;</div><div class="line">xhr.open(<span class="string">'get'</span>,<span class="string">'01.php'</span>);</div><div class="line">xhr.send(<span class="literal">null</span>);</div><div class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(xhr.status == <span class="number">200</span> &amp;&amp; xhr.readyState == <span class="number">4</span>)&#123;</div><div class="line">        <span class="comment">/*获取到XML格式内容  放回的是DOM对象  document*/</span></div><div class="line">        <span class="keyword">var</span> xml = xhr.responseXML;</div><div class="line">        <span class="comment">/*通过选着器可以获取到xml的数据*/</span></div><div class="line">        <span class="built_in">console</span>.log(xml.querySelectorAll(<span class="string">'array'</span>)[<span class="number">0</span>].querySelector(<span class="string">'src'</span>).innerHTML);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>即 JavaScript Object Notation，另一种轻量级的文本数据交换格式，独立于语言。</p>
<p>1、数据在名称/值对中<br>2、数据由逗号分隔(最后一个健/值对不能带逗号)<br>3、花括号保存对象方括号保存数组<br>4、使用双引号  </p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  &#123;<span class="attr">"src"</span>:<span class="string">"images/detail01.jpg"</span>,<span class="attr">"oldPrice"</span>:<span class="string">"10.12"</span>,<span class="attr">"newPrice"</span>:<span class="string">"130.00"</span>&#125;,</div><div class="line">  &#123;<span class="attr">"src"</span>:<span class="string">"images/detail02.jpg"</span>,<span class="attr">"oldPrice"</span>:<span class="string">"1.00"</span>,<span class="attr">"newPrice"</span>:<span class="string">"11.00"</span>&#125;,</div><div class="line">  &#123;<span class="attr">"src"</span>:<span class="string">"images/detail03.jpg"</span>,<span class="attr">"oldPrice"</span>:<span class="string">"100.00"</span>,<span class="attr">"newPrice"</span>:<span class="string">"1000.00"</span>&#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>JSON数据在不同语言进行传输时，类型为字符串，不同的语言各自也都对应有解析方法，需要解析完成后才能读取</p>
<p><strong>1、PHP解析方法</strong><br>json_encode()、json_decode()<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> </div><div class="line">    header(<span class="string">'Content-Type:text/html;charset=utf-8'</span>);</div><div class="line">    <span class="comment">/*以json格式传输数据的时候要求响应内容格式是   application/json*/</span></div><div class="line">    <span class="comment">/*注意也可以不设置  但是这遵循的一个规范*/</span></div><div class="line"></div><div class="line">    <span class="comment">/*file_get_contents 获取文件内容*/</span></div><div class="line">    $json = file_get_contents(<span class="string">'01.json'</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*输出json内容*/</span></div><div class="line">    <span class="keyword">echo</span> $json;</div><div class="line">    <span class="keyword">echo</span> <span class="string">'&lt;br&gt;&lt;br&gt;'</span>;</div><div class="line"></div><div class="line">    $array = <span class="keyword">array</span>(</div><div class="line">        <span class="keyword">array</span>(<span class="string">'src'</span>=&gt;<span class="string">'images/detail01.jpg'</span>,<span class="string">'newPrice'</span>=&gt;<span class="string">'12.00'</span>,<span class="string">'oldPrice'</span>=&gt;<span class="string">'455.00'</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">'src'</span>=&gt;<span class="string">'images/detail02.jpg'</span>,<span class="string">'newPrice'</span>=&gt;<span class="string">'65.00'</span>,<span class="string">'oldPrice'</span>=&gt;<span class="string">'878.00'</span>),</div><div class="line">        <span class="keyword">array</span>( <span class="string">'src'</span>=&gt;<span class="string">'images/detail01.jpg'</span>,<span class="string">'newPrice'</span>=&gt;<span class="string">'100.00'</span>,<span class="string">'oldPrice'</span>=&gt;<span class="string">'1000.00'</span>)</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="comment">/*将php数组转化成json字符*/</span></div><div class="line">    $json_array = json_encode($array);</div><div class="line">    <span class="keyword">echo</span> $json_array;</div><div class="line">    <span class="keyword">echo</span> <span class="string">'&lt;br&gt;&lt;br&gt;'</span>;</div><div class="line"></div><div class="line">    <span class="comment">/*将json字符转化成php数组*/</span></div><div class="line">    $array_json = json_decode($json_array);</div><div class="line">    <span class="keyword">echo</span> $array_json;</div><div class="line">    <span class="keyword">echo</span> <span class="string">'&lt;br&gt;&lt;br&gt;'</span>;</div><div class="line"><span class="meta">?&gt;</span></div><div class="line">```  </div><div class="line">**<span class="number">1</span>、Javascript 解析方法**  </div><div class="line">JSON对象  JSON.parse()、JSON.stringify()；  </div><div class="line">JSON兼容处理json2.js  </div><div class="line">总结：JSON体积小、解析方便且高效，在实际开发成为首选。</div><div class="line">```javascript</div><div class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest;</div><div class="line">    xhr.open(<span class="string">'get'</span>,<span class="string">'01.php'</span>);</div><div class="line">    xhr.send(<span class="keyword">null</span>);</div><div class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(xhr.status == <span class="number">200</span> &amp;&amp; xhr.readyState == <span class="number">4</span>)&#123;</div><div class="line">            <span class="comment">/*获取仅仅是字符串*/</span></div><div class="line">            <span class="keyword">var</span> text = xhr.responseText;</div><div class="line">            </div><div class="line">            <span class="comment">/*需要把字符串转化成JSON对象*/</span></div><div class="line">            <span class="keyword">var</span> json_obj = JSON.parse(text);</div><div class="line">            console.log(json_obj);</div><div class="line">    </div><div class="line">            <span class="comment">/*我们也可以把JSON对象转化成字符串*/</span></div><div class="line">            <span class="keyword">var</span> json_str = JSON.stringify(json_obj);</div><div class="line">            console.log(json_str);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p><strong>关于IE的兼容方面，了解即可。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">XHR</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> xhr;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*如果 try内的程序运行错误  抛出异常  捕捉异常  上面程序当中运行的错误*/</span></div><div class="line">    <span class="keyword">catch</span>(e) &#123;</div><div class="line">        <span class="comment">/*在不同的IE版本下初始  ActiveXObject  需要传入的标识*/</span></div><div class="line">        <span class="keyword">var</span> IEXHRVers =[<span class="string">"Msxml3.XMLHTTP"</span>,<span class="string">"Msxml2.XMLHTTP"</span>,<span class="string">"Microsoft.XMLHTTP"</span>];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;IEXHRVers.length;i++) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                xhr = <span class="keyword">new</span> ActiveXObject(IEXHRVers[i]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">catch</span>(e) &#123;</div><div class="line">                <span class="comment">/*如果出现错误的时候  停止当次的循环*/</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> xhr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="封装ajax工具函数"><a href="#封装ajax工具函数" class="headerlink" title="封装ajax工具函数"></a>封装ajax工具函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * ITCAST WEB</div><div class="line"> * Created by zhousg on 2016/5/24.</div><div class="line"> */</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 1. 请求的类型                type    get post</div><div class="line"> * 2. 请求地址                  url</div><div class="line"> * 3. 是异步的还是同步的         async   false true</div><div class="line"> * 4. 请求内容的格式            contentType</div><div class="line"> * 5. 传输的数据                data    json对象</div><div class="line"> *</div><div class="line"> * 6.响应成功处理函数           success   function</div><div class="line"> * 7.响应失败的处理函数         error     function</div><div class="line"> *</div><div class="line"> * 这些都是动态参数  参数对象  options</div><div class="line"> * */</div><div class="line"></div><div class="line"><span class="comment">/*封装一个函数*/</span></div><div class="line"><span class="built_in">window</span>.$ = &#123;&#125;;</div><div class="line"><span class="comment">/*申明一个ajax的方法*/</span></div><div class="line">$.ajax = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(!options || <span class="keyword">typeof</span> options != <span class="string">'object'</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*请求的类型*/</span></div><div class="line">    <span class="keyword">var</span> type = options.type || <span class="string">'get'</span>;<span class="comment">/*默认get*/</span></div><div class="line">    <span class="comment">/*请求地址 */</span></div><div class="line">    <span class="keyword">var</span> url = options.url || location.pathname;<span class="comment">/*当前的地址*/</span></div><div class="line">    <span class="comment">/*是异步的还是同步的 */</span></div><div class="line">    <span class="keyword">var</span> <span class="keyword">async</span> = (options.async === <span class="literal">false</span>)?<span class="literal">false</span>:<span class="literal">true</span>;<span class="comment">/*默认异步*/</span></div><div class="line">    <span class="comment">/*请求内容的格式 */</span></div><div class="line">    <span class="keyword">var</span> contentType = options.contentType || <span class="string">"text/html"</span>;</div><div class="line"></div><div class="line">    <span class="comment">/*传输的数据 */</span></div><div class="line">    <span class="keyword">var</span> data = options.data || &#123;&#125;;<span class="comment">/*｛name:'',age:''｝*/</span></div><div class="line">    <span class="comment">/*在提交的时候需要转成 name=xjj 这种格式*/</span></div><div class="line"></div><div class="line">    <span class="keyword">var</span> dataStr = <span class="string">''</span><span class="comment">/*数据字符串*/</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> data)&#123;</div><div class="line">        dataStr += key+<span class="string">'='</span>+data[key]+<span class="string">'&amp;'</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dataStr = dataStr &amp;&amp; dataStr.slice(<span class="number">0</span>,<span class="number">-1</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*ajax 编程*/</span></div><div class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line"></div><div class="line">    <span class="comment">/*请求行*/</span></div><div class="line">    <span class="comment">/*(type=='get'?url+'?'+dataStr:url)判断当前的请求类型*/</span></div><div class="line">    xhr.open(type,(type==<span class="string">'get'</span>?url+<span class="string">'?'</span>+dataStr:url),<span class="keyword">async</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*请求头*/</span></div><div class="line">    <span class="keyword">if</span>(type == <span class="string">'post'</span>)&#123;</div><div class="line">        xhr.setRequestHeader(<span class="string">'Content-Type'</span>,<span class="string">'application/x-www-form-urlencoded'</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*请求主体*/</span></div><div class="line">    <span class="comment">/*需要判断请求类型*/</span></div><div class="line">    xhr.send(type==<span class="string">'get'</span>?<span class="literal">null</span>:dataStr);</div><div class="line"></div><div class="line">    <span class="comment">/*监听响应状态的改变  响应状态*/</span></div><div class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="comment">/*请求响应完成并且成功*/</span></div><div class="line">        <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>)&#123;</div><div class="line">            <span class="comment">/*success*/</span></div><div class="line">            <span class="keyword">var</span> data = <span class="string">''</span>;</div><div class="line">            <span class="keyword">var</span> contentType = xhr.getResponseHeader(<span class="string">'Content-Type'</span>);</div><div class="line">            <span class="comment">/*如果我们服务器返回的是xml*/</span></div><div class="line">            <span class="keyword">if</span>(contentType.indexOf(<span class="string">'xml'</span>) &gt; <span class="number">-1</span>)&#123;</div><div class="line">                data = xhr.responseXML;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/*如果我们的服务器返回的是json字符串*/</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(contentType.indexOf(<span class="string">'json'</span>) &gt; <span class="number">-1</span>)&#123;</div><div class="line">                <span class="comment">/*转化json对象*/</span></div><div class="line">                data = <span class="built_in">JSON</span>.parse(xhr.responseText);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/*否则的话他就是字符串*/</span></div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                data = xhr.responseText;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">/*回调 成功处理函数*/</span></div><div class="line"></div><div class="line">            options.success &amp;&amp; options.success(data);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/*计时请求xhr.status不成功  他也需要的响应完成才认作是一个错误的请求*/</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>)&#123;</div><div class="line">            <span class="comment">/*error*/</span></div><div class="line">            options.error &amp;&amp; options.error(<span class="string">'you request fail !'</span>);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">$.post = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</div><div class="line">    options.type = <span class="string">'post'</span>;</div><div class="line">    $.ajax(options);</div><div class="line">&#125;</div><div class="line">$.get = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</div><div class="line">    options.type = <span class="string">'get'</span>;</div><div class="line">    $.ajax(options);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="jquery的ajax"><a href="#jquery的ajax" class="headerlink" title="jquery的ajax"></a>jquery的ajax</h3><ul>
<li>jQuery为我们提供了更强大的Ajax封装</li>
<li>$.ajax({}) 可配置方式发起Ajax请求</li>
<li>$.get() 以GET方式发起Ajax请求</li>
<li>$.post() 以POST方式发起Ajax请求</li>
<li>$(‘form’).serialize() 序列化表单（即格式化key=val&amp;key=val）</li>
<li>url 接口地址</li>
<li>type 请求方式</li>
<li>timeout 请求超时</li>
<li>dataType 服务器返回格式</li>
<li>data 发送请求数据</li>
<li>beforeSend: function () {} 请求发起前调用</li>
<li>success 成功响应后调用</li>
<li>error 错误响应时调用</li>
<li>complete 响应完成时调用（包括成功和失败）</li>
<li>jQuery Ajax介绍</li>
<li><a href="http://www.w3school.com.cn/jquery/jquery_ref_ajax.asp" target="_blank" rel="external">http://www.w3school.com.cn/jquery/jquery_ref_ajax.asp</a></li>
</ul>
<p><strong>具体参考代码</strong></p>
<h2 id="模版引擎"><a href="#模版引擎" class="headerlink" title="模版引擎"></a>模版引擎</h2><h3 id="artTemplate-简介语法模板"><a href="#artTemplate-简介语法模板" class="headerlink" title="artTemplate 简介语法模板"></a>artTemplate 简介语法模板</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/template.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>下载(<a href="https://raw.github.com/aui/artTemplate/master/dist/template.js" target="_blank" rel="external">https://raw.github.com/aui/artTemplate/master/dist/template.js</a>)</p>
<p>编写模版</p>
<pre><code>&lt;script id=&quot;test&quot; type=&quot;text/html&quot;&gt;
&lt;h1&gt;{{title}}&lt;/h1&gt;
&lt;ul&gt;
    {{each list as value i}}
        &lt;li&gt;索引 {{i + 1}} ：{{value}}&lt;/li&gt;
    {{/each}}
&lt;/ul&gt;
&lt;/script&gt;
</code></pre><p>渲染数据</p>
<pre><code>var data = {
    title: &apos;标签&apos;,
    list: [&apos;文艺&apos;, &apos;博客&apos;, &apos;摄影&apos;, &apos;电影&apos;, &apos;民谣&apos;, &apos;旅行&apos;, &apos;吉他&apos;]
};
var html = template(&apos;test&apos;, data);
document.getElementById(&apos;content&apos;).innerHTML = html;
</code></pre><p>简介语法    </p>
<pre><code>{{if admin}}
    {{include 'admin_content'}}

    {{each list}}
        &lt;div&gt;{{$index}}. {{$value.user}}&lt;/div&gt;
    {{/each}}
{{/if}}
</code></pre><h3 id="artTemplate-原生-js-模板语法版"><a href="#artTemplate-原生-js-模板语法版" class="headerlink" title="artTemplate 原生 js 模板语法版"></a>artTemplate 原生 js 模板语法版</h3><p><strong>使用</strong></p>
<p>在页面中引用模板引擎：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/template-native.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>下载(<a href="https://raw.github.com/aui/artTemplate/master/dist/template-native.js" target="_blank" rel="external">https://raw.github.com/aui/artTemplate/master/dist/template-native.js</a>)</p>
<p><strong>表达式</strong></p>
<pre><code>&lt;% 与 %&gt; 符号包裹起来的语句则为模板的逻辑表达式。
</code></pre><p><strong>输出表达式</strong></p>
<p>对内容编码输出：</p>
<pre><code>&lt;%=content%&gt;
</code></pre><p>不编码输出：</p>
<pre><code>&lt;%=#content%&gt;
</code></pre><p>编码可以防止数据中含有 HTML 字符串，避免引起 XSS 攻击。</p>
<p><strong>逻辑</strong></p>
<p>支持使用 js 原生语法</p>
<pre><code>&lt;h1&gt;&lt;%=title%&gt;&lt;/h1&gt;
&lt;ul&gt;
    &lt;%for(i = 0; i &lt; list.length; i ++) {%>
            <li>条目内容 <%=i +="" 1%=""> ：<%=list[i]%></%=list[i]%></%=i></li>
        <%}%&gt; &lt;="" ul&gt;="" <="" code=""></%}%&gt;></code></pre><p>模板不能访问全局对象，公用的方法请参见文档 辅助方法 章节<br>模板包含表达式</p>
<p>用于嵌入子模板。</p>
<pre><code>&lt;% include(&apos;template_name&apos;) %&gt;
</code></pre><p>子模板默认共享当前数据，亦可以指定数据：</p>
<pre><code>&lt;% include(&apos;template_name&apos;, news_list) %&gt;
</code></pre><p>辅助方法</p>
<p>使用template.helper(name, callback)注册公用辅助方法，例如一个基本的 UBB 替换方法：</p>
<pre><code>template.helper(&apos;$ubb2html&apos;, function (content) {
    // 处理字符串...
    return content;
});
</code></pre><p>模板中使用的方式：</p>
<pre><code>&lt;% $ubb2html(content) %&gt;
</code></pre><h2 id="同源-amp-跨域"><a href="#同源-amp-跨域" class="headerlink" title="同源&amp;跨域"></a>同源&amp;跨域</h2><h3 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h3><p>同源策略是浏览器的一种安全策略，所谓同源是指，域名，协议，端口完全相同。</p>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>不同源则跨域<br>例如<a href="http://www.example.com/" target="_blank" rel="external">http://www.example.com/</a></p>
<pre><code>http://api.example.com/detail.html  不同源 域名不同  
https//www.example.com/detail.html   不同源 协议不同  
http://www.example.com:8080/detail.html 不同源 端口不同  
http://api.example.com:8080/detail.html 不同源 域名、端口不同  
https://api.example.com/detail.html 不同源 协议、域名不同  
https://www.example.com:8080/detail.html  不同源 端口、协议不同  
http://www.example.com/detail/index.html  同源  只是目录不同  
</code></pre><h3 id="跨域方案（课外拓展）"><a href="#跨域方案（课外拓展）" class="headerlink" title="跨域方案（课外拓展）"></a>跨域方案（课外拓展）</h3><p>1、顶级域名相同的可以通过domain.name来解决，即同时设置 domain.name = 顶级域名（如example.com）<br>2、document.domain + iframe<br>3、window.name + iframe<br>4、location.hash + iframe<br>5、window.postMessage()  </p>
<p>参考资料<br><a href="http://rickgray.me/2015/09/03/solutions-to-cross-domain-in-browser.html" target="_blank" rel="external">http://rickgray.me/2015/09/03/solutions-to-cross-domain-in-browser.html</a></p>
<h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><blockquote>
<p>JSON with Padding</p>
</blockquote>
<p><strong>1、原理剖析</strong></p>
<p>其本质是利用了<script src=""></script>标签具有可跨域的特性，<br>由服务端返回一个预先定义好的Javascript函数的调用，并且将服务器数据以该函数参数的形式传递过来，<br>此方法需要前后端配合完成。</p>
<pre><code>&lt;!--
当我们用script标签去加载的时候  会把内容解析成js去执行
--&gt;
&lt;script&gt;
    function fuc(data){
        console.log(data.name);
    }
&lt;/script&gt;
&lt;script src=&quot;http://www.guangzhou.com/api.php?callback=fuc&quot;&gt;&lt;/script&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;服务器&quot;&gt;&lt;a href=&quot;#服务器&quot; class=&quot;headerlink&quot; title=&quot;服务器&quot;&gt;&lt;/a&gt;服务器&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;前言：通俗的讲，能够提供某种服务的机器（计算机）称为服务器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;服务器类型&quot;&gt;&lt;a href=&quot;#服务器类型&quot; class=&quot;headerlink&quot; title=&quot;服务器类型&quot;&gt;&lt;/a&gt;服务器类型&lt;/h3&gt;&lt;p&gt;按照不同的划分标准，服务可划分为以下类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按&lt;strong&gt;服务类型&lt;/strong&gt;可分为：文件服务器、数据库服务器、邮件服务器、Web服务器等；&lt;/li&gt;
&lt;li&gt;按&lt;strong&gt;操作系统&lt;/strong&gt;可分为：Linux服务器、Windows服务器等；&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="前端基础" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
      <category term="ajax" scheme="http://yoursite.com/tags/ajax/"/>
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>认识原型与原型链</title>
    <link href="http://yoursite.com/2016/06/03/%E8%AE%A4%E8%AF%86%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2016/06/03/认识原型与原型链/</id>
    <published>2016-06-03T10:25:33.000Z</published>
    <updated>2017-02-24T17:55:21.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型"></a>什么是原型</h3><p>在构建函数创建出来的时候,系统会默认帮构造函数创建并关联一个空的对象,就是对象的原型</p>
<h3 id="原型的作用"><a href="#原型的作用" class="headerlink" title="原型的作用"></a>原型的作用</h3><p>在原型中的所有方法和属性(成员),都可以被和其关联的构造函数创建出来的所有实例共享</p>
<a id="more"></a>
<h3 id="如何访问原型"><a href="#如何访问原型" class="headerlink" title="如何访问原型"></a>如何访问原型</h3><p>构造函数名.prototype</p>
<p>实例.__proto__(不推荐使用,因为是非标准)</p>
<h3 id="原型的使用"><a href="#原型的使用" class="headerlink" title="原型的使用"></a>原型的使用</h3><p>1利用对象的动态特性为原型对象添加成员</p>
<p>function Person(){</p>
<p>}</p>
<p>Person.prototype.sayHi = function(){</p>
<p>console.log(‘我是原型中的sayHi’);</p>
<p>}</p>
<p>2直接替换原型对象</p>
<p>Person.prototype = {</p>
<p>sayHi:function(){</p>
<p>console.log(‘我是原型中的sayHi’);</p>
<p>}</p>
<p>}</p>
<p>var aaa = new Person();</p>
<p>aaa.sayHi();</p>
<h3 id="原型的注意事项"><a href="#原型的注意事项" class="headerlink" title="原型的注意事项"></a>原型的注意事项</h3><p>1当使用对象去访问属性和方法的时候,会先在自身查找,如果没有才去原型查找</p>
<p>2一般情况下只会将方法放在原型中,属性放在对象中</p>
<p>3当替换原型的时候,替换之前创建的的对象和替换之后创建的对象的原型是不一致的</p>
<p>4对象能够访问的原型，就是在对象创建的那一刻，和构造函数关联的那个原型！</p>
<p>5只有在获取属性的时候才会在原型中找.当设置属性的时候,会在自身中找,找不到,就新增</p>
<h3 id="访问原型的方式"><a href="#访问原型的方式" class="headerlink" title="访问原型的方式"></a>访问原型的方式</h3><p>//1 构造函数.prototype</p>
<p>function Person() {</p>
<p>}</p>
<p>var p = new Person();</p>
<p>var yuanxing = Person.prototype;</p>
<p>//2 对象.__proto__</p>
<p>Var yuanxing2 = p.__proto__;</p>
<p>console.log(Person.prototype === p.__proto__)//true</p>
<p>//注意:这是一个非标准属性 (不推荐使用)</p>
<p>//调试过程中使用</p>
<p>//单下划线一般是私有属性(不建议外部使用,怕对内部代码造成伤害)</p>
<p><strong>\@实例化</strong></p>
<p>实例化出来的对象，就可以称作是构造函数的一个实例</p>
<h3 id="原型的属性constructor"><a href="#原型的属性constructor" class="headerlink" title="原型的属性constructor"></a>原型的属性constructor</h3><p>1原型中有一个属性constructor,可以访问构造函数</p>
<p>//Person.prototype访问原型</p>
<p>原型.constructor访问构造函数</p>
<p>2每一个构造函数都有一个name 属性 可以访问自己函数名</p>
<p>//console.log(Person.name);</p>
<p>3用函数替换的方法继承 constructor方向会发生改变,所以在此方法中必须手动添加指向</p>
<p>Person.prototype = {</p>
<p>constructor: Person,</p>
<p>sayHi: function () {</p>
<p>console.log(“Hey, man”);</p>
<p>}</p>
<p>}</p>
<p>console.log(Person.prototype.constructor);</p>
<p>var p = new Person();</p>
<p>console.log(p.constructor);</p>
<p>console.log(p.constructor.name);</p>
<h3 id="继承的实现方式"><a href="#继承的实现方式" class="headerlink" title="继承的实现方式"></a>继承的实现方式</h3><p><strong>1 混入式继承</strong></p>
<p><strong>2 原型继承</strong></p>
<p>2.1 通过混入的方式为原型新增成员,以实现继承</p>
<p>2.2 直接替换原型对象</p>
<p><strong>3 经典继承(兼容问题)</strong></p>
<p>在使用原型继承的时候,需要创建构造函数,并对原型进行响应的操作</p>
<p>Object.create()</p>
<p>var 对象1 = Object.create(对象2);把对象2的当作了对象1(__proto__)的原型</p>
<p><strong>4封装兼容问题</strong></p>
<p>1 检测浏览器 能力if(Object.create)</p>
<p>2 有就直接用</p>
<p>3 没有(else) 就原型继承</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><strong>\@什么是原型链</strong></p>
<p>js中所有的对象都会有原型，原型也是对象，所以原型对象也有原型，这样就形成了一个链式结构，称之为原型链</p>
<p><strong>\@属性的搜索方式</strong></p>
<p>1.当使用对象访问成员的时候，会现在对象自身进行查找，如果找到了，就直接使用</p>
<p>2.如果没有找到，就去对象的原型中进行查找，如果找到了，就直接使用</p>
<p>3.如果没有找到，就沿着原型链，继续向上查找，直到找到null</p>
<p>注意！！设置属性不遵循属性搜索原则！！</p>
<h3 id="Object-prototype-的成员"><a href="#Object-prototype-的成员" class="headerlink" title="Object.prototype 的成员"></a>Object.prototype 的成员</h3><p><strong>\@constructor 指向和原型相关的构造函数</strong></p>
<p><strong>\@hasOwnProperty 判断对象自身是否拥有某个属性</strong></p>
<p>对象.hasOwnProperty(“属性名”)</p>
<p><strong>\@isPrototypeOf 判断当前对象是不是另外一个对象的原型</strong></p>
<p>当前对象.isPrototypeOf(另外一个对象)</p>
<p><strong>\@propertyIsEnumerable 判断属性是否属于对象本身并且可以被遍历</strong></p>
<p>obj.propertyIsEnumerable(“gender”));</p>
<p><strong>\@toString 和 toLocaleString</strong></p>
<p>1 toString和toLocaleString都是将对象转换成字符串的方法</p>
<p>2但是toLocaleString会将对象转换成本地格式的字符串 本地格式是和系统设置相关的！</p>
<p><strong>\@valueOf</strong></p>
<p>1当引用类型的数据和值类型的数据参与运算的时候，会先调用引用类型数据的valueOf方法,获取返回，如果可以参与运算，则直接使用</p>
<p>2如果不能参与运算，则调用toString方法，使用该返回值进行运算</p>
<p><strong>\@__proto__ 指向对象的原型对象！</strong></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h3><p>判断构造函数的原型是不是在对象的原型链上</p>
<p>语法: 对象 instanceof 构造函数</p>
<p>返回值: 布尔值</p>
<h3 id="创建函数的三种方式"><a href="#创建函数的三种方式" class="headerlink" title="创建函数的三种方式"></a>创建函数的三种方式</h3><p><strong>\@函数声明</strong></p>
<p>function 函数名(参数列表){</p>
<p>//函数体</p>
<p>}</p>
<p><strong>\@函数表达式</strong></p>
<p>var 函数名 = function (参数列表){</p>
<p>//函数体</p>
<p>}</p>
<p><strong>\@ Function</strong></p>
<p>var 函数名 = new Function();</p>
<h3 id="Function的使用"><a href="#Function的使用" class="headerlink" title="Function的使用"></a>Function的使用</h3><p><strong>\@不传传参数</strong></p>
<p>var func = new Function(); //创建空函数</p>
<p><strong>\@传一个参数</strong></p>
<p>var func1 = new Function(methodBody);<br>//创建有函数体的函数，methodBody是一个字符串</p>
<p><strong>\@传多个参数</strong></p>
<p>var func2 = new Function(arg1, arg2…argN, methodBody)<br>//创建一个以methodBody为函数体，之前所有的参数为形参名的函数，<br>所有的参数都是字符串！</p>
<p><strong>\@如何解决函数体过长的问题</strong></p>
<p>1 拼接字符串</p>
<p>2 使用模板</p>
<p>3 有兼容问题的解决方案 反引号 ``</p>
<h3 id="eval的使用"><a href="#eval的使用" class="headerlink" title="eval的使用"></a>eval的使用</h3><p>eval是个函数，可以将字符串转换成代码并立即执行！</p>
<p>语法: eval(符合js语法规范的字符串);</p>
<p><strong>\@使用eval处理JSON格式数据的时候的问题</strong></p>
<p>1 JSON和JS的对象的异同</p>
<p>//1.都是键值对的集合</p>
<p>//2.JSON格式的数据的键必须加引号，对象不需要</p>
<p>2 如何把JSON格式的数据转换成js对象</p>
<p>//1.使用JSON对象</p>
<p>//2.如果JSON对象不可用就用 JSON2.js</p>
<p>//3.使用eval</p>
<p>当使用eval处理JSON格式数据的时候，eval会将JSON格式字符串中的大括号{}，当做代码段来解析，所以会报错！</p>
<p><strong>\@解决方案</strong></p>
<p>1 将变量声明也同时放在eval中</p>
<p>var jsonStr = “{key: value}”;</p>
<p>eval(“var obj=” + jsonStr);</p>
<p>2 在json格式的字符串前后拼接小括号</p>
<p>var jsonStr = “{key: value}”;</p>
<p>var obj = eval(“(“ + jsonStr + “)”);</p>
<p><strong>\@ Function和eval的异同</strong></p>
<ol>
<li>都能将字符串转换成代码</li>
</ol>
<p>2.<br>Funciton创建出来的是函数，需要手动去调用，代码才会执行，而eval会直接将字符串转成代码并执行</p>
<p>问题：</p>
<ol>
<li><p>执行效率的问题</p>
</li>
<li><p>安全性问题（XSS）</p>
</li>
</ol>
<h3 id="函数的原型链"><a href="#函数的原型链" class="headerlink" title="函数的原型链"></a>函数的原型链</h3><p>1 js 中所有函数的构造函数都是Function, 包括Funtion自己</p>
<p>2 Funtion是自己的构造函数,也是自己的实例</p>
<p>3 Function构造函数在原型图中可以担任两个角色，一个是构造函数，一个是实例</p>
<p>4 当作为构造函数的时候，访问原型使用 Function.prototype</p>
<p>5但作为实例的时候，访问原型使用Funciton.__proto__</p>
<h3 id="Object和Function的关系"><a href="#Object和Function的关系" class="headerlink" title="Object和Function的关系"></a>Object和Function的关系</h3><p>可以通过instanceof关键字来确定两者的关系， Object和Function互为实例！</p>
<h3 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h3><p>1 arguments是函数内部的一个对象，他是一个伪数组</p>
<p>2 在函数调用的时候，会将函数的实参，依次的存入这个伪数组中。</p>
<p>3 arguments.length 属性，表示函数在调用的时候，传入的实参的个数</p>
<p>4 arguments.callee<br>属性，指的就是arguments对象所在的函数，一般用来在匿名函数中做递归</p>
<h3 id="函数对象的成员"><a href="#函数对象的成员" class="headerlink" title="函数对象的成员"></a>函数对象的成员</h3><p>1 arguments</p>
<p>2 caller<br>函数的调用环境，如果是在全局，则为null，如果是在其他函数当中调用的，那么caller为所在的那个函数</p>
<p>3 length 函数的形参的个数</p>
<p>4 name 函数的名称 函数声明和函数表达式的函数名为正常的函数名，new<br>Function创建出来的函数名为 anonymous</p>
<h3 id="静态成员以及实例成员"><a href="#静态成员以及实例成员" class="headerlink" title="静态成员以及实例成员"></a>静态成员以及实例成员</h3><p><strong>\@静态成员： 通过构造函数访问的成员就是静态成员</strong></p>
<p>一般将工具方法，也就是类似于\$.ajax这种，设置为静态成员</p>
<p><strong>\@实例成员： 通过实例去访问的成员就是实例成员</strong></p>
<p>一般将和对象相关的成员，也就是类似于css方法这种，设置为实例成员</p>
<h2 id="数组-递归-变量提升"><a href="#数组-递归-变量提升" class="headerlink" title="数组,递归,变量提升"></a>数组,递归,变量提升</h2><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><p>indexOf在数组中查找元素的时候返回的元素的索引，没找到返回-1</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p><strong>\@什么是递归</strong></p>
<p>在函数直接或者间接的调用自己，就是递归</p>
<p><strong>\@递归的两个要素</strong></p>
<ol>
<li><p>自己调自己</p>
</li>
<li><p>结束条件</p>
</li>
</ol>
<p><strong>\@化归思想</strong></p>
<p>化繁为简，化难为易的过程， 转化 归结 的简称</p>
<p><strong>\@递归的使用</strong></p>
<ol>
<li><p>前n项和</p>
</li>
<li><p>n的m次方</p>
</li>
<li><p>斐波那契数列</p>
</li>
<li><p>递归获取后代元素（重点！！）</p>
</li>
</ol>
<p>方法1 children</p>
<p>方法2 childNodes nodeType类型判断 1元素 2属性 3文本 8注释</p>
<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><ol>
<li>作用域就是变量起作用的范围</li>
</ol>
<p>2.<br>在代码写好的时候，根据代码的书写结构，就可以确定变量的作用域，这种作用域就是词法作用域</p>
<ol>
<li><p>词法作用域又叫静态作用域</p>
</li>
<li><p>js中没有块级作用域（代码块限定的作用域叫做块级作用域）</p>
</li>
</ol>
<h3 id="变量提升-hoisting"><a href="#变量提升-hoisting" class="headerlink" title="变量提升(hoisting)"></a>变量提升(hoisting)</h3><p><strong>\@JS代码执行分两个阶段：1.预解析阶段 2.执行阶段</strong></p>
<p><strong>\@在预解析阶段，会对代码中所有的变量声明以及函数声明做提升操作，提升到其所在的作用域的最顶上！</strong></p>
<p><strong>\@特殊情况</strong></p>
<ol>
<li><p>函数同名的时候，会全部提升，但是后面的会覆盖掉前面的</p>
</li>
<li><p>函数和变量同名的情况，只会提升函数，忽略掉变量的声明</p>
</li>
<li><p>变量提升是分作用域的</p>
</li>
<li><p>变量提升是分段（script标签）的</p>
</li>
</ol>
<p>5.<br>条件式函数声明（在条件语句中的函数声明），会将条件式函数声明视为函数表达式做处理，只会提升函数名，函数体不提升</p>
<ol>
<li>函数中形参赋值的过程是在变量提升之前！</li>
</ol>
<p>7函数中的形参，就相当于是在函数中声明一个局部的变量</p>
<p>8 重复声明同一个变量的时候, 只会声明第一个, 后面的声明会全部省略掉, 只剩下赋值</p>
<p><strong>\@自调用函数</strong><br>表达式：(function (形参) {})(实参);</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>函数可以创建作用域，函数中又可以声明函数，这样就形成了作用域套作用域的链式结构，称作作用域链</p>
<h3 id="变量搜索原则"><a href="#变量搜索原则" class="headerlink" title="变量搜索原则"></a>变量搜索原则</h3><ol>
<li><p>现在使用变量的作用域中进行查找，如果找到了，就直接使用</p>
</li>
<li><p>如果没有找到，就去上一级作用域链中进行查找，如果找到了，就直接使用</p>
</li>
<li><p>如果没有找到，就沿着作用域链依次向上查找，直到找到全局作用域</p>
</li>
</ol>
<h3 id="绘制作用域链图"><a href="#绘制作用域链图" class="headerlink" title="绘制作用域链图"></a>绘制作用域链图</h3><ol>
<li><p>首先绘制0级作用域链</p>
</li>
<li><p>在全局作用域中查找变量以及函数的声明，用小方块的形式将其画在0级作用域线上</p>
</li>
<li><p>再从0级作用域链中的函数中引出下一级作用域链</p>
</li>
<li><p>重复以上步骤！！！</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;原型&lt;/h2&gt;&lt;h3 id=&quot;什么是原型&quot;&gt;&lt;a href=&quot;#什么是原型&quot; class=&quot;headerlink&quot; title=&quot;什么是原型&quot;&gt;&lt;/a&gt;什么是原型&lt;/h3&gt;&lt;p&gt;在构建函数创建出来的时候,系统会默认帮构造函数创建并关联一个空的对象,就是对象的原型&lt;/p&gt;
&lt;h3 id=&quot;原型的作用&quot;&gt;&lt;a href=&quot;#原型的作用&quot; class=&quot;headerlink&quot; title=&quot;原型的作用&quot;&gt;&lt;/a&gt;原型的作用&lt;/h3&gt;&lt;p&gt;在原型中的所有方法和属性(成员),都可以被和其关联的构造函数创建出来的所有实例共享&lt;/p&gt;
    
    </summary>
    
      <category term="面向对象" scheme="http://yoursite.com/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>什么是面向对象</title>
    <link href="http://yoursite.com/2016/05/28/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2016/05/28/什么是面向对象/</id>
    <published>2016-05-28T10:55:31.000Z</published>
    <updated>2017-02-24T16:27:19.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象-思维方式"><a href="#面向对象-思维方式" class="headerlink" title="面向对象( 思维方式 )"></a>面向对象( 思维方式 )</h2><h3 id="以洗衣服为例"><a href="#以洗衣服为例" class="headerlink" title="以洗衣服为例"></a>以洗衣服为例</h3><p><strong>面向过程的思维方式：</strong></p>
<p>把解决问题的关注点放在了解决问题的每一个详细步骤(过程)上</p>
<p>1.收集脏衣服</p>
<p>2.把脏衣服扔到洗衣机中</p>
<a id="more"></a>
<p>3.设定洗衣程序</p>
<p>4.开始洗衣服</p>
<p>5.拿出衣服晾晒</p>
<p><strong>面向对象的思维方式：</strong></p>
<p>把解决问题的关注点放在了解决问题所需要的一些列的对象上</p>
<p>1.女朋友</p>
<p>2.洗衣机</p>
<h3 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h3><p>万物皆对象</p>
<h3 id="javascript中的对象是什么？"><a href="#javascript中的对象是什么？" class="headerlink" title="javascript中的对象是什么？"></a>javascript中的对象是什么？</h3><p>无序的键值对儿的集合</p>
<h2 id="面向对象举例"><a href="#面向对象举例" class="headerlink" title="面向对象举例"></a>面向对象举例</h2><h3 id="JS封装存在的问题"><a href="#JS封装存在的问题" class="headerlink" title="JS封装存在的问题"></a>JS封装存在的问题</h3><p>问题:</p>
<p>1代码结构混乱 不便于维护</p>
<p>2全局变量增多 造成全局污染</p>
<p>解决:</p>
<p>1对象封装(依然存在相同的问题)</p>
<p>2对象模块化</p>
<h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>现实生活中的继承是指子承父业,</p>
<p>JS中的继承是指就是自己没有的东西,别人有,拿来用就是继承</p>
<blockquote>
<p>  混入式继承(mix-in) 就是用for in 遍历</p>
</blockquote>
<p>var obj1 = {</p>
<p>name:”zz”,</p>
<p>age:18</p>
<p>}</p>
<p>var obj2 = {}</p>
<p>for(var k in obj1){</p>
<p>obj2[k]=obj1[k];</p>
<p>}</p>
<p>console.log(obj2);</p>
<h3 id="多肽-js中不支持多态"><a href="#多肽-js中不支持多态" class="headerlink" title="多肽(js中不支持多态)"></a>多肽(js中不支持多态)</h3><blockquote>
<p>  多肽就是父类指针指向子类对象</p>
</blockquote>
<p>class Parent{</p>
<p>public string name;</p>
<p>public void sayHell(){</p>
<p>}</p>
<p>}</p>
<p>Parent p = new Parent();</p>
<p>class Son:extends Parent{</p>
<p>}</p>
<p>Parent s = new Son();</p>
<h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>var obj = {</p>
<p>name:’zz’,</p>
<p>age:18</p>
<p>}</p>
<p>缺陷: 复用性差</p>
<h3 id="使用内置构造函数Object"><a href="#使用内置构造函数Object" class="headerlink" title="使用内置构造函数Object"></a>使用内置构造函数Object</h3><p>var obj2 = new Object();</p>
<p>obj2.name = “”;</p>
<p>obj2.age = 18;</p>
<p>缺陷:</p>
<p>1创造出来的对象是空对象</p>
<p>2复用性差</p>
<h3 id="自定义构造函数"><a href="#自定义构造函数" class="headerlink" title="自定义构造函数"></a>自定义构造函数</h3><p><strong>\@什么是构造函数</strong></p>
<p>构造函数也是一个函数,一般用于初始化对象</p>
<p><strong>\@构造函数的特点</strong></p>
<p>1.构造函数的首字母大写</p>
<p>2.一般和new关键字一起使用</p>
<p>3.构造函数不需要手动写返回语句(会默认返回新创建出来的对象)</p>
<p>function Pers(name, age, gender){</p>
<p>this.name = name;</p>
<p>this.age = age;</p>
<p>this.gender = gender;</p>
<p>//return [];</p>
<p>}</p>
<p>var myObj = new Pers();</p>
<p><strong>\@构造函数的执行过程</strong></p>
<p>1 使用new关键字 创建对象</p>
<p>2 调用构造函数</p>
<p>3 将构造函数内部的this 指针指向使用new关键字创建出来的对象</p>
<p>4 使用this指针在构造函数内部对对象进行初始化</p>
<p>5 默认将创建的对象返回</p>
<p><strong>\@构造函数的注意项目</strong></p>
<p>1 默认不需要返回值 如果写了</p>
<blockquote>
<p>  1.1如果返回的是值类型的数据 则不会对默认返回值有任何影响</p>
<p>  1.2如果返回的是引用类型的数据 则会将该数据返回</p>
</blockquote>
<p>2 当把构造函数当做普通函数调用的时候 this 指向 window</p>
<p><strong>\@传统构造函数中存在的问题</strong></p>
<p>将函数的声明，放在构造函数外边</p>
<p>在构造函数内部将函数的地址赋值给对象的方法</p>
<p>就可以避免资源浪费，做到所有的对象共享同一个方法</p>
<p>同时也会造成如下的问题：</p>
<p>1.全局变量污染</p>
<p>2.代码结构混乱，不利于维护</p>
<p>3.不安全</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面向对象-思维方式&quot;&gt;&lt;a href=&quot;#面向对象-思维方式&quot; class=&quot;headerlink&quot; title=&quot;面向对象( 思维方式 )&quot;&gt;&lt;/a&gt;面向对象( 思维方式 )&lt;/h2&gt;&lt;h3 id=&quot;以洗衣服为例&quot;&gt;&lt;a href=&quot;#以洗衣服为例&quot; class=&quot;headerlink&quot; title=&quot;以洗衣服为例&quot;&gt;&lt;/a&gt;以洗衣服为例&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;面向过程的思维方式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把解决问题的关注点放在了解决问题的每一个详细步骤(过程)上&lt;/p&gt;
&lt;p&gt;1.收集脏衣服&lt;/p&gt;
&lt;p&gt;2.把脏衣服扔到洗衣机中&lt;/p&gt;
    
    </summary>
    
      <category term="面向对象" scheme="http://yoursite.com/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>canvas三部曲(终章)</title>
    <link href="http://yoursite.com/2016/05/18/canvas%E4%B8%89%E9%83%A8%E6%9B%B2(%E7%BB%88%E7%AB%A0)/"/>
    <id>http://yoursite.com/2016/05/18/canvas三部曲(终章)/</id>
    <published>2016-05-18T12:18:00.000Z</published>
    <updated>2017-02-23T12:37:45.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><p>Canvas 绘图中支持矩阵变换功能. 其中涉及的常用方法有</p>
<ol>
<li><code>CanvasRenderingContext2D.transform()</code></li>
<li><code>CanvasRenderingContext2D.scale()</code></li>
<li><code>CanvasRenderingContext2D.translate()</code></li>
<li><code>CanvasRenderingContext2D.rotate()</code></li>
<li><code>CanvasRenderingContext2D.setTransForm()</code></li>
</ol>
<a id="more"></a>
<p>还有一些方法, 暂时没有普及与确定. 因此这里的几个方法才是最常用的方法.</p>
<h3 id="什么是变换"><a href="#什么是变换" class="headerlink" title="什么是变换"></a>什么是变换</h3><p>计算机图形学是建立在解析几何基础之上的. 也就是说所有绘制的图形都是基于坐标进行计算得到的. 那么利用坐标系位置的调整, 同样的坐标可以得到不同的效果. 例如有一个点 A ( 10, 10 ). 可以在坐标系中绘制出该点.</p>
<p><img src="./imgs/2016-08-12_005104.png" alt=""></p>
<p>如果调整坐标系. 比如将坐标系向右移动 10 个单位, 得到</p>
<p><img src="./imgs/2016-08-12_005920.png" alt=""></p>
<p>此时同样是 A 点, 坐标就变成了 ( 0, 10 ). 然后再把坐标系向上移动 10 个单位, 得到</p>
<p><img src="./imgs/2016-08-12_010818.png" alt=""></p>
<p>那么针对新坐标系, 这个点的坐标就是 ( 0, 0 ). 这个就是坐标变换. 通过移动坐标的位置, 对坐标进行旋转, 以及对坐标轴数据的缩放, 从而使得原有点的坐标发生变化, 或利用原有的坐标点绘制新的效果.</p>
<p>坐标变换有一套完整的数学公式. 利用矩阵可以很容易的表示坐标的所有变换.</p>
<p><img src="./imgs/2016-08-12_012845.png" alt=""></p>
<p>这里的 a, b, c, d, e, f 就刚好是 <code>transform</code> 函数的 参数.</p>
<ol>
<li>其中 a 有时又标记为 m11. 它表示水平缩放.</li>
<li>其中 b 有时又标记为 m12. 它表示水平倾斜.</li>
<li>其中 c 有时又标记为 m21. 它表示垂直倾斜.</li>
<li>其中 d 有时又标记为 m22. 它表示垂直缩放.</li>
<li>其中 e 有时又标记为 dx. 它表示水平移动.</li>
<li>其中 f 有时又标记为 dy. 它表示垂直移动.</li>
</ol>
<p><strong>演示</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">ctx.transform( 1, 0, 0, 1, 0, 0 );</div><div class="line">ctx.fillRect( 0, 0, 100, 100 );</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-12_013849.png" alt=""></p>
<p>这里矩阵变换会比较复杂, 因此在使用中一般使用简单的, 平移, 旋转 和 缩放 的简单 api.</p>
<h3 id="平移变换"><a href="#平移变换" class="headerlink" title="平移变换"></a>平移变换</h3><p>平移变换就是将原有坐标轴进行平行移动, 那么坐标轴移动后就可以使用新坐标来绘制图形了.</p>
<p>语法: <code>CanvasRenderingContext2D.translate( x, y )</code></p>
<p>描述:</p>
<ol>
<li>该方法将坐标进行平移.</li>
<li>x 表示水平移动, 正数向右, 负数向左.</li>
<li>y 表示垂直移动, 正数向下, 负数向上.</li>
<li>变换可以重复调用, 变换是可以累加的.</li>
</ol>
<p>使用该变换, 常常用于绘制不同位置, 但是形状重复的图形.</p>
<p>注意: 变换也会被 “继承”, 开启新路径后依旧保留原先变换.</p>
<h3 id="旋转变换"><a href="#旋转变换" class="headerlink" title="旋转变换"></a>旋转变换</h3><p>语法: <code>CanvasRenderingContext2D.rotate( radian )</code></p>
<p>描述:</p>
<ol>
<li>该方法将坐标轴进行旋转变换.</li>
<li>参数是弧度, 表示旋转的方式. 正数表示顺时针旋转, 负数表示逆时针旋转.</li>
</ol>
<p>该变换常常用于实现旋转动画等.</p>
<h3 id="缩放变换"><a href="#缩放变换" class="headerlink" title="缩放变换"></a>缩放变换</h3><p>语法: <code>CanvasRenderingContext2D.scale( x, y )</code></p>
<p>描述:</p>
<ol>
<li>该方法实现水平与垂直的缩放.</li>
<li>参数 x 控制水平缩放倍率. 传参 1 表示不作缩放, 传入大于 1 的数字表示扩大.</li>
<li>参数 y 控制垂直缩放倍率. 传参 1 表示不作缩放, 传入大于 1 的数字表示扩大.</li>
</ol>
<p>该变换常常用于放大与缩小, 以及反转的效果.</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>前面提到 Canvas 是含有状态的, 也就是说需要修改颜色, 直线样式, 绘图方式等效果时需要开启一个新的状态. 但是有时在绘制过程中需要修改状态, 同时绘制完当前状态后又需要回到之前的状态中继续绘制另外的形状. 那么只有再将修改过的样式载更改回来. 如果在该状态中修改的属性较多, 那么每次在回到之前状态时就有很多的代码.</p>
<p>Canvas 中引入了状态的保持机制. 使用 <code>CanvasRenderingContext2D.save()</code> 方法可以保存当前状态. 如果需要恢复到已经保存的状态, 只需要调用 <code>CanvasRenderingContext2D.restore()</code> 方法即可.</p>
<p>状态保持的机制是基于状态栈实现的. 也就是说 save 一次就存储一个状态. restore 一次就将刚刚存入的恢复. 如果 save 两次, 就需要 restore 两次, 才可以恢复到最先的状态.</p>
<p>一般在封装绘图的时候都会采用开始绘制之前, save 一次, 然后 开启一个新路径, 然后绘制结束后 restore, 然后再开启一个新路径. 这样保持当前状态不会对其他绘图代码构成影响.</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>canvas 在绘制图片的时候, drawImage 方法还支持将一个 canvas 绘制到另一个 canvas 中. 因此使用该功能, 可以在内存中完成复杂的绘图, 将绘制好的半成品再绘制到 canvas 中合成需要的效果.</p>
<h2 id="画布保存"><a href="#画布保存" class="headerlink" title="画布保存"></a>画布保存</h2><p>画布在绘制后实际上就是一张图片, 可以直接右键另存为. 同时也支持使用 js 代码将其保存为 base64 编码的字符串.</p>
<p>语法: <code>Canvas.ToDataURL( type, encoderOptions )</code></p>
<p>描述:</p>
<ol>
<li>该方法可以将画布转换成 base64 格式的数据</li>
<li>type 表示输出类型. 例如: image/png 或 image/jpeg 等</li>
<li>encoderOptions 表示图片输出质量, 其取值在 0 到 1 之间. 如果是 1, 表示无损压缩, 必须使用 image/jpeg 或 image/webp 才起作用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">&lt;img id=&quot;img&quot;/&gt;</div><div class="line">...</div><div class="line">var img = document.getElementById( &apos;img&apos; );</div><div class="line"></div><div class="line">var cas = document.createElement( &apos;canvas&apos; );</div><div class="line">cas.width = 100, cas.height = 100;</div><div class="line">var ctx = cas.getContext( &apos;2d&apos; );</div><div class="line">ctx.fillStyle = &apos;pink&apos;;</div><div class="line">ctx.fillRect( 0, 0, 100, 100 );</div><div class="line"></div><div class="line">var data = cas.toDataURL( &apos;image/png&apos;, 1 );</div><div class="line"></div><div class="line">img.src = data;</div></pre></td></tr></table></figure>
<h2 id="渐变和图案"><a href="#渐变和图案" class="headerlink" title="渐变和图案"></a>渐变和图案</h2><p>绘制图像有两个主要方法, 一个是描边, 一个是填充. 前面介绍过要设置其样式, 可以使用 <code>strokeStyle</code> 和 <code>fillStyle</code> 属性, 只需要给它们提供颜色就可以了. 但是不仅仅是颜色, 它还支持渐变和重复.</p>
<p>相关方法</p>
<ol>
<li><code>CanvasRenderingContext2D.createLinearGradient()</code></li>
<li><code>CanvasRenderingContext2D.createRadialGradient()</code></li>
<li><code>CanvasRenderingContext2D.createPattern()</code></li>
</ol>
<h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><p>语法: <code>CanvasRenderingContext2D.createLinearGradient( x0, y0, x1, y1 )</code></p>
<p>描述:</p>
<ol>
<li>该方法返回一个 CanvasGradient 对象. 用于描述渐变的方式.</li>
<li>该方法有两个参数, 用于表示线型渐变的方向与位置.</li>
<li>使用的时候, 首先创建一个 CanvasGradient 对象, 然后利用 addColorStop 方法添加颜色区间.<ol>
<li>方法语法: <code>CanvasGradient.addColorStop( rate, color )</code>.</li>
<li>该方法用于设置在某个比例位置的颜色是什么. rate 的取值是 0 到 1 之间.</li>
<li>可以添加多个渐变点.</li>
</ol>
</li>
<li>然后将该对象赋值给 <code>*Style</code> 属性即可.</li>
</ol>
<p><strong>案例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">var canvasGradient = ctx.createLinearGradient( 0, 25, 200, 25 );</div><div class="line">canvasGradient.addColorStop( 0, &apos;blue&apos; );</div><div class="line">canvasGradient.addColorStop( 1, &apos;red&apos; );</div><div class="line">ctx.fillStyle = canvasGradient;</div><div class="line"></div><div class="line">ctx.fillRect( 0, 100, 200, 50 );</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-13_013233.png" alt=""></p>
<p>注意: 渐变点的坐标是基于坐标轴来计算的.</p>
<h3 id="放射渐变"><a href="#放射渐变" class="headerlink" title="放射渐变"></a>放射渐变</h3><p>语法: <code>CanvasRenderingContext2D.createRadialGradient( x0, y0, r0, x1, y1, r1 )</code></p>
<p>描述:</p>
<ol>
<li>该方法实现放射渐变, 渐变的是在两个圆之间. 一般会使用两个内含关系的圆.</li>
<li>前三个参数分别表示其中一个圆的圆心的坐标, 以及半径.</li>
<li>后三个参数分别表示另一个圆的圆心的坐标, 以及半径.</li>
<li>绘制渐变效果用法与线性渐变一样.</li>
</ol>
<p><strong>案例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var x = cas.width / 2, y = cas.height / 2, r = 100;</div><div class="line">var g = ctx.createRadialGradient( x + r * 2 / 3, y - r * 2 / 3, 0, x + r / 3, y - r / 3, r * 4 / 3 );</div><div class="line">g.addColorStop( 0, &apos;#fff&apos; );</div><div class="line">g.addColorStop( 1, &apos;#f00&apos; );</div><div class="line">ctx.fillStyle = g;</div><div class="line">ctx.arc( x, y, r, 0, 2 * Math.PI );</div><div class="line">ctx.fill();</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-13_014617.png" alt=""></p>
<h3 id="重复填充"><a href="#重复填充" class="headerlink" title="重复填充"></a>重复填充</h3><p>语法: <code>CanvasRenderingContext2D.createPattern( img, repetition )</code></p>
<p>描述:</p>
<ol>
<li>该方法表示使用图片来填充的设置方法. 需要两个参数, 一个是图片, 一个是重复的方式.</li>
<li>图片允许是 img 标签, 图片, canvas 等对象</li>
<li>可选择的重复方式与 CSS 一致. 有: repeat, repeat-x, repeat-y, no-repeat.</li>
<li>如果是 空或””, 但不是 undefined, 默认就是 repeat.</li>
</ol>
<p>准备一张图片</p>
<p><img src="./imgs/04d91106ecb1ec84b6708cd9796fc772.jpg" alt=""></p>
<p><strong>案例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var img = new Image();</div><div class="line">img.src = &apos;imgs/04d91106ecb1ec84b6708cd9796fc772.jpg&apos;;</div><div class="line">img.onload = function () &#123;</div><div class="line">    var p = ctx.createPattern( img, &apos;repeat&apos; );</div><div class="line">    ctx.fillStyle = p;</div><div class="line">    ctx.fillRect( 50, 50, 550, 350 );</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-13_015514.png" alt=""></p>
<h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><p>在 Canvas 中还可以给绘制的内容设置阴影. 但是一般不这么用, 因为性能不高.</p>
<p>相关属性:</p>
<ol>
<li><code>CanvasRenderingContext2D.shadowBlur</code> 属性表示模糊程度.</li>
<li><code>CanvasRenderingContext2D.shadowColor</code> 属性表示模糊颜色.</li>
<li><code>CanvasRenderingContext2D.shadowOffsetX</code> 属性表示模糊位置 x 坐标偏移.</li>
<li><code>CanvasRenderingContext2D.shadowOffsetY</code> 属性表示模糊位置 y 坐标偏移.</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;变换&quot;&gt;&lt;a href=&quot;#变换&quot; class=&quot;headerlink&quot; title=&quot;变换&quot;&gt;&lt;/a&gt;变换&lt;/h2&gt;&lt;p&gt;Canvas 绘图中支持矩阵变换功能. 其中涉及的常用方法有&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;CanvasRenderingContext2D.transform()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CanvasRenderingContext2D.scale()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CanvasRenderingContext2D.translate()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CanvasRenderingContext2D.rotate()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CanvasRenderingContext2D.setTransForm()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="canvas三部曲" scheme="http://yoursite.com/categories/canvas%E4%B8%89%E9%83%A8%E6%9B%B2/"/>
    
    
      <category term="canvas" scheme="http://yoursite.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>canvas三部曲(进阶)</title>
    <link href="http://yoursite.com/2016/05/12/canvas%E4%B8%89%E9%83%A8%E6%9B%B2(%E8%BF%9B%E9%98%B6)/"/>
    <id>http://yoursite.com/2016/05/12/canvas三部曲(进阶)/</id>
    <published>2016-05-12T12:14:13.000Z</published>
    <updated>2017-02-23T12:37:38.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="绘制形状"><a href="#绘制形状" class="headerlink" title="绘制形状"></a>绘制形状</h2><p>绘制图形不仅仅是利用线条来实现绘图, 还可以有快捷的绘制图形的办法</p>
<ol>
<li>绘制矩形</li>
<li>绘制圆弧</li>
</ol>
<h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><p>绘制矩形的方法</p>
<a id="more"></a>
<ol>
<li><code>CanvasRenderingContext2D.strokeRect</code></li>
<li><code>CanvasRenderingContext2D.fillRect</code></li>
<li><code>CanvasRenderingContext2D.rect</code></li>
</ol>
<p>注意: <code>rect</code> 方法就是矩形路径, 还需要使用 <code>fill</code> 或 <code>stroke</code> 才可以看到效果. 因此一般使用 <code>strokeRect</code> 或 <code>fillRect</code> 直接可以看到结果.</p>
<p>清除矩形区域</p>
<ol>
<li><code>CanvasRenderingContext2D.clearRect</code></li>
</ol>
<h4 id="绘制矩形框"><a href="#绘制矩形框" class="headerlink" title="绘制矩形框"></a>绘制矩形框</h4><p>语法: <code>CanvasRenderingContext2D.strokeRect( x, y, width. height )</code></p>
<p>描述:</p>
<ol>
<li>用来绘制一个矩形. 比起直接使用 <code>moveTo</code> 和 <code>lineTo</code> 方法要简单许多.</li>
<li>该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高.</li>
<li>使用该方法不需要使用 <code>moveTo</code> 方法设置起始点, 也不需要调用 <code>stroke</code> 等绘画方法.</li>
<li>绘制的矩形支持 <code>strokeStyle</code> 设置颜色样式.</li>
</ol>
<p><strong>案例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">ctx.strokeStyle = &apos;red&apos;;</div><div class="line">ctx.strokeRect( 100, 100, 200, 100 );</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-09_233542.png" alt=""></p>
<h4 id="绘制填充矩形"><a href="#绘制填充矩形" class="headerlink" title="绘制填充矩形"></a>绘制填充矩形</h4><p>语法: <code>CanvasRenderingContext2D.fillRect( x, y, width. height )</code></p>
<p>描述:</p>
<ol>
<li>用来绘制一个矩形. 比起直接使用 <code>moveTo</code> 和 <code>lineTo</code> 方法要简单许多.</li>
<li>该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高.</li>
<li>使用该方法不需要使用 <code>moveTo</code> 方法设置起始点, 也不需要调用 <code>stroke</code> 等绘画方法.</li>
<li>绘制的矩形支持 <code>fillStyle</code> 设置颜色样式.</li>
</ol>
<p><strong>案例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">ctx.fillStyle = &apos;green&apos;;</div><div class="line">ctx.fillRect( 100, 100, 200, 100 );</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-09_233846.png" alt=""></p>
<h4 id="清除矩形区域"><a href="#清除矩形区域" class="headerlink" title="清除矩形区域"></a>清除矩形区域</h4><p>语法: <code>CanvasRenderingContext2D.clearRect( x, y, width, height )</code></p>
<p>描述:</p>
<ol>
<li>用于清除画布中的矩形区域的内容.</li>
<li>参数 x, y 表示矩形区域左上角的坐标, width 与 height 表示矩形区域的宽高.</li>
</ol>
<p><strong>案例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">ctx.fillRect( 100, 100, 200, 100 );</div><div class="line">ctx.clearRect( 110, 110, 50, 50 );</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_001845.png" alt=""></p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>利用绘制图形与清除矩形区域, 可以实现简单的动画. 例如代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">var x = 10, y = 10, oldx = 10, oldy = 10;</div><div class="line">var width = 100, height = 50;     </div><div class="line">var intervalId = setInterval(function () &#123;</div><div class="line">    ctx.clearRect( oldx - 1, oldy - 1, width + 2, height + 2 );</div><div class="line"></div><div class="line">    ctx.strokeRect( x, y, width, height );</div><div class="line"></div><div class="line">    oldx = x;</div><div class="line">    oldy = y;</div><div class="line"></div><div class="line">    x += 4;</div><div class="line">    y += 2;</div><div class="line"></div><div class="line">    if ( oldy &gt;= 200 ) &#123;</div><div class="line">        // clearInterval( intervalId );</div><div class="line">        x = 10, y = 10;</div><div class="line">    &#125;</div><div class="line">&#125;, 20);</div></pre></td></tr></table></figure>
<p><strong>简单效果</strong></p>
<p><img src="./imgs/2016-08-10_003757.gif" alt=""></p>
<p>有时为了简单常常将整个画布都清除, 这样就不用每次计算清除的问题.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ctx.clearRect( 0, 0, cas.width, cas.height );</div><div class="line">// 也可以设置画布宽度, 这样就会自动清除</div><div class="line">cas.width = cas.width;</div></pre></td></tr></table></figure>
<h3 id="绘制圆弧"><a href="#绘制圆弧" class="headerlink" title="绘制圆弧"></a>绘制圆弧</h3><p>绘制圆弧的方法有</p>
<ol>
<li><code>CanvasRenderingContext2D.arc()</code></li>
<li><code>CanvasRenderingContext2D.arcTo()</code></li>
</ol>
<h4 id="绘制圆弧-1"><a href="#绘制圆弧-1" class="headerlink" title="绘制圆弧"></a>绘制圆弧</h4><p>语法: <code>CanvasRenderingContext2D.arc( x, y, radius. startAngle. endAngle, anticlockwise )</code></p>
<p>描述:</p>
<ol>
<li>该方法用于绘制一段弧, 配合开始点的位置 与 <code>stroke</code> 方法或 <code>fill</code> 方法可以绘制扇形.</li>
<li>方法中的前两个参数 x, y 表示绘制圆弧的圆心坐标.</li>
<li>参数 radius 表示圆弧半径, 单位为弧度.</li>
<li>参数 startAngle 与 endAngle 表示开始到结束的角度. 角度以水平向右为 0 弧度, 顺时针为正方向.</li>
<li>参数 anticlockwise 表示是否采用默认的正向角度, 如果传入 true 表示逆指针为正. 该参数可选.</li>
</ol>
<p><strong>案例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 在 200, 200 的地方绘制一段半径为 100 的圆弧, 圆心角为 - PI / 2 到 PI / 4</div><div class="line">...</div><div class="line">ctx.arc( 200, 200, 100, -Math.PI/2, Math.PI/4 );</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">// 为了方便看清楚结构, 绘制坐标轴</div><div class="line">ctx.beginPath();</div><div class="line">ctx.strokeStyle = &apos;red&apos;;</div><div class="line">ctx.moveTo( 50, 200 );</div><div class="line">ctx.lineTo( 350, 200 );</div><div class="line"></div><div class="line">ctx.moveTo( 200, 50 );</div><div class="line">ctx.lineTo( 200, 350 );</div><div class="line"></div><div class="line">ctx.moveTo( 200, 200 );</div><div class="line">ctx.lineTo( 300, 300 );</div><div class="line"></div><div class="line">ctx.stroke();</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_011024.png" alt=""></p>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ol>
<li>使用 arc 绘图的时候, 如果没有设置 <code>moveTo</code> 那么会从开始的绘弧的地方作为起始点. 如果设置了 <code>moveTo</code>, 那么会连线该点与圆弧的起点.</li>
<li>如果使用 <code>stroke</code> 方法, 那么会从开始连线到圆弧的起始位置. 如果是 <code>fill</code> 方法, 会自动闭合路径填充.</li>
</ol>
<p><strong>例如</strong></p>
<p><img src="./imgs/2016-08-10_012936.png" alt=""></p>
<h4 id="绘制扇形"><a href="#绘制扇形" class="headerlink" title="绘制扇形"></a>绘制扇形</h4><p>绘制扇形的重点是需要设置起始位置为圆心点, 然后闭合路径即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">ctx.strokeStyle = &apos;red&apos;;</div><div class="line">ctx.fillStyle = &apos;pink&apos;;</div><div class="line"></div><div class="line">ctx.moveTo( 100, 200 );</div><div class="line">ctx.arc( 100, 200, 100, -Math.PI/3, Math.PI/3 );</div><div class="line">ctx.closePath();</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">ctx.beginPath();</div><div class="line">ctx.moveTo( 300, 200 );</div><div class="line">ctx.arc( 300, 200, 100, -Math.PI/3, Math.PI/3 );</div><div class="line">ctx.closePath();</div><div class="line">ctx.fill();</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_013523.png" alt=""></p>
<h4 id="绘制扇形动画"><a href="#绘制扇形动画" class="headerlink" title="绘制扇形动画"></a>绘制扇形动画</h4><p>绘制扇形动画, 就是每隔几毫秒( 20 毫秒)擦除以前绘制的内容, 然后在以前绘制的基础上比以前多绘制一点东西. 这里多绘制的内容就是由角度决定. 比如一开始角度从 <code>-Math.PI / 2</code> 开始绘制. 那么每次角度都 <code>+0.1</code>, 直到 绘制到 <code>Math.PI * 3 / 2</code> 为止.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">ctx.fillStyle = &apos;green&apos;;</div><div class="line">var startAngle = -Math.PI / 2,</div><div class="line">    angle = startAngle,</div><div class="line">    x = 200, y = 200,</div><div class="line">    r = 100;</div><div class="line">var intervalId = setInterval(function () &#123;</div><div class="line">    // 清除之前绘制的内容</div><div class="line">    ctx.clearRect( 0, 0, cas.width, cas.height );</div><div class="line">    // 角度增量</div><div class="line">    angle += 0.1;</div><div class="line">    // 判断是否停止计时器</div><div class="line">    if ( angle &gt;= Math.PI * 3 / 2 ) &#123;</div><div class="line">        clearInterval( intervalId);</div><div class="line">        angle = Math.PI * 3 / 2; </div><div class="line">        console.log( &apos;绘制完成&apos; );</div><div class="line">    &#125;</div><div class="line">    // 绘制</div><div class="line">    ctx.moveTo( x, y );</div><div class="line">    ctx.arc( x, y, r, startAngle, angle );</div><div class="line">    ctx.fill();</div><div class="line">&#125;, 20);</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/123.gif" alt=""></p>
<h4 id="绘制饼形图"><a href="#绘制饼形图" class="headerlink" title="绘制饼形图"></a>绘制饼形图</h4><p>绘制饼形图最大的特点是角度是叠加的. 开始从 <code>-Math.PI/2</code> 开始绘制, 达到执行角 <code>x</code> 后, 下一个区域从 <code>x</code> 开始绘制, 然后有到一个角 <code>y</code> 停下来. 如此反复到 <code>Math.PI * 3 / 2</code> 结束.</p>
<p>本节看两个案例, 一个固定等分, 一个由数据源来定义角度.</p>
<h5 id="三等分饼形图"><a href="#三等分饼形图" class="headerlink" title="三等分饼形图"></a>三等分饼形图</h5><p>绘制一个三等分的饼形图, 颜色使用 红, 绿, 蓝.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var x = 200, y = 200,</div><div class="line">    r = 100,</div><div class="line">    step = Math.PI * 2 / 3,     // 120 度一个区域</div><div class="line">    start = -Math.PI / 2,       // 起始角度</div><div class="line">    colors = [ &apos;red&apos;, &apos;green&apos;, &apos;blue&apos; ];</div><div class="line"></div><div class="line">for ( var i = 0; i &lt; 3; i++ ) &#123;</div><div class="line">    ctx.beginPath();</div><div class="line">    ctx.moveTo( x, y );</div><div class="line">    ctx.fillStyle = colors[ i ];</div><div class="line">    ctx.arc( x, y, r, start, start+=step );</div><div class="line">    ctx.fill();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_021710.png" alt=""></p>
<h5 id="根据数据定义角度"><a href="#根据数据定义角度" class="headerlink" title="根据数据定义角度"></a>根据数据定义角度</h5><p>根据数据源定义角度, 就是将所有的数据求和, 按照总和为 <code>2 * Math.PI</code> 的结论计算出每一个数据部分的弧度值. 同时颜色可以提前定义好.</p>
<p>从 Konva 库中分离出来的颜色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var colors = </div><div class="line">    ( &quot;aliceblue,antiquewhite,aqua,aquamarine,azure,beige,bisque,black,blanchedalmond,blue,&quot; +</div><div class="line">    &quot;blueviolet,brown,burlywood,cadetblue,chartreuse,chocolate,coral,cornflowerblue,cornsilk,&quot; +</div><div class="line">    &quot;crimson,cyan,darkblue,darkcyan,darkgoldenrod,darkgray,darkgreen,darkgrey,darkkhaki,darkmagenta,&quot; +</div><div class="line">    &quot;darkolivegreen,darkorange,darkorchid,darkred,darksalmon,darkseagreen,darkslateblue,darkslategray,&quot; +</div><div class="line">    &quot;darkslategrey,darkturquoise,darkviolet,deeppink,deepskyblue,dimgray,dimgrey,dodgerblue,firebrick,&quot; +</div><div class="line">    &quot;floralwhite,forestgreen,fuchsia,gainsboro,ghostwhite,gold,goldenrod,gray,green,greenyellow,grey,&quot; +</div><div class="line">    &quot;honeydew,hotpink,indianred,indigo,ivory,khaki,lavender,lavenderblush,lawngreen,lemonchiffon,&quot; + </div><div class="line">    &quot;lightblue,lightcoral,lightcyan,lightgoldenrodyellow,lightgray,lightgreen,lightgrey,lightpink,&quot; +</div><div class="line">    &quot;lightsalmon,lightseagreen,lightskyblue,lightslategray,lightslategrey,lightsteelblue,lightyellow,&quot; +</div><div class="line">    &quot;lime,limegreen,linen,magenta,maroon,mediumaquamarine,mediumblue,mediumorchid,mediumpurple,&quot; +</div><div class="line">    &quot;mediumseagreen,mediumslateblue,mediumspringgreen,mediumturquoise,mediumvioletred,midnightblue,&quot; +</div><div class="line">    &quot;mintcream,mistyrose,moccasin,navajowhite,navy,oldlace,olive,olivedrab,orange,orangered,orchid,&quot; +</div><div class="line">    &quot;palegoldenrod,palegreen,paleturquoise,palevioletred,papayawhip,peachpuff,peru,pink,plum,powderblue,&quot; +</div><div class="line">    &quot;purple,rebeccapurple,red,rosybrown,royalblue,saddlebrown,salmon,sandybrown,seagreen,seashell,sienna,&quot; +</div><div class="line">    &quot;silver,skyblue,slateblue,slategray,slategrey,snow,springgreen,steelblue,tan,teal,thistle,transparent,&quot; +</div><div class="line">    &quot;tomato,turquoise,violet,wheat,white,whitesmoke,yellow,yellowgreen&quot; ).split( &apos;,&apos; );</div></pre></td></tr></table></figure>
<p>如果得到数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var data = [ 123, 156, 47, 100, 80 ];</div></pre></td></tr></table></figure>
<p>那么计算各个部分的比例时, 可以构造一个存储分量值与弧度的对象数组.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var sum = 0;</div><div class="line">for ( var i = 0; i &lt; data.length; i++ ) &#123;</div><div class="line">    sum += data[ i ];</div><div class="line">&#125;</div><div class="line">// 得到总数后, 分量比就有了</div><div class="line">var odata = data.map(function ( v, i ) &#123;</div><div class="line">    return &#123; value: v, radius: v * 2 * Math.PI / sum &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>最后根据数据开始绘图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 开始绘图</div><div class="line">var start = -Math.PI / 2,</div><div class="line">    x = 200, y = 200,</div><div class="line">    r = 100;</div><div class="line"></div><div class="line">for ( var i = 0; i &lt; odata.length; i++ ) &#123;</div><div class="line">    ctx.beginPath();</div><div class="line">    ctx.fillStyle = colors[ i + 10 ];</div><div class="line">    ctx.moveTo( x, y );</div><div class="line">    ctx.arc( x, y, r, start, start+=odata[ i ][ &apos;radius&apos; ] );</div><div class="line">    ctx.fill();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_024116.png" alt=""></p>
<h4 id="绘制相切弧"><a href="#绘制相切弧" class="headerlink" title="绘制相切弧"></a>绘制相切弧</h4><p>语法: <code>CanvasRenderingContext2D.arcTo( x1, y1, x2, y2, radius )</code></p>
<p>描述:</p>
<ol>
<li>该方法用于绘制圆弧</li>
<li>绘制的规则是当前位置与第一个参考点连线, 绘制的弧与该直线相切.</li>
<li>同时连接两个参考点, 圆弧根据半径与该连线相切</li>
</ol>
<p>例如有一个起始点 <code>( 100, 100 )</code>, 那么绘制其点. 颜色设置为红色.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ctx.fillStyle = &apos;red&apos;;</div><div class="line">ctx.fillRect( 100 - 4, 100 - 4, 8, 8 );</div></pre></td></tr></table></figure>
<p>然后两个参考点分别为 <code>( 100, 300 )</code> 和 <code>( 300, 300 )</code>, 绘制出该点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ctx.fillRect( 100 - 4, 300 - 4, 8, 8 );</div><div class="line">ctx.fillRect( 300 - 4, 300 - 4, 8, 8 );</div></pre></td></tr></table></figure>
<p>连接两个参考点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ctx.beginPath();</div><div class="line">ctx.strokeStyle = &apos;red&apos;;</div><div class="line">ctx.moveTo( 100, 300 );</div><div class="line">ctx.lineTo( 300, 300 );</div><div class="line">ctx.stroke();</div></pre></td></tr></table></figure>
<p>得到效果为</p>
<p><img src="./imgs/2016-08-10_030033.png" alt=""></p>
<p>调用 <code>arcTo</code> 方法绘制圆弧. 记得将起始点设置为 <code>( 100, 100 )</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ctx.beginPath();</div><div class="line">ctx.strokeStyle = &apos;blue&apos;;</div><div class="line">ctx.moveTo( 100, 100 );</div><div class="line"></div><div class="line">ctx.arcTo( 100, 300, 300, 300, 100 );</div><div class="line">ctx.stroke();</div></pre></td></tr></table></figure>
<p>得到效果</p>
<p><img src="./imgs/2016-08-10_030327.png" alt=""></p>
<p>注意: 使用该方法可以使用圆弧连接两条直线, 而不用计算复杂的起始角度与结束角度. 因此用于绘制圆角矩形等案例较多.</p>
<h4 id="绘制圆角矩形"><a href="#绘制圆角矩形" class="headerlink" title="绘制圆角矩形"></a>绘制圆角矩形</h4><p>封装一个函数, 用于绘制圆角矩形.</p>
<ol>
<li>参考 <code>rect</code> 方法, 需要坐标参数 x, y.</li>
<li>由于设置圆角, 因此需要设置圆角半径 cornerRadius.</li>
<li>还需要提供宽高.</li>
</ol>
<p>首先绘制一个矩形边框. 但是需要考虑圆角, 虽然从 x, y 开始绘制, 但是中间要空出 半径的距离.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var x = 100, y = 100, width = 300, height = 100,</div><div class="line">    cornerRadius = 10;</div><div class="line">ctx.strokeStyle = &apos;red&apos;;</div><div class="line"></div><div class="line">ctx.moveTo( x + cornerRadius, y );</div><div class="line">ctx.lineTo( x + width - cornerRadius, y );</div><div class="line"></div><div class="line">ctx.moveTo( x + width, y + cornerRadius );</div><div class="line">ctx.lineTo( x + width, y + height - cornerRadius );</div><div class="line"></div><div class="line">ctx.moveTo( x + width - cornerRadius, y + height );</div><div class="line">ctx.lineTo( x + cornerRadius, y + height );</div><div class="line"></div><div class="line">ctx.moveTo( x, y + height - cornerRadius );</div><div class="line">ctx.lineTo( x, y + cornerRadius );</div><div class="line"></div><div class="line">ctx.stroke();</div></pre></td></tr></table></figure>
<p>效果为</p>
<p><img src="./imgs/2016-08-10_031610.png" alt=""></p>
<p>然后再分别绘制四个角, 设置当前位置与参考点的位置. 设置当前位置为一个线端点, 然后参考点依次就是 矩形顶点 和 另一个线段的端点.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ctx.moveTo( x + cornerRadius, y );</div><div class="line">ctx.arcTo( x, y, x, y + cornerRadius, cornerRadius );</div></pre></td></tr></table></figure>
<p>即可得到</p>
<p><img src="./imgs/2016-08-10_032430.png" alt=""></p>
<p>同理绘制另外三个圆角</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ctx.moveTo( x + width - cornerRadius, y );</div><div class="line">ctx.arcTo( x + width, y, x + width, y + cornerRadius, cornerRadius );</div><div class="line"></div><div class="line">ctx.moveTo( x + width, y + height - cornerRadius );</div><div class="line">ctx.arcTo( x + width, y + height, x + width - cornerRadius, y + height, cornerRadius );</div><div class="line"></div><div class="line">ctx.moveTo( x + cornerRadius, y + height );</div><div class="line">ctx.arcTo( x, y + height, x, y + height - cornerRadius, cornerRadius );</div></pre></td></tr></table></figure>
<p>即可得到</p>
<p><img src="./imgs/2016-08-10_032852.png" alt=""></p>
<p>封装成方法就可以绘制更多圆角矩形了. 封装中注意 <code>beginPath()</code> 和 <code>save()</code> 和 <code>restore()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">function cRect ( x, y, width, height, cornerRadius, color ) &#123;</div><div class="line">    ctx.save();</div><div class="line">    ctx.beginPath();</div><div class="line">    ctx.strokeStyle = color || &apos;red&apos;;</div><div class="line"></div><div class="line">    ctx.moveTo( x + cornerRadius, y );</div><div class="line">    ctx.lineTo( x + width - cornerRadius, y );</div><div class="line"></div><div class="line">    ctx.moveTo( x + width, y + cornerRadius );</div><div class="line">    ctx.lineTo( x + width, y + height - cornerRadius );</div><div class="line"></div><div class="line">    ctx.moveTo( x + width - cornerRadius, y + height );</div><div class="line">    ctx.lineTo( x + cornerRadius, y + height );</div><div class="line"></div><div class="line">    ctx.moveTo( x, y + height - cornerRadius );</div><div class="line">    ctx.lineTo( x, y + cornerRadius );</div><div class="line"></div><div class="line">    // 开始绘制四个圆角</div><div class="line">    ctx.moveTo( x + cornerRadius, y );</div><div class="line">    ctx.arcTo( x, y, x, y + cornerRadius, cornerRadius );</div><div class="line"></div><div class="line">    ctx.moveTo( x + width - cornerRadius, y );</div><div class="line">    ctx.arcTo( x + width, y, x + width, y + cornerRadius, cornerRadius );</div><div class="line"></div><div class="line">    ctx.moveTo( x + width, y + height - cornerRadius );</div><div class="line">    ctx.arcTo( x + width, y + height, x + width - cornerRadius, y + height, cornerRadius );</div><div class="line"></div><div class="line">    ctx.moveTo( x + cornerRadius, y + height );</div><div class="line">    ctx.arcTo( x, y + height, x, y + height - cornerRadius, cornerRadius );</div><div class="line"></div><div class="line">    ctx.stroke();</div><div class="line">    ctx.restore();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cRect( 50, 50, 100, 50, 5 );</div><div class="line">cRect( 100, 120, 100, 80, 8, &apos;blue&apos; );</div><div class="line">cRect( 300, 100, 200, 100, 10, &apos;green&apos; );</div></pre></td></tr></table></figure>
<p>得到结果为</p>
<p><img src="./imgs/2016-08-10_033552.png" alt=""></p>
<h2 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h2><p>绘制文本的方法</p>
<ol>
<li><code>CanvasRenderingContext2D.fillText()</code></li>
<li><code>CanvasRenderingContext2D.strokeText()</code></li>
<li><code>CanvasRenderingContext2D.measureText()</code></li>
</ol>
<p>文本样式</p>
<ol>
<li><code>CanvasRenderingContext2D.font</code></li>
<li><code>CanvasRenderingContext2D.textAlign</code></li>
<li><code>CanvasRenderingContext2D.textBaseline</code></li>
</ol>
<h3 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h3><p>语法:</p>
<ol>
<li><code>CanvasRenderingContext2D.strokeText( text, x, y[, maxWidth] )</code></li>
<li><code>CanvasRenderingContext2D.fillText( text, x, y[, maxWidth] )</code></li>
</ol>
<p>描述:</p>
<ol>
<li>这两个方法的功能都是在给定的 x, y 坐标下绘制文本内容.</li>
<li>stroke 绘制描边文字, 文字内空心. fill 绘制填充文字, 即实心文字.</li>
<li>最后一个参数可选, 用于限制文字的总宽. 特殊条件下, 系统会自动调整文字宽度与大小以适应该参数限制.</li>
</ol>
<p><strong>案例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">ctx.strokeRect( 100, 100, 200, 50 );</div><div class="line">ctx.strokeText( &apos;Hello PM&apos;, 100, 100 );</div><div class="line"></div><div class="line">ctx.strokeRect( 100, 200, 200, 50 );</div><div class="line">ctx.fillText( &apos;Hello PM&apos;, 100, 200 );</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_091333.png" alt=""></p>
<p>注意: 第一个文字由于中间空心, 所以文字相当于双线显示. 就显得较粗.</p>
<p>根据绘制的矩形块可以发现文字几乎使用该点作为文字基线参考.</p>
<h3 id="计算文本尺寸"><a href="#计算文本尺寸" class="headerlink" title="计算文本尺寸"></a>计算文本尺寸</h3><p>语法: <code>CanvasRenderingContext2D.measureText()</code></p>
<p>描述:</p>
<ol>
<li>该方法返回一个文本尺寸对象, TextMetrics 对象.</li>
<li>TextMetrics 对象属性很多, 常用的 width 属性可以获取文字的宽度.</li>
</ol>
<h3 id="设置文字属性"><a href="#设置文字属性" class="headerlink" title="设置文字属性"></a>设置文字属性</h3><h4 id="设置文字字体"><a href="#设置文字字体" class="headerlink" title="设置文字字体"></a>设置文字字体</h4><p>语法: <code>CanvasRenderingContext2D.font = value</code></p>
<p>描述:</p>
<ol>
<li>该属性用于设置绘制字体的各种信息, 与 CSS 语法一致, 设置字体形状, 样式, 字号粗细等.</li>
<li>其顺序可以是: style | variant | weight | size/line-height | family.</li>
<li>默认值为 10px sans-serif</li>
</ol>
<p>修改字号后查看 strokeText 与 fillText 的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">ctx.font = &apos;50px 黑体&apos;;</div><div class="line">ctx.strokeRect( 100, 100, 200, 50 );</div><div class="line">ctx.strokeText( &apos;Hello PM&apos;, 100, 100 );</div><div class="line"></div><div class="line">ctx.strokeRect( 100, 200, 200, 50 );</div><div class="line">ctx.fillText( &apos;Hello PM&apos;, 100, 200 );</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_105346.png" alt=""></p>
<h4 id="设置字体水平对齐方式"><a href="#设置字体水平对齐方式" class="headerlink" title="设置字体水平对齐方式"></a>设置字体水平对齐方式</h4><p>语法: <code>CanvasRenderingContext2D.textAlign = value</code></p>
<p>描述:</p>
<ol>
<li>该属性用于设置文字的水平对齐方式. 设置文字居中, 靠左右对齐等.</li>
<li>该属性可以设置的值有: start( 默认 ), end, left, right, center.</li>
</ol>
<p>start 表示根据参考基准点的垂直直线左靠对齐</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">ctx.moveTo( 150, 100 );</div><div class="line">ctx.lineTo( 150, 200 );</div><div class="line">ctx.moveTo( 100, 150 );</div><div class="line">ctx.lineTo( 200, 150 );</div><div class="line">ctx.strokeStyle = &apos;red&apos;;</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">ctx.font = &apos;30px 黑体&apos;;</div><div class="line">ctx.textAlign = &apos;start&apos;; // 默认</div><div class="line">ctx.fillText( &apos;测试文字&apos;, 150, 150 );</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_104221.png" alt=""></p>
<p>end 表示根据参考基准点的垂直直线右靠对齐</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">ctx.font = &apos;30px 黑体&apos;;</div><div class="line">ctx.textAlign = &apos;end&apos;;</div><div class="line">ctx.fillText( &apos;测试文字&apos;, 150, 150 );</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_104403.png" alt=""></p>
<p>left 与 right 就是左对齐与右对齐的意思</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">ctx.font = &apos;30px 黑体&apos;;</div><div class="line">ctx.textAlign = &apos;left&apos;;</div><div class="line">ctx.fillText( &apos;left&apos;, 150, 150 );</div><div class="line">ctx.textAlign = &apos;right&apos;</div><div class="line">ctx.fillText( &apos;right&apos;, 150, 150 );</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_104802.png" alt=""></p>
<p>最后 center 就是居中的含义.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ctx.font = &apos;50px 黑体&apos;</div><div class="line">ctx.textAlign = &apos;center&apos;;</div><div class="line">ctx.fillText( &apos;00000&apos;, 150, 150 );</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_105718.png" alt=""></p>
<h4 id="设置字体垂直对齐方式"><a href="#设置字体垂直对齐方式" class="headerlink" title="设置字体垂直对齐方式"></a>设置字体垂直对齐方式</h4><p>语法: <code>CanvasRenderingContext2D.textBaseline = value</code></p>
<p>描述:</p>
<ol>
<li>该方法设置文字在垂直方向上的对齐方式.</li>
<li>该属性可以取值: top, middle, bottom, hanging, alphabetic, ideographic</li>
<li>基于参考点的直线, 其中 top, middle, buttom 分别表示靠上, 居中, 靠下对齐.</li>
<li>alphabetic 表示字母基线, 类似于英文字母的对齐方式. 例如 a, g, f 等字母.</li>
<li>ideographic 表意对齐. 使用字母对齐中超出的字母为参考. 即比字母基线略靠下.</li>
<li>所有的对齐方式是根据文字特点相关的. 对于中文主要使用的还是 top, bottom 和 middle.</li>
</ol>
<p>top, middle, bottom 使用的较多</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">// ------------------</div><div class="line">ctx.moveTo( 100, 80 );</div><div class="line">ctx.lineTo( 500, 80 );</div><div class="line">ctx.strokeStyle = &apos;red&apos;;</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">ctx.font = &apos;30px 黑体&apos;;</div><div class="line"></div><div class="line">ctx.textBaseline = &apos;top&apos;;</div><div class="line">ctx.fillText( &apos;abfghijklpqrty&apos;, 150, 80 );</div><div class="line"></div><div class="line">// ------------------</div><div class="line">ctx.translate( 0, 100 );</div><div class="line">ctx.moveTo( 100, 80 );</div><div class="line">ctx.lineTo( 500, 80 );</div><div class="line">ctx.strokeStyle = &apos;red&apos;;</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">ctx.font = &apos;30px 黑体&apos;;</div><div class="line"></div><div class="line">ctx.textBaseline = &apos;bottom&apos;;</div><div class="line">ctx.fillText( &apos;abfghijklpqrty&apos;, 150, 80 );</div><div class="line"></div><div class="line">// ------------------</div><div class="line">ctx.translate( 0, 100 );</div><div class="line">ctx.moveTo( 100, 80 );</div><div class="line">ctx.lineTo( 500, 80 );</div><div class="line">ctx.strokeStyle = &apos;red&apos;;</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">ctx.font = &apos;30px 黑体&apos;;</div><div class="line"></div><div class="line">ctx.textBaseline = &apos;middle&apos;;</div><div class="line">ctx.fillText( &apos;abfghijklpqrty&apos;, 150, 80 );</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_111756.png" alt=""></p>
<p>alphabetic 表示字母参考线, ideographic 会比它低一点, hanging 表示悬挂.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">ctx.moveTo( 100, 80 );</div><div class="line">ctx.lineTo( 500, 80 );</div><div class="line">ctx.strokeStyle = &apos;red&apos;;</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">ctx.font = &apos;30px 黑体&apos;;</div><div class="line"></div><div class="line">ctx.textBaseline = &apos;alphabetic&apos;;</div><div class="line">ctx.fillText( &apos;abfghijklpqrty&apos;, 150, 80 ); </div><div class="line"></div><div class="line">// -------------------------------------------------</div><div class="line"></div><div class="line">ctx.translate( 0, 100 );</div><div class="line">ctx.moveTo( 100, 80 );</div><div class="line">ctx.lineTo( 500, 80 );</div><div class="line">ctx.strokeStyle = &apos;red&apos;;</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">ctx.font = &apos;30px 黑体&apos;;</div><div class="line"></div><div class="line">ctx.textBaseline = &apos;ideographic&apos;;</div><div class="line">ctx.fillText( &apos;abfghijklpqrty&apos;, 150, 80 ); </div><div class="line"></div><div class="line">// -------------------------------------------------</div><div class="line"></div><div class="line">ctx.translate( 0, 100 );</div><div class="line">ctx.moveTo( 100, 80 );</div><div class="line">ctx.lineTo( 500, 80 );</div><div class="line">ctx.strokeStyle = &apos;red&apos;;</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">ctx.font = &apos;30px 黑体&apos;;</div><div class="line"></div><div class="line">ctx.textBaseline = &apos;hanging&apos;;</div><div class="line">ctx.fillText( &apos;abfghijklpqrty&apos;, 150, 80 );</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_113004.png" alt=""></p>
<p>实际上大多数参考方式只有在特定语言中有作用, 而且与字体也有相对复杂的关系. 例如( 下图是有部分错误的 ):</p>
<p><img src="./imgs/textBaseline.gif" alt=""></p>
<h2 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h2><p>绘制图像虽然只有一个 <code>drawImage</code> 函数, 但是该函数有多重参数形式.</p>
<ol>
<li><code>CanvasRenderingContext2D.drawImage( img, dx, dy )</code>.</li>
<li><code>CanvasRenderingContext2D.drawImage( img, dx, dy, dWidth, dHeight )</code>.</li>
<li><code>CanvasRenderingContext2D.drawImage( img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight )</code>.</li>
</ol>
<h3 id="绘制简单图像"><a href="#绘制简单图像" class="headerlink" title="绘制简单图像"></a>绘制简单图像</h3><p>语法: <code>CanvasRenderingContext2D.drawImage( img, dx, dy )</code></p>
<p>描述:</p>
<ol>
<li>使用三个参数, 允许在画布上的 任意位置 绘制图片.</li>
<li>参数 img 是指图片对象. 可以是 img 标签, 或者是 video 标签, 已经另一个 canvas 等.</li>
<li>需要注意的是如果直接添加 img 对象是不可以的, 需要等待其加载.</li>
</ol>
<p>准备一张网络图片, 绘制, 便于查看其加载过程.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 随便从百度中搜索 &apos;美女头像&apos;, 记录一个链接地址</div><div class="line">var url = &apos;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3289155966,3850025949&amp;fm=116&amp;gp=0.jpg&apos;;</div><div class="line">// 创建 img 对象</div><div class="line">var img = new Image(); // 就是 img 标签</div><div class="line">// 设置 src 属性为 图片</div><div class="line">img.src = url;</div><div class="line"></div><div class="line">// 绘图</div><div class="line">ctx.drawImage( img, 100, 100 );</div></pre></td></tr></table></figure>
<p>此时没有任何结果, 打开调试工具查看 Net Work</p>
<p><img src="./imgs/2016-08-10_215925.png" alt=""></p>
<p>因为加载图片需要时间, 因此将绘制的方法放在 onload 事件中.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 随便从百度中搜索 &apos;美女头像&apos;, 记录一个链接地址</div><div class="line">var url = &apos;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3289155966,3850025949&amp;fm=116&amp;gp=0.jpg&apos;;</div><div class="line">// 创建 img 对象</div><div class="line">var img = new Image(); // 就是 img 标签</div><div class="line">// 设置 src 属性为 图片</div><div class="line">img.src = url;</div><div class="line"></div><div class="line">// 绘图</div><div class="line">img.onload = function () &#123;</div><div class="line">    ctx.drawImage( img, 100, 100 );</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>修改后就可得到效果</p>
<p><img src="./imgs/2016-08-10_220644.png" alt=""></p>
<p>注意: 这里使用 <code>new Image()</code> 与 <code>document.createElement( &#39;img&#39; )</code> 是一样的.</p>
<h3 id="在指定区域内绘制图像"><a href="#在指定区域内绘制图像" class="headerlink" title="在指定区域内绘制图像"></a>在指定区域内绘制图像</h3><p>当图片比较大的时候, 如果使用这样的方式绘图, 那么图片可能会完全覆盖画布. 例如:</p>
<p><img src="./imgs/2016-08-10_222122.png" alt=""></p>
<p>因此, 需要将其控制在一个矩形区域内绘制.</p>
<p>语法: <code>CanvasRenderingContext2D.drawImage( img, dx, dy, dWidth, dHeight )</code></p>
<p>描述:</p>
<ol>
<li>参数 dWidth, dHeight 表示绘制的矩形区域. 绘制的 dx, dy 坐标决定了开始.</li>
<li>该方法绘制的图像会在指定范围内被压缩显示.</li>
</ol>
<p>将上面的图绘制在 <code>100 * 100</code> 的范围内.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">ctx.drawImage( img, 100, 100, 100, 100 );</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_222838.png" alt=""></p>
<p>如果希望正常显示, 需要固定一个宽度或者高度, 然后根据比例计算出另一个值. 这里假定高度是 100. 计算宽度后绘图.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">var heigth = 100, width;</div><div class="line">img.onload = function () &#123;</div><div class="line">    width = img.width * height / img.height;</div><div class="line">    ctx.drawImage( img, 100, 100, width, height );</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_223421.png" alt=""></p>
<h3 id="绘制任意图像"><a href="#绘制任意图像" class="headerlink" title="绘制任意图像"></a>绘制任意图像</h3><p>类似于 CSS 中处理按钮等小图标的技巧, 将很多的效果图集中在一张 png 格式的背景透明的图片中, 这样可以提高效率也便于维护. 那么 drawImage 同样支持该方式绘图. 在画布中的指定位子与指定区域内, 绘制图片中的某个矩形区.</p>
<p>语法: <code>CanvasRenderingContext2D.drawImage( img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight )</code></p>
<p>描述: 这里的带有 s 前缀的参数就是指图源的矩形区域.</p>
<p>例如将图片的 <code>( 100, 100, 300, 200 )</code> 处的内容绘制到页面的 <code>( 100, 100, 300, 200 )</code> 的位置.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&apos;&apos;&apos;</div><div class="line">ctx.drawImage( img, 100, 100, 300, 200,  100, 100, 300, 200 );</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_224454.png" alt=""></p>
<h2 id="绘制动画"><a href="#绘制动画" class="headerlink" title="绘制动画"></a>绘制动画</h2><p>有了图片部分绘制的功能, 我们就可以尝试绘制动画了. 准备一张图片</p>
<p><img src="./imgs/士兵1.gif" alt=""></p>
<p>然后开始的时候绘制第一行的第一张图. 计算它的坐标与宽高</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var img = new Image();</div><div class="line">img.src = &apos;./imgs士兵(1).png&apos;</div><div class="line">img.onload = function () &#123;</div><div class="line">    var width = img.width / 4;</div><div class="line">    var height = img.heigth / 4;</div><div class="line">    // 第一张图的顶点是 0, 0, 宽高是 width, height</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>那么第一行的第二张图就是 <code>( 0, width, width, height )</code>, 第三张就是 <code>( 0, width * 2, width, height )</code>. 因此第一行的第 <code>i</code> 张图就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var x = 0;</div><div class="line">var y = width * ( i - 1 );</div></pre></td></tr></table></figure>
<p>同理得到, 第 <code>j</code> 列的 <code>x</code> 坐标是 <code>height * ( j - 1 )</code></p>
<p>现在绘制第一张图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">var img = new Image();</div><div class="line">img.src = &apos;./imgs/士兵(1).png&apos;</div><div class="line">img.onload = function () &#123;</div><div class="line">    var width = img.width / 4;</div><div class="line">    var height = img.height / 4;</div><div class="line"></div><div class="line">    ctx.drawImage( img, 0, 0, width, height, 100, 100, width, height ); </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_231312.png" alt="">;</p>
<p>现在要求, 每隔 200 毫秒就切换一张图片, 现在只考虑第一行的图片.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">var img = new Image();</div><div class="line">img.src = &apos;./imgs/士兵(1).png&apos;</div><div class="line">img.onload = function () &#123;</div><div class="line">    var width = img.width / 4;</div><div class="line">    var height = img.height / 4;</div><div class="line"></div><div class="line">    var i = 0;</div><div class="line">    setInterval(function () &#123;</div><div class="line">        ctx.clearRect( 0, 0, cas.width, cas.height );</div><div class="line">        ctx.drawImage( img, width * (i++ % 4), 0, width, height, 100, 100, width, height );</div><div class="line">    &#125;, 200 );</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/士兵1.gif" alt=""></p>
<p>那么扩展一下, 把四行都画出来</p>
<p><img src="./imgs/士兵2.gif" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;绘制形状&quot;&gt;&lt;a href=&quot;#绘制形状&quot; class=&quot;headerlink&quot; title=&quot;绘制形状&quot;&gt;&lt;/a&gt;绘制形状&lt;/h2&gt;&lt;p&gt;绘制图形不仅仅是利用线条来实现绘图, 还可以有快捷的绘制图形的办法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;绘制矩形&lt;/li&gt;
&lt;li&gt;绘制圆弧&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;绘制矩形&quot;&gt;&lt;a href=&quot;#绘制矩形&quot; class=&quot;headerlink&quot; title=&quot;绘制矩形&quot;&gt;&lt;/a&gt;绘制矩形&lt;/h3&gt;&lt;p&gt;绘制矩形的方法&lt;/p&gt;
    
    </summary>
    
      <category term="canvas三部曲" scheme="http://yoursite.com/categories/canvas%E4%B8%89%E9%83%A8%E6%9B%B2/"/>
    
    
      <category term="canvas" scheme="http://yoursite.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>canvas三部曲(前奏)</title>
    <link href="http://yoursite.com/2016/04/30/canvas%E4%B8%89%E9%83%A8%E6%9B%B2(%E5%89%8D%E5%A5%8F)/"/>
    <id>http://yoursite.com/2016/04/30/canvas三部曲(前奏)/</id>
    <published>2016-04-30T11:30:35.000Z</published>
    <updated>2017-02-23T12:17:32.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Canvas"><a href="#什么是-Canvas" class="headerlink" title="什么是 Canvas"></a>什么是 Canvas</h2><p>canvas 是 HTML5 提供的一个用于展示绘图效果的标签. canvas 原意画布, 帆布. 在 HTML 页面中用于展示绘图效果. 最早 canvas 是苹果提出的一个方案, 今天已经在大多数浏览器中实现.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">canvas 英 [&apos;kænvəs]  美 [&apos;kænvəs]   帆布 画布</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="canvas-的基本用法"><a href="#canvas-的基本用法" class="headerlink" title="canvas 的基本用法"></a>canvas 的基本用法</h3><p><strong>基本语法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;canvas&gt;&lt;/canvas&gt;</div></pre></td></tr></table></figure>
<ol>
<li>使用 canvas 标签, 即可在页面中开辟一格区域. 可以设置其 width 和 height 设置该区域的尺寸.</li>
<li>默认 canvas 的宽高为 300 和 150.</li>
<li>不要使用 CSS 的方式设置宽高, 应该使用 HTML 属性.</li>
<li>如果浏览器不支持 canvas 标签, 那么就会将其解释为 div 标签. 因此常常在 canvas 中嵌入文本, 以提示用户浏览器的能力.</li>
<li>canvas 的兼容性非常强, 只要支持该标签的, 基本功能都一样, 因此不用考虑兼容性问题.</li>
<li>canvas 本身不能绘图. 是使用 JavaScript 来完成绘图. canvas 对象提供了各种绘图用的 api.</li>
</ol>
<p><strong>canvas 的使用领域</strong></p>
<p>canvas 的使用领域很多:</p>
<ol>
<li>游戏</li>
<li>可视化数据(重点)</li>
<li>banner 广告</li>
<li>多媒体</li>
<li>未来<ul>
<li>模拟仿真</li>
<li>远程操作</li>
<li>图形编辑</li>
</ul>
</li>
</ol>
<h3 id="我们的课程目标"><a href="#我们的课程目标" class="headerlink" title="我们的课程目标"></a>我们的课程目标</h3><ol>
<li>不是为了做游戏</li>
<li>学会使用基本的 canvas api, 使用 canvas 可以完成简单的绘图</li>
<li>实现数据的可视化</li>
</ol>
<h2 id="基本绘图"><a href="#基本绘图" class="headerlink" title="基本绘图"></a>基本绘图</h2><h3 id="基本绘图方法"><a href="#基本绘图方法" class="headerlink" title="基本绘图方法"></a>基本绘图方法</h3><p><strong>绘图步骤</strong></p>
<ol>
<li>获得 <code>canvas</code> 对象.</li>
<li>调用 <code>getContext</code> 方法, 提供字符串参数 <code>&#39;2d&#39;</code>.</li>
<li>该方法返回 <code>CanvasRenderingContext2D</code> 类型的对象. 该对象提供基本的绘图命令.</li>
<li>使用 <code>CanvasRenderingContext2D</code> 对象提供的方法进行绘图.</li>
<li>基本绘图命令<ul>
<li>设置开始绘图的位置: <code>context.moveTo( x, y )</code>.</li>
<li>设置直线到的位置: <code>context.lineTo( x, y )</code>.</li>
<li>描边绘制: <code>context.stroke()</code>.</li>
<li>填充绘制: <code>context.fill()</code>.</li>
<li>闭合路径: <code>context.closePath()</code>.</li>
</ul>
</li>
</ol>
<p><strong>01-绘制基本线</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var canvas = document.createElement( &apos;canvas&apos; );</div><div class="line">canvas.width = 500;</div><div class="line">canvas.height = 400;</div><div class="line">canvas.style.border = &apos;1px dashed red&apos;;</div><div class="line">document.body.appendChild( canvas );</div><div class="line">// 获得 CanvasRenderingContext2D 对象</div><div class="line">var context = canvas.getContext( &apos;2d&apos; );</div><div class="line">// 设置 起点</div><div class="line">context.moveTo( 0, 0 );</div><div class="line">// 绘制直线</div><div class="line">context.lineTo( 500, 400 );</div><div class="line">// 设置 起点</div><div class="line">context.moveTo( 0, 400 );</div><div class="line">// 绘制直线</div><div class="line">context.lineTo( 500, 0 );</div><div class="line">// 描边显示效果</div><div class="line">context.stroke();</div></pre></td></tr></table></figure>
<p>运行结果为</p>
<p><img src="./imgs/2016-08-06_015256.png" alt=""></p>
<h4 id="计算机直角坐标系"><a href="#计算机直角坐标系" class="headerlink" title="计算机直角坐标系"></a>计算机直角坐标系</h4><p><img src="./imgs/2016-08-06_025322.png" alt=""></p>
<h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><ol>
<li>需要绘图就需要有 <code>canvas</code> 标签, 该标签用于展示图像.</li>
<li><code>canvas</code> 的宽高不要使用 CSS 来设置, 会有拉伸的问题. 应该直接使用属性设置.</li>
<li>但是 <code>canvas</code> 只是展示图像的标签, 它没有绘图的能力. 需要使用 <code>canvas</code> 的上下文工具来实现绘图.</li>
<li>使用 <code>canvas.getContext( &#39;2d&#39; )</code> 可以获得绘图工具, 该工具是 <code>CanvasRenderingContext2D</code> 类型的对象.</li>
<li>需要绘图, 首选设置绘图的起点.<ul>
<li>使用 <code>canvas</code> 绘图, 需要主要的是他主张先描点, 再连线绘制效果.</li>
<li>因此需要首先设置起点, 然后在起点的基础上描述其他需要的点.</li>
<li>使用 <code>CanvasRenderingContext2D.moveTo( x, y )</code> 方法设置起点.<ul>
<li>其中 x, y 表示的是在坐标系中的位置.</li>
</ul>
</li>
</ul>
</li>
<li>使用 <code>CanvasRenderingContext2D.lineTo( x, y )</code> 来描述绘制直线的下一个点. 依次类推可以描述多个点.</li>
<li>描点结束后, 需要使用 <code>CanvasRenderingContext2D.stroke()</code> 方法来连线. 开可以显示出效果.</li>
</ol>
<h4 id="getContext-方法"><a href="#getContext-方法" class="headerlink" title="getContext 方法"></a>getContext 方法</h4><p>语法: <code>Canvas.getContext( typeStr )</code></p>
<p>描述:</p>
<ol>
<li>该方法用于绘制上下文工具.</li>
<li>如果是绘制平面图形使用 <code>&#39;2d&#39;</code> 作为参数, 如果绘制立体图形使用 <code>&#39;webgl&#39;</code>.</li>
<li>使用 <code>&#39;2d&#39;</code> 返回 <code>CanvasRenderingContext2D</code> 类型的对象.</li>
<li>使用 <code>&#39;webgl&#39;</code> 返回 <code>WebGLRenderingContext</code> 类型的对象.</li>
</ol>
<h4 id="moveTo-方法"><a href="#moveTo-方法" class="headerlink" title="moveTo 方法"></a>moveTo 方法</h4><p>语法: <code>CanvasRenderingContext2D.moveTo( x, y )</code></p>
<p>描述:</p>
<ol>
<li>该方法用于设置绘制起点.</li>
<li>其中参数 x, y 表示在坐标系中的位置, 分别是 x 坐标与 y 坐标.</li>
</ol>
<h4 id="lineTo-方法"><a href="#lineTo-方法" class="headerlink" title="lineTo 方法"></a>lineTo 方法</h4><p>语法: <code>CanvasRenderingContext2D.lineTo( x, y )</code></p>
<p>描述:</p>
<ol>
<li>该方法用于设置需要绘制直线的另一个点. 最终描边后会连线当前点和方法参数描述的点.</li>
<li>其中参数 x, y 表示在坐标系中的位置, 分别是 x 坐标与 y 坐标.</li>
</ol>
<h4 id="stroke-方法"><a href="#stroke-方法" class="headerlink" title="stroke 方法"></a>stroke 方法</h4><p>语法: <code>CanvasRenderingContext2D.stroke()</code></p>
<p>描述: 该方法用于连线, 将描述的所有点按照指定顺序连接起来.</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ol>
<li>绘图先要获得上下文, 即绘图工具</li>
<li>绘图需要设置开始的坐标</li>
<li>绘图是先描点, 然后一个一个依次连线</li>
<li>依次绘图只能绘制单一样式( 色彩等 )</li>
</ol>
<h3 id="直线图形"><a href="#直线图形" class="headerlink" title="直线图形"></a>直线图形</h3><p>分别绘制下面的案例:</p>
<p><img src="./imgs/2016-08-06_023133.png" alt=""></p>
<ol>
<li>绘制直线计算坐标.</li>
<li>描边调用 <code>CanvasRenderingContext2D.stroke()</code> 方法.</li>
<li>填充使用 <code>CanvasRenderingContext2D.fill()</code> 方法.</li>
</ol>
<h4 id="fill-方法"><a href="#fill-方法" class="headerlink" title="fill 方法"></a>fill 方法</h4><p>语法: <code>CanvasRenderingContext2D.fill()</code></p>
<p>描述: 该方法会按照描绘的点的路径来填充图形. 默认是黑色.</p>
<h3 id="非零环绕原则"><a href="#非零环绕原则" class="headerlink" title="非零环绕原则"></a>非零环绕原则</h3><p>绘制下面的图</p>
<p><img src="./imgs/2016-08-06_134021.png" alt=""></p>
<p>填充满足非零环绕数原则</p>
<p><img src="./imgs/20151227142627714.png" alt=""></p>
<p>说明:</p>
<ol>
<li>在 <code>canvas</code> 中使用各种方法描点实际上描述的是一个称为路径( path )的东西.</li>
<li>在 <code>canvas</code> 绘图中, 所有描述的东西都是路径, 只有最后填充或描边的时候才会显示出效果.</li>
<li>每一个路径都是一个状态.</li>
</ol>
<p>练习: 绘制下面图形</p>
<p><img src="./imgs/2016-08-06_135624.png" alt=""></p>
<h3 id="闭合路径"><a href="#闭合路径" class="headerlink" title="闭合路径"></a>闭合路径</h3><h4 id="closePath-方法"><a href="#closePath-方法" class="headerlink" title="closePath 方法"></a>closePath 方法</h4><p>语法: <code>CanvasRenderingContext2D.closePath()</code></p>
<p>描述: 使用该方法可以将最后一个描点与最开始的描点自动连接起来.</p>
<p><strong>案例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">ctx.moveTo( 100, 100 );</div><div class="line">ctx.lineTo( 300, 100 );</div><div class="line">ctx.lineTo( 300, 200 );</div><div class="line">ctx.closePath();</div><div class="line">ctx.stroke();</div></pre></td></tr></table></figure>
<p>结果为:</p>
<p><img src="./imgs/2016-08-06_140228.png" alt=""></p>
<p>练习: 使用 <code>closePath</code> 改写非零环绕的案例.</p>
<h3 id="路径的概念"><a href="#路径的概念" class="headerlink" title="路径的概念"></a>路径的概念</h3><ol>
<li>路径就是一次绘图<ul>
<li>类比使用油漆刷墙面</li>
<li>首先打底色, 绝对不会一次性使用多个色彩</li>
<li>一定是先画完某一个色彩再考虑另一个色彩</li>
<li>除非需要自己创作才会考虑墙面绘画</li>
</ul>
</li>
<li>路径就好比一桶油漆和一把刷子, 一次性描点绘制. 如果重新更换油漆, 那么是绘制另一个区域.</li>
<li>如果需要开启新的绘制, 那么使用 <code>CanvasRenderingContext2D.beginPath()</code> 方法.</li>
</ol>
<p><strong>墙面油漆图示</strong></p>
<p><img src="./imgs/65-141105115211111.jpg" alt=""></p>
<p><img src="./imgs/123.jpg" alt=""></p>
<p><strong>示例</strong></p>
<p>如果需要在一个区域内绘制描边的图形和填充的图形. 例如</p>
<p><img src="./imgs/2016-08-08_124829.png" alt=""></p>
<h3 id="线型相关属性"><a href="#线型相关属性" class="headerlink" title="线型相关属性"></a>线型相关属性</h3><p>设置描边与填充不一定只能使用黑色的细线. 可以利用一些属性设置其效果</p>
<ol>
<li><code>CanvasRenderingContext2D.lineWidth</code> 设置线宽.</li>
<li><code>CanvasRenderingContext2D.lineCap</code> 设置线末端类型.</li>
<li><code>CanvasRenderingContext2D.lineJoin</code> 设置相交线的拐点.</li>
<li><code>CanvasRenderingContext2D.getLineDash()</code> 获得线段样式数组.</li>
<li><code>CanvasRenderingContext2D.setLineDash()</code> 设置线段样式.</li>
<li><code>CanvasRenderingContext2D.lineDashOffset</code> 绘制线段偏移量.</li>
</ol>
<h4 id="设置线宽"><a href="#设置线宽" class="headerlink" title="设置线宽"></a>设置线宽</h4><p>语法: <code>CanvasRenderingContext2D.lineWidth = number</code></p>
<p>描述: 设置线宽.</p>
<p><strong>案例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">ctx.moveTo( 100, 100 );</div><div class="line">ctx.lineTo( 300, 100 );</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">ctx.beginPath();</div><div class="line">ctx.lineWidth = 10;</div><div class="line">ctx.moveTo( 100, 250 );</div><div class="line">ctx.lineTo( 300, 250 );</div><div class="line">ctx.stroke();</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-08_130548.png" alt=""></p>
<h4 id="设置线末端类型"><a href="#设置线末端类型" class="headerlink" title="设置线末端类型"></a>设置线末端类型</h4><p>语法: <code>CanvasRenderingContext2D.lineCap = value</code></p>
<p>描述:</p>
<ol>
<li>设置线型末端的样式, 可取值为: ‘butt’( 默认 ), ‘round’, ‘square’.</li>
<li>‘butt’ 表示两端使用方形结束.</li>
<li>‘round’ 表示两端使用圆角结束.</li>
<li>‘square’ 表示突出的圆角结束.</li>
</ol>
<p><strong>案例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">ctx.lineWidth = 10;</div><div class="line">ctx.moveTo( 100, 100 );</div><div class="line">ctx.lineTo( 300, 100 );</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">ctx.beginPath();</div><div class="line">ctx.lineCap =  &apos;round&apos;;</div><div class="line">ctx.moveTo( 100, 130 );</div><div class="line">ctx.lineTo( 300, 130 );</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">ctx.beginPath();</div><div class="line">ctx.lineCap =  &apos;square&apos;;</div><div class="line">ctx.moveTo( 100, 160 );</div><div class="line">ctx.lineTo( 300, 160 );</div><div class="line">ctx.stroke();</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-08_131353.png" alt=""></p>
<h4 id="设置相交线的拐点"><a href="#设置相交线的拐点" class="headerlink" title="设置相交线的拐点"></a>设置相交线的拐点</h4><p>语法: <code>CanvasRenderingContext2D.lineJoin = value</code></p>
<p>描述:</p>
<ol>
<li>设置两条直线的拐点描述方式. 可以取值 ‘round’, ‘bevel’, ‘miter’(默认)</li>
<li>‘round’ 使用圆角连接.</li>
<li>‘bevel’ 使用平切连接.</li>
<li>‘miter’ 使用直角转.</li>
</ol>
<p><strong>案例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">ctx.lineWidth = 10;</div><div class="line">ctx.lineJoin = &apos;round&apos;;</div><div class="line">ctx.moveTo( 100, 100 );</div><div class="line">ctx.lineTo( 200, 200 );</div><div class="line">ctx.lineTo( 300, 100 );</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">ctx.beginPath();</div><div class="line">ctx.lineJoin = &apos;bevel&apos;;</div><div class="line">ctx.moveTo( 100, 150 );</div><div class="line">ctx.lineTo( 200, 250 );</div><div class="line">ctx.lineTo( 300, 150 );</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">ctx.beginPath();</div><div class="line">ctx.lineJoin = &apos;miter&apos;;</div><div class="line">ctx.moveTo( 100, 200 );</div><div class="line">ctx.lineTo( 200, 300 );</div><div class="line">ctx.lineTo( 300, 200 );</div><div class="line">ctx.stroke();</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-08_132309.png" alt=""></p>
<h4 id="虚线"><a href="#虚线" class="headerlink" title="虚线"></a>虚线</h4><p>语法:</p>
<ol>
<li><code>CanvasRenderingContext2D.lineDashOffset = number</code></li>
<li><code>CanvasRenderingContext2D.getLineDash()</code></li>
<li><code>CanvasRenderingContext2D.setLineDash()</code></li>
</ol>
<p>描述:</p>
<ol>
<li>lineDashOffset用于设置开始绘制虚线的偏移量. 数字的正负表示左右偏移.</li>
<li>getLineDash() 与 setLineDash() 方法使用数组描述实线与虚线的长度.</li>
</ol>
<p><strong>演示</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">ctx.moveTo( 100, 90 );</div><div class="line">ctx.lineTo( 100, 110 );</div><div class="line">ctx.moveTo( 300, 90 );</div><div class="line">ctx.lineTo( 300, 110 );</div><div class="line"></div><div class="line">ctx.moveTo( 100, 140 );</div><div class="line">ctx.lineTo( 100, 160 );</div><div class="line">ctx.moveTo( 300, 140 );</div><div class="line">ctx.lineTo( 300, 160 );</div><div class="line"></div><div class="line">ctx.moveTo( 100, 190 );</div><div class="line">ctx.lineTo( 100, 210 );</div><div class="line">ctx.moveTo( 300, 190 );</div><div class="line">ctx.lineTo( 300, 210 );</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">ctx.beginPath();</div><div class="line">ctx.moveTo( 100, 100 );</div><div class="line">ctx.lineTo( 300, 100 );</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">ctx.beginPath();</div><div class="line">ctx.setLineDash( [ 5, 5 ] );</div><div class="line">ctx.moveTo( 100, 150 );</div><div class="line">ctx.lineTo( 300, 150 );</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">ctx.beginPath();</div><div class="line">ctx.lineDashOffset = -2;</div><div class="line">ctx.moveTo( 100, 200 );</div><div class="line">ctx.lineTo( 300, 200 );</div><div class="line">ctx.stroke();</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-08_134700.png" alt=""></p>
<h4 id="填充与描边样式"><a href="#填充与描边样式" class="headerlink" title="填充与描边样式"></a>填充与描边样式</h4><p>语法:</p>
<ol>
<li><code>CanvasRenderingContext2D.strokeStyle = value</code></li>
<li><code>CanvasRenderingContext2D.fillStyle = value</code></li>
</ol>
<p>描述:</p>
<ol>
<li>strokeStyle 可以设置描边颜色, 与 CSS 的语法一样</li>
<li>fillStyle 设置填充颜色, 与 CSS 语法一样</li>
<li>这两个属性还可以设置渐变对象.</li>
</ol>
<p><strong>案例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">for (var i=0;i&lt;6;i++)&#123;</div><div class="line">    for (var j=0;j&lt;6;j++)&#123;</div><div class="line">        ctx.strokeStyle = &apos;rgb(0,&apos; + Math.floor(255-42.5*i) + &apos;,&apos; + </div><div class="line">                        Math.floor(255-42.5*j) + &apos;)&apos;;</div><div class="line">        ctx.beginPath();</div><div class="line">        ctx.arc(12.5+j*25,12.5+i*25,10,0,Math.PI*2,true);</div><div class="line">        ctx.stroke();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-08_135332.png" alt=""></p>
<h2 id="实例练习"><a href="#实例练习" class="headerlink" title="实例练习"></a>实例练习</h2><h3 id="绘制坐标网格"><a href="#绘制坐标网格" class="headerlink" title="绘制坐标网格"></a>绘制坐标网格</h3><p>绘制下面的效果</p>
<p><img src="./imgs/2016-08-09_121247.png" alt=""></p>
<h3 id="绘制坐标系"><a href="#绘制坐标系" class="headerlink" title="绘制坐标系"></a>绘制坐标系</h3><p>绘制下面的效果</p>
<p><img src="./imgs/2016-08-09_122426.png" alt=""></p>
<h3 id="绘制坐标点"><a href="#绘制坐标点" class="headerlink" title="绘制坐标点"></a>绘制坐标点</h3><p>绘制下面的效果</p>
<p><img src="./imgs/2016-08-09_130716.png" alt=""></p>
<h3 id="绘制折线图"><a href="#绘制折线图" class="headerlink" title="绘制折线图"></a>绘制折线图</h3><p><img src="./imgs/2016-08-09_132957.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Canvas&quot;&gt;&lt;a href=&quot;#什么是-Canvas&quot; class=&quot;headerlink&quot; title=&quot;什么是 Canvas&quot;&gt;&lt;/a&gt;什么是 Canvas&lt;/h2&gt;&lt;p&gt;canvas 是 HTML5 提供的一个用于展示绘图效果的标签. canvas 原意画布, 帆布. 在 HTML 页面中用于展示绘图效果. 最早 canvas 是苹果提出的一个方案, 今天已经在大多数浏览器中实现.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;canvas 英 [&amp;apos;kænvəs]  美 [&amp;apos;kænvəs]   帆布 画布&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="canvas三部曲" scheme="http://yoursite.com/categories/canvas%E4%B8%89%E9%83%A8%E6%9B%B2/"/>
    
    
      <category term="canvas" scheme="http://yoursite.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>CSS3-新属性动画实现</title>
    <link href="http://yoursite.com/2016/04/22/CSS3-%E6%96%B0%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2016/04/22/CSS3-新属性动画实现/</id>
    <published>2016-04-22T13:16:23.000Z</published>
    <updated>2017-02-23T12:37:36.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><p>过渡是CSS3中具有颠覆性的特征之一，可以实现元素不同状态间的平滑过渡（补间动画），经常用来制作动画效果。</p>
<p>帧动画：通过一帧一帧的关键画面按照固定顺序和速度播放。如电影胶片</p>
<p><img src="media/5a93ab21acde7cee4c91f8cc6c2c948f.jpg" alt=""></p>
<p>补间动画：自动完成从起始状到终止状的的过度。</p>
<a id="more"></a>
<p>关于补间动画更多学习可查看<a href="http://mux.alimama.com/posts/1009" target="_blank" rel="external">http://mux.alimama.com/posts/1009</a></p>
<p>特点：当前元素只要有“属性”发生变化时，可以平滑的进行过渡。</p>
<p>transition-property设置过渡属性</p>
<p>transition-duration设置过渡时间</p>
<p>transition-timing-function设置过渡速度</p>
<p>transition-delay设置过渡延时</p>
<p>贝塞尔曲线限定了过渡的轨迹。这部分没有提及，有兴趣同学自行查阅相关资料了解一下即可。</p>
<p>以上四属性重在更解，具体细节可参考手册辅助记忆</p>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>动画是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。</p>
<p>参考手册</p>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>转换是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、变形、缩放，甚至支持矩阵方式，配合即将学习的过渡和动画知识，可以取代大量之前只能靠Flash才可以实现的效果。</p>
<p>2D 转换</p>
<p>translate(x,y) x、y 可为负值，相对自身移动，并未脱离文档流。</p>
<p>左手坐标系：伸出左手，让拇指和食指成“L”形，大拇指向右，食指向上，中指指向前方。这样我们就建立了一个左手坐标系，拇指、食指和中指分别代表X、Y、Z轴的正方向。</p>
<p>左手法则：左手握住旋转轴，竖起拇指指向旋转轴正方向，正向旋转方向就是其余手指卷曲的方向。</p>
<p><img src="media/d7743a7db602d3205b481e87afc6b6a7.png" alt=""></p>
<p>3D坐标轴，用X、Y、Z分别表示空间的3个维度，三条轴上互相垂直。</p>
<p><img src="media/4785ab4ee3f1e938fa3652106c7890e3.png" alt=""></p>
<h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><p>由于网页呈现终端设备越来越趋向于多样化，尤其是移动终端（手机），具有不同屏幕尽寸、不同分辨率，为了保证网页能十分友好的呈现，CSS3为开发人员提供了可以识别呈现终端的方法，这样便可以有针对性的为不同的呈现终端分别进行处理，被广泛应用于响应式开发中。</p>
<p>html 标签方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;viewport content=&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot;/&gt;</div></pre></td></tr></table></figure>
<p>css 属性方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@media screen and (max-width:720px) and (min-width:320px)&#123;</div><div class="line"></div><div class="line">      body&#123;</div><div class="line"></div><div class="line">       background-color:red;</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">@media screen and (max-width:320px)&#123;</div><div class="line"></div><div class="line">      body&#123;</div><div class="line"></div><div class="line">         background-color:blue;</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>常使用的是检测设备宽度</p>
<h2 id="Web字体与字体格式"><a href="#Web字体与字体格式" class="headerlink" title="Web字体与字体格式"></a>Web字体与字体格式</h2><p>开发人员可以为自已的网页指定特殊的字体，无需考虑用户电脑上是否安装了此特殊字体，从此把特殊字体处理成图片的时代便成为了过去。</p>
<p>支持程度比较好，甚至IE低版本浏览器也能支持。</p>
<p>不同浏览器所支持的字体格式是不一样的，我们有必要了解一下有关字体格式的知识。</p>
<p>1、TureTpe(.ttf)格式</p>
<p>.ttf字体是Windows和Mac的最常见的字体，是一种RAW格式，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOS<br>Mobile、Safari4.2+；</p>
<p>2、OpenType(.otf)格式</p>
<p>.otf字体被认为是一种原始的字体格式，其内置在TureType的基础上，支持这种字体的浏览器有Firefox3.5+、Chrome4.0+、Safari3.1+、Opera10.0+、iOS<br>Mobile、Safari4.2+；</p>
<p>3、Web Open Font Format(.woff)格式</p>
<p>woff字体是Web字体中最佳格式，他是一个开放的TrueType/OpenType的压缩版本，同时也支持元数据包的分离，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+；</p>
<p>4、Embedded Open Type(.eot)格式</p>
<p>.eot字体是IE专用字体，可以从TrueType创建此格式字体，支持这种字体的浏览器有IE4+；</p>
<p>5、SVG(.svg)格式</p>
<p>.svg字体是基于SVG字体渲染的一种格式，支持这种字体的浏览器有Chrome4+、Safari3.1+、Opera10.0+、iOS<br>Mobile Safari3.2+；</p>
<p>关于字体介绍摘自<a href="http://www.w3cplus.com/content/css3-font-face/" target="_blank" rel="external">http://www.w3cplus.com/content/css3-font-face/</a></p>
<p>了解了上面的知识后，我们就需要为不同的浏览器准备不同格式的字体，通常我们会通过字体生成工具帮我们生成各种格式的字体，因此无需过于在意字体格式间的区别差异。</p>
<p>推荐<a href="http://www.zhaozi.cn/、http://www.youziku.com/" target="_blank" rel="external">http://www.zhaozi.cn/、http://www.youziku.com/</a> 查找更多中文字体</p>
<h2 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h2><p>其实我们可以把文字理解成是一种特殊形状的图片，反之我们是不是也可以把图片制作成字体呢？</p>
<p>答案是肯定的。</p>
<p>常见的是把网页常用的一些小的图标，借助工具帮我们生成一个字体库，然后就可以像使用文字一样使用图标了。</p>
<p>优点：</p>
<p>1、将所有图标打包成字体库，减少请求；</p>
<p>2、具有矢量性，可保证清晰度；</p>
<p>3、使用灵活，便于维护；</p>
<p>Font Awesome 使用介绍</p>
<p><a href="http://fontawesome.dashgame.com/" target="_blank" rel="external">http://fontawesome.dashgame.com/</a></p>
<p>定制自已的字体图标库</p>
<p><a href="http://iconfont.cn/" target="_blank" rel="external">http://iconfont.cn/</a></p>
<p><a href="https://icomoon.io/" target="_blank" rel="external">https://icomoon.io/</a></p>
<p>SVG</p>
<p><a href="http://www.iconsvg.com/" target="_blank" rel="external">http://www.iconsvg.com/</a></p>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>通过<a href="http://caniuse.com/" target="_blank" rel="external">http://caniuse.com/</a><br>可查询CSS3各特性的支持程度，一般兼容性处理的常见方法是为属性添加私有前缀，如不能解决，应避免使用，无需刻意去处理CSS3的兼容性问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;过渡&quot;&gt;&lt;a href=&quot;#过渡&quot; class=&quot;headerlink&quot; title=&quot;过渡&quot;&gt;&lt;/a&gt;过渡&lt;/h2&gt;&lt;p&gt;过渡是CSS3中具有颠覆性的特征之一，可以实现元素不同状态间的平滑过渡（补间动画），经常用来制作动画效果。&lt;/p&gt;
&lt;p&gt;帧动画：通过一帧一帧的关键画面按照固定顺序和速度播放。如电影胶片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;media/5a93ab21acde7cee4c91f8cc6c2c948f.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;补间动画：自动完成从起始状到终止状的的过度。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3从入门到精通" scheme="http://yoursite.com/categories/CSS3%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"/>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>CSS3-新属性的合理使用</title>
    <link href="http://yoursite.com/2016/04/12/CSS3-%E6%96%B0%E5%B1%9E%E6%80%A7%E7%9A%84%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/04/12/CSS3-新属性的合理使用/</id>
    <published>2016-04-12T13:16:23.000Z</published>
    <updated>2017-02-23T12:37:34.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>新增了RGBA、HSLA模式，其中的A<br>表示透明度通道，即可以设置颜色值的透明度，相较opacity，不具有继承性，即不会影响子元素的透明度。</p>
<p>Red、Green、Blue、Alpha即RGBA</p>
<p>Hue、Saturation、Lightness、Alpha即HSLA</p>
<p>R、G、B 取值范围0~255</p>
<a id="more"></a>
<p>H 取值范围0~360，0/360表示黑色、120表示绿色、240表示蓝色</p>
<p>S 取值范围0%~100%</p>
<p>L 取值范围0%~100%</p>
<p>A 取值范围0~1</p>
<p>关于透明度：</p>
<p>1、opacity子元素会继承父元素的透明度，在实际开发中会带来干扰；</p>
<p>2 、transparent 设置透明度时完全类似于“玻璃”一样的透明；</p>
<h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><p>参考手册</p>
<p>文字阴影与边框阴影相似，可分别设置偏移量、模糊度、颜色（可设透明度）。</p>
<p>单行文本溢出，需要配合overflow:hidden; white-space: nowrap;</p>
<p>难理解的点：</p>
<p>自已要多试着理解一下关于white-space的各个属性值之间的差异；</p>
<p>换行符指的我们在键盘上的Enter键，Enter换行符会被当成空行来对待，而由Tab、Space产生的换行，则会视为一个空格。</p>
<p>上述方法只能解决单行文本的溢出问题，多行文本溢出处理可参照下面的方法，但是有比较严重的兼容性，需要慎重选择，比较完备的多行溢出需要JS辅助完成，可自行尝试。</p>
<p>多行文本文字溢出处理，非标准属性，可应用于移动端</p>
<p><img src="media/110dabcaf6cdf82762d885fa2ddf3bbf.png" alt=""></p>
<p>了解常握white-space 使用</p>
<h2 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h2><p>其边框圆角、边框阴影属性，应用十分广泛，兼容性也相对较好，具有符合渐进增强原则的特征，我们需要重点掌握。</p>
<h3 id="边框圆角"><a href="#边框圆角" class="headerlink" title="边框圆角"></a>边框圆角</h3><p>圆角处理时，脑中要形成圆、圆心、长半径、短半径的概念，正圆是椭圆的一种特殊情况。</p>
<p><img src="media/f47499199d6f29d290db7d1982f5129b.jpg" alt=""></p>
<p><img src="media/c0561bcfb177623973edca46b1def4cb.jpg" alt=""></p>
<p>可分别设置长、短半径，以“/”进行分隔，遵循“1，2，3，规则，“/”前面的1~4个用来设置横轴半径（分别对应横轴1、2、3、4位置<br>），“/”后面1~4个参数用来设置纵轴半径（分别对应纵轴1、2、3、4位置 ）</p>
<p>参考手册练习熟悉各种简写方式。</p>
<p><img src="media/6eb78c9ef294ad96c371e4acf5293373.png" alt=""></p>
<p>表格运用圆角需要要 border-collapse: separate;</p>
<p>当圆角半径小于或等于边框宽度时，元素内角是直角</p>
<p><img src="media/ec378877baa4e52a8a2d3e2286cba527.jpg" alt=""></p>
<p>如何在PS中查看圆角半径？</p>
<h3 id="边框图片"><a href="#边框图片" class="headerlink" title="边框图片"></a>边框图片</h3><p>设置的图片将会被“切割”成九宫格形式，然后进行设置。如下图</p>
<p><img src="media/9171683f69de8eebd5b25cfe91f863d4.png" alt=""></p>
<p>“切割”完成后生成虚拟的9块图形，然后按对应位置设置背景，</p>
<p>其中四个角位置、形状保持不变，中心位置水平垂直两个方向平铺。如下图</p>
<p><img src="media/14a92e451681185de5b7621291e2a32d.png" alt=""></p>
<p>round 会自动调整尺寸，完整显示边框图片。</p>
<p><img src="media/5fbe0c6dcc68370c2733dd455244a14f.png" alt=""></p>
<p>repeat 单纯平铺多余部分，会被“裁切”而不显示。</p>
<p><img src="media/be8cfbfce83501be207fab3389e9d1ba.png" alt=""></p>
<p>background-slice: 27 40 40 27 分别设置裁切如下图</p>
<p><img src="media/e8df6939c2f1ba831a3fed0e2b0b2b69.png" alt=""></p>
<h3 id="边框阴影"><a href="#边框阴影" class="headerlink" title="边框阴影"></a>边框阴影</h3><p>水平偏移量 正值向右 负值向左 垂直正值向下 负值向上。</p>
<p>模糊度是不能为负</p>
<p>关于模糊度：从一个颜色值在一定距离内进行一个渐变至透明的过程。</p>
<p>移量和扩展也是数学运算的，即正负会相互抵消。</p>
<p>偏移量和模糊度是可以相加计算，偏移量负号只代表方向。</p>
<p>设置边框阴影不会影响盒子的布局，即不会影响其兄弟元素的布局。</p>
<p>spread可以与blur、h-shadow、v-shadow相互抵消，blur不可为负值</p>
<p>可以设置多重边框阴影，实现更好的效果，增强立体感。</p>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>关于盒模型存在两种形式，分别是W标准盒模型和IE盒模型，如下图所示，其区别主要在于宽度和高度的计算方式，CSS3对盒模型做出了新的定义，即允许开发人员指定盒子宽度和高度的计算方式。</p>
<p><img src="media/70176261fa465100896b26daa60a68b9.png" alt=""></p>
<p>IE模型下 width = padding + content + border;</p>
<p>W盒模型下 width = content</p>
<p>box-sizing: border-box width = border + padding + content</p>
<p>box-sizing: content-box width = content</p>
<p>IE盒模型只会出现在IE5版本和IE6+的怪异模式中。</p>
<p>怪异模式</p>
<p><a href="http://www.cnblogs.com/coco1s/p/4034937.html" target="_blank" rel="external">http://www.cnblogs.com/coco1s/p/4034937.html</a></p>
<p>CSS3中可以通过box-sizing 来指定盒模型，即可指定为content-box、border-box;</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>背景在CSS3中也得到很大程度的增强，比如背景图片尺寸、背景裁切区域、背景定位参照点、多重背景等。</p>
<p>cover 会使“最大”边，进行缩放，另一边同比缩放，铺满容器，超出部分会溢出。</p>
<p>contain 会使“最小”边，进行缩放，另一边同比缩放，不一定铺满容器，会完整显示图片。</p>
<p>background-size 与 background-clip无关</p>
<p>background-size 与 background-origin 保持一致</p>
<p>背景图片尺寸在实际开发中应用十分广泛。</p>
<p>参照手册</p>
<h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><p>渐变是CSS3当中比较丰富多彩的一个特性，通过渐变我们可以实现许多炫丽的效果，有效的减少图片的使用数量，并且具有很强的适应性和可扩展性。</p>
<p>可分为线性渐变、径向渐变、重复渐变。</p>
<p>线性渐变指沿着某条直线朝一个方向产生渐变效果。</p>
<p><img src="media/034a779c365083d01081894aead93624.png" alt=""></p>
<p>上图是从黄色渐变到绿色</p>
<p>必要的元素：方向、起始颜色、终止色；</p>
<p>关于方向如下图</p>
<p><img src="media/b92cf8974fdc164ef8a418224172da03.png" alt=""></p>
<p>关于颜色起止，可以设置多个色值的渐变，并且可以分别设置渐变的距离</p>
<p>如 linear-gradient(to left, yellow 10%, blue 15%, red 50%)</p>
<p>径向渐变指从一个中心点开始沿着四周产生渐变效果</p>
<p><img src="media/bddba71b972ce8b23f29633086849274.png" alt=""></p>
<p>特点：</p>
<p>1、辐射范围</p>
<p>2、中心点</p>
<p>3、颜色的起止</p>
<p>关于中心点：中心位置参照的是盒子的左上角</p>
<p>关于辐射范围：其半径可以不等即可以是椭圆</p>
<p>关于圆的知识同边框圆角章节的介绍</p>
<h2 id="伸缩布局"><a href="#伸缩布局" class="headerlink" title="伸缩布局"></a>伸缩布局</h2><p>CSS3在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用，使得开发人员一下子就过上了小康的生活。</p>
<p>伸缩盒模型经历了几次演变，大致分为旧版伸缩布局、过渡伸缩布局、新版伸缩布局，同样为了避免混淆，我们以学习新版伸缩布局为主。</p>
<h3 id="新版伸缩布局"><a href="#新版伸缩布局" class="headerlink" title="新版伸缩布局"></a>新版伸缩布局</h3><p>这里我们需要引入一些新的概念：</p>
<p>主轴：Flex容器的主轴主要用来配置Flex项目。</p>
<p>侧轴：与主轴垂直的轴称作侧轴，是侧轴方向的延伸。</p>
<p>主轴和侧轴并不是固定不变的，通过flex-direction可以调整。</p>
<p><img src="media/ea625a3d38b0d9ddffc17e9014e27c00.png" alt=""></p>
<p>1、指定一个盒子为伸缩盒子 display: flex</p>
<p>2、设置属性来调整此盒的子元素的布局方式 例如 flex-direction</p>
<p>3、明确主侧轴的方向</p>
<p>4、可互换主侧轴，也可改变方向</p>
<p>其相关属性可参照源代码里的解释如flex-direction、flex-wrap、flex-flow、align-items、align-content、justify-content、align-self、flex、order等</p>
<p>另个两个版本伸缩布局其实现思路与新版基本一致，区别在于其属性及属性值不同，熟练掌握新版伸缩布局后，要参照对比另外两个版本的不同。</p>
<h2 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h2><p>类似报纸或杂志中的排版方式，上要用以控制大篇幅文本。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;颜色&quot;&gt;&lt;a href=&quot;#颜色&quot; class=&quot;headerlink&quot; title=&quot;颜色&quot;&gt;&lt;/a&gt;颜色&lt;/h2&gt;&lt;p&gt;新增了RGBA、HSLA模式，其中的A&lt;br&gt;表示透明度通道，即可以设置颜色值的透明度，相较opacity，不具有继承性，即不会影响子元素的透明度。&lt;/p&gt;
&lt;p&gt;Red、Green、Blue、Alpha即RGBA&lt;/p&gt;
&lt;p&gt;Hue、Saturation、Lightness、Alpha即HSLA&lt;/p&gt;
&lt;p&gt;R、G、B 取值范围0~255&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3从入门到精通" scheme="http://yoursite.com/categories/CSS3%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"/>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>CSS3-正确使用选择器</title>
    <link href="http://yoursite.com/2016/04/04/CSS3-%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <id>http://yoursite.com/2016/04/04/CSS3-正确使用选择器/</id>
    <published>2016-04-04T12:06:25.000Z</published>
    <updated>2017-02-23T12:11:22.022Z</updated>
    
    <content type="html"><![CDATA[<p>如同人类的的进化一样，CSS3是CSS2的“进化”版本，在CSS2基础上，增强或新增了许多特性，<br>弥补了CSS2的众多不足之处，使得Web开发变得更为高效和便捷。</p>
<h2 id="CSS3的现状"><a href="#CSS3的现状" class="headerlink" title="CSS3的现状"></a>CSS3的现状</h2><p>1、浏览器支持程度差，需要添加私有前缀</p>
<a id="more"></a>
<p>2、移动端支持优于PC端</p>
<p>3、不断改进中</p>
<p>4、应用相对广泛</p>
<h2 id="学会使用手册"><a href="#学会使用手册" class="headerlink" title="学会使用手册"></a>学会使用手册</h2><p>学会使用工具，可以让我们事半功倍。</p>
<p>[] 表示全部可选项</p>
<p>|| 表示或者</p>
<p>| 表示多选一</p>
<p>？ 表示0个或者1个</p>
<p>* 表示0个或者多个</p>
<p>{} 表示范围</p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>CSS3新增了许多灵活查找元素的方法，极大的提高了查找元素的效率和精准度。CSS3选择器与jQuery中所提供的绝大部分选择器兼容。</p>
<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>参考手册</p>
<p>1、E[attr] 表示存在attr属性即可；</p>
<p>2、E[attr=val] 表示属性值完全等于val</p>
<p>3、E[attr~=val] 表示的一个单独的属性值 这个属性值是以空格分隔的</p>
<p>4、E[attr|=val] 表示的要么一个单独的属性值 要么这个属性值是以“-”分隔的</p>
<p>5、E[attr*=val] 表示的属性值里包含val字符并且在“任意”位置</p>
<p>6、E[attr\^=val] 表示的属性值里包含val字符并且在“开始”位置</p>
<p>7、E[attr\$=val] 表示的属性值里包含val字符并且在“结束”位置</p>
<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>参考手册</p>
<p>重点理解E是用来参考确定其父元素的，nth-child(n)<br>对应根据E元素确定的父元素的所有子元素，nth-of-type(n)<br>的不同之处在于其对应的是只有E元素，会忽略其子元素。（此处要配合案例加强理解）</p>
<p>E:nth-child(n) 第n个子元素，计算方法是E元素的全部兄弟元素</p>
<p>E:nth-of-type(n) 第n个子元素，计算方法只是E元素，会忽略其子元素的</p>
<p>存在</p>
<p>E:nth-last-child(n) 同E:nth-child(n) 计算顺序相反。</p>
<p>E:nth-last-of-type(n) 同E:nth-of-type(n) 计算顺序相反。</p>
<p>n遵循线性变化，其取值1、2、3、4、…</p>
<p>关于n的取值范围：</p>
<p>1、当n做为一个独立值时，n取值为n>=1，例如nth-child(n)</p>
<p>2、当n做一个系数时，n取值为n>=0者n\&lt;0，例如nth-child(2n+1)、nth-child(-1n+5)<br>此处需要理解2n+1或者-n+5做为一个整体不能小于1；</p>
<p>E:only-child 表示当前以E确定的父元素，除E之外并无其它子元素（独生子）；</p>
<p>E:only-of-type表示当前以E确定的父元素， 除E之外不能包含其它和E同类型的子元素；</p>
<p>E:target 结合锚点进行使用，处于当前锚点的元素会被选中；</p>
<p>E:empty 选中没有任何子节点的E元素；</p>
<h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><p>E::selection 可改变选中文本的样式</p>
<p>E::placeholder<br>可改变placeholder默认样式，这个存在明显的兼容问题，比如::-webkit-input-placeholder，具体参考手册进行对比。</p>
<p>E:after、E:before<br>在旧版本里是伪类，在新版本里是伪元素，新版本下E:after、E:before会被自动识别为E::after、E::before，按伪元素来对待。</p>
<p>“:” 与 “::” 区别在于区分伪类和伪元素</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如同人类的的进化一样，CSS3是CSS2的“进化”版本，在CSS2基础上，增强或新增了许多特性，&lt;br&gt;弥补了CSS2的众多不足之处，使得Web开发变得更为高效和便捷。&lt;/p&gt;
&lt;h2 id=&quot;CSS3的现状&quot;&gt;&lt;a href=&quot;#CSS3的现状&quot; class=&quot;headerlink&quot; title=&quot;CSS3的现状&quot;&gt;&lt;/a&gt;CSS3的现状&lt;/h2&gt;&lt;p&gt;1、浏览器支持程度差，需要添加私有前缀&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3从入门到精通" scheme="http://yoursite.com/categories/CSS3%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"/>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>深入了解jQuery</title>
    <link href="http://yoursite.com/2016/03/22/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3jQuery/"/>
    <id>http://yoursite.com/2016/03/22/深入了解jQuery/</id>
    <published>2016-03-22T08:31:28.000Z</published>
    <updated>2017-02-23T12:11:03.227Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动画函数"><a href="#动画函数" class="headerlink" title="动画函数"></a>动画函数</h2><p>jQuery提供的一组常见的动画效果，这些动画是标准的、有规律的效果；同时还提供给我们了自定义动画的功能。</p>
<h3 id="隐藏显示动画"><a href="#隐藏显示动画" class="headerlink" title="隐藏显示动画"></a>隐藏显示动画</h3><p><strong>show()方法</strong></p>
<p>形式一：</p>
<p>// 不带参数，没有动画</p>
<p>\$(selector).show();//作用等同于css(“display”, ”block”)</p>
<a id="more"></a>
<p>形式二：</p>
<p>//参数为数值，表示：执行动画时长</p>
<p>\$(selector).show(2000);//单位为毫秒（ms），2000毫秒即2秒</p>
<p>形式三：</p>
<p>//参数为字符串，是jQuery预设的值，共有三个，分别是：slow、normal、fast</p>
<p>\$(selector).show(“slow”); //slow：600ms、normal：400ms、fast：200ms</p>
<p>形式四：</p>
<p>// 参数一可以是数值类型或者字符串类型</p>
<p>// 参数二表示：动画执行完后立即执行的回调函数</p>
<p>\$(selector).show(2000, function() {});</p>
<p><strong>hide()方法</strong></p>
<p>\$(selector).hide();</p>
<p>\$(selector).hide(1000);</p>
<p>\$(selector).hide(“slow”);</p>
<p>\$(selector).hide(1000, function(){});</p>
<p><strong>显示隐藏切换</strong></p>
<p>\$(selector).toggle(speed,callback);</p>
<p>jQuery预设的三组动画效果的语法几乎一致：</p>
<p>参数可以有两个，第一个是动画的执行时长(可以是指定字符或毫秒)，第二个是动画执行完成后的回调函数。</p>
<h3 id="滑入滑出动画"><a href="#滑入滑出动画" class="headerlink" title="滑入滑出动画"></a>滑入滑出动画</h3><p><strong>滑入效果</strong></p>
<p>作用：让元素以下拉动画效果<strong>展示</strong>出来</p>
<p>\$(selector).slideDown(speed,callback);</p>
<p><strong>滑出动画</strong></p>
<p>作用：让元素以上拉动画效果<strong>隐藏</strong>起来</p>
<p>\$(selector).slideUp(speed,callback);</p>
<p><strong>滑入滑出切换</strong></p>
<p>\$(selector).slideToggle(speed,callback);</p>
<h3 id="淡入淡出动画"><a href="#淡入淡出动画" class="headerlink" title="淡入淡出动画"></a>淡入淡出动画</h3><p><strong>淡入效果</strong></p>
<p>作用：让元素以淡淡的进入视线的方式<strong>展示</strong>出来</p>
<p>\$(selector).fadeIn(speed, callback);</p>
<p><strong>淡出效果</strong></p>
<p>作用：让元素以渐渐消失的方式<strong>隐藏</strong>起来</p>
<p>\$(selector).fadeOut(1000);</p>
<p><strong>淡入淡出切换</strong></p>
<p>作用：通过改变不透明度，切换匹配元素的显示或隐藏状态</p>
<p>\$(selector).fadeToggle(‘fast’,function(){});</p>
<p><strong>淡淡达到效果</strong></p>
<p>改变不透明度到某个值</p>
<p>与淡入淡出的区别：淡入淡出只能控制元素的不透明度从 完全不透明<br>到完全透明；而fadeTo可以指定元素不透明度的具体值。并且时间参数是必需的！</p>
<p>作用：调节匹配元素的不透明度</p>
<p>// 用法有别于其他动画效果</p>
<p>// 第一个参数表示：时长</p>
<p>// 第二个参数表示：不透明度值，取值范围：0-1</p>
<p>\$(selector).fadeTo(1000, .5); //0全透，1全不透</p>
<p>// 第一个参数为0，此时作用相当于：.css(“opacity”, .5);</p>
<p>\$(selector).fadeTo(0, .5);</p>
<h3 id="动画方法总结"><a href="#动画方法总结" class="headerlink" title="动画方法总结"></a>动画方法总结</h3><p><img src="media/3aaaca3741c7de7d5dd626f86be6387a.png" alt=""></p>
<p>有规律的体现：</p>
<p>jQuery提供的这几个动画效果控制的CSS属性包括：高度、宽度、不透明度。{height:400px;<br>width:300px; opacity:.4;}</p>
<p>这三个CSS属性的共性是：属性值只有一个（合写的不行），并且这个值是数值（至少经过准换后能变为数值）。</p>
<h3 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h3><p>注意：所有能够执行动画的属性必须只有一个数字类型的值。</p>
<p>比如：要改变字体大小，要使用：fontSize（font-size），不要使用：font</p>
<p>动画支持的属性：</p>
<p><a href="http://www.w3school.com.cn/jquery/effect_animate.asp" target="_blank" rel="external">http://www.w3school.com.cn/jquery/effect_animate.asp</a></p>
<p>作用：执行一组CSS属性的自定义动画</p>
<p>// 第一个参数表示：要执行动画的CSS属性（必选）</p>
<p>// 第二个参数表示：执行动画时长（可选）</p>
<p>// 第三个参数表示：动画执行完后立即执行的回调函数（可选）</p>
<p>\$(selector).animate({params},speed,callback);</p>
<h3 id="停止动画"><a href="#停止动画" class="headerlink" title="停止动画"></a>停止动画</h3><p>作用：停止当前正在执行的动画</p>
<p><strong>为什么要停止动画？</strong></p>
<p>如果多个动画在同一元素上执行，对这个元素来说，后面的动画将被放到队列中，从而形成动画队列。（联想：排队进站）</p>
<p>上一个动画执行完成，下一个动画才能执行，但是这样的效果有时不是我们想要的。</p>
<p>// 第一个参数表示是否清空所有的后续动画</p>
<p>// 第二个参数表示是否立即执行完当前正在执行的动画</p>
<p>\$(selector).stop(clearQueue,jumpToEnd);</p>
<p><strong>解释：</strong></p>
<p>当调用stop()方法后，当前动画停止于当前样式的只（不会到达目标值），队列中的下一个动画会立即开始。</p>
<p>如果参数clearQueue被设置为true，那么队列中剩余的动画就被删除了，永远不会再执行。</p>
<p>如果参数jumpToEnd被设置为true，那么当前动画会停止，但是参与动画的每一个CSS属性将被立即设置为它们的目标值。比如：slideUp()方法，那么元素会立即隐藏掉。如果存在回调函数，回调函数也会立即执行。</p>
<p><strong>另外：</strong></p>
<p>如果元素动画还没有执行完，此时调用sotp()方法，那么当前动画将会停止。并且由于本次动画没有执行完成，本次动画的回调函数也不会被执行（下一次的会照常执行）。</p>
<p><strong>常用方式：</strong></p>
<p>\$(selector).stop();//当前动画停止于此刻的样式状态 后面的动画继续执行</p>
<h2 id="节点操作（重点）"><a href="#节点操作（重点）" class="headerlink" title="节点操作（重点）"></a>节点操作（重点）</h2><h3 id="动态创建元素"><a href="#动态创建元素" class="headerlink" title="动态创建元素"></a>动态创建元素</h3><p>// \$()函数的另外一个作用：动态创建元素</p>
<p>var \$span = \$(“\<span\>我是一个span元素\</span\>”);</p>
<h3 id="添加元素（重点）"><a href="#添加元素（重点）" class="headerlink" title="添加元素（重点）"></a>添加元素（重点）</h3><p><strong>append()（重点）</strong></p>
<p>作用：在被选元素内部的最后一个子元素（或内容）后面插入内容（页面中存在或者创建出来的元素都可以）</p>
<p>//在\$(selector)中追加\$node</p>
<p>\$(selector).append(\$node);</p>
<p>//在\$(selector)中追加div元素，参数为htmlString</p>
<p>\$(selector).append(‘\<div\>\</div\>‘);</p>
<p>如果是页面中存在的元素，那么调用append()后，会把这个元素从原先的位置移除，然后再插入到新的位置。</p>
<p>如果给多个目标追加一个元素，append()方法内部会将这个元素复制多份，然后追加到多个目标中。（最好不要这么做）</p>
<p>常用参数：htmlString 或 jQuery对象</p>
<p>不常用操作（了解即可）：（用法跟append()方法基本一致）</p>
<p><strong>prepend()</strong></p>
<p>作用：在元素的第一个子元素前面追加内容或节点</p>
<blockquote>
<p>  \$(selector).prepend(node);</p>
</blockquote>
<p><strong>after()</strong></p>
<p>作用：在被选元素之后，作为兄弟元素插入内容或节点</p>
<p>\$(selector).after(node);</p>
<p><strong>before()</strong></p>
<p>作用：在被选元素之前，作为兄弟元素插入内容或节点</p>
<p>\$(selector).before(node);</p>
<h3 id="html创建元素"><a href="#html创建元素" class="headerlink" title="html创建元素"></a>html创建元素</h3><p>作用：设置或返回所选元素的html内容（包括 HTML 标记）</p>
<p>设置内容的时候，如果是html标记，会动态创建元素，此时作用跟JS里面的<br>innerHTML属性相同</p>
<p>// 动态创建元素</p>
<p>\$(selector).html(‘\<span\>传智播客\</span\>’);</p>
<p>// 获取html内容</p>
<p>\$(selector).html();</p>
<h3 id="清空元素"><a href="#清空元素" class="headerlink" title="清空元素"></a>清空元素</h3><p>//清空指定元素的所有子元素</p>
<p>\$(selector).empty();</p>
<p>\$(selector).html(“”);</p>
<p>//”自杀”把自己（包括所有内部元素）从文档中删除掉</p>
<p>\$(selector).remove();</p>
<h3 id="复制元素"><a href="#复制元素" class="headerlink" title="复制元素"></a>复制元素</h3><p>// 复制\$(selector)所匹配到的元素</p>
<p>// 返回值为复制的新元素</p>
<p>\$(selector).clone();</p>
<p>推荐</p>
<p>使用html(“\<span\>\</span\>”)方法来创建元素</p>
<p>使用html(“”)清空元素（但是这样无法清除对象身上的事件，造成内存泄漏（少量的无所谓））</p>
<h3 id="代码-文本-值"><a href="#代码-文本-值" class="headerlink" title="代码/文本/值"></a>代码/文本/值</h3><p><strong>html() 方法</strong></p>
<p>作用：设置或获取匹配元素的代码内容</p>
<p>\$(selector).html(); //获取</p>
<p>\$(selector).html(‘\<span\>传智播客\</span\>’); //设置</p>
<p><strong>text() 方法</strong></p>
<p>作用：设置或获取匹配元素的文本内容</p>
<p>\$(selector).text();//获取操作不带参数</p>
<p>（注：会把所有匹配到的元素内容拼接为一个字符串，不同于其他获取操作！）</p>
<p>\$(selector).text(“我是内容”);//设置操作带参数，参数表示要设置的文本内容</p>
<p><strong>val()方法</strong></p>
<p>作用：设置或返回<strong>表单元素</strong>的值，例如：input,select,textarea的值</p>
<p>\$(selector).val();// 获取匹配元素的值，只匹配第一个元素</p>
<p>\$(selector).val(“具体值”);// 设置所有匹配到的元素的值</p>
<h3 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h3><p>设置属性：</p>
<p>// 第一个参数表示：要设置的属性名称</p>
<p>// 第二个参数表示：该属性的值</p>
<p>\$(selector).attr(“title”, “传智播客”);</p>
<p>获取属性：</p>
<p>// 参数为：只传入要获取的属性的名称即可返回指定属性的值</p>
<p>\$(selector).attr(“title”);</p>
<p>移除属性：</p>
<p>// 参数为：要移除的属性的名称</p>
<p>\$(selector).removeAttr(“title”);</p>
<p>注意：表单元素中属性值为布尔值的属性，如checked、selected、disabled要使用.prop()方法</p>
<p>\$(selector).prop(“checked”); //获取</p>
<p>\$(selector).prop(“checked”, true ); //设置</p>
<p>细节参考：<a href="http://api.jquery.com/prop/" target="_blank" rel="external">http://api.jquery.com/prop/</a></p>
<h2 id="尺寸位置"><a href="#尺寸位置" class="headerlink" title="尺寸位置"></a>尺寸位置</h2><h3 id="尺寸操作"><a href="#尺寸操作" class="headerlink" title="尺寸操作"></a>尺寸操作</h3><p>在jQuery中有一套可以非常方便的操作元素尺寸的系列方法。</p>
<p>height()与width()：设置或者返回元素的高度及高度,返回结果是<strong>数值类型</strong>。</p>
<p>innerWidth()与innerHeight()：包括padding</p>
<p>outerWidth()与outerHeigth()：包括padding、border</p>
<p>outWidth(true)与outerHeight(true)：包括padding、border、margin</p>
<p>注：只有height()与width（）可以进行设置操作，innerWidth（）、outWidth（）都是只读属性，只能获取、不能设置。</p>
<h3 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h3><p><strong>scrollTop()</strong></p>
<p>作用：获取或者设置元素垂直方向滚动的位置</p>
<p>//获取</p>
<p>\$(selector).scrollTop();</p>
<p>//设置，参数为数值类型</p>
<p>\$(selector).scrollTop(100);</p>
<p><strong>scrollLeft()</strong></p>
<p>作用：获取或者设置元素水平方向滚动的位置</p>
<p>//获取</p>
<p>\$(selector).scrollLeft();</p>
<p>//设置，参数为数值类型</p>
<p>\$(selector).scrollLeft(100);</p>
<p><strong>offset()</strong></p>
<p>作用：获取或设置元素相对于document左上角的位置</p>
<p>//无参数表示获取，返回值为：{left:num, top:num}，值是相对于document的位置</p>
<p>\$(selector).offset();</p>
<p>//有参数表示设置，参数推荐使用数值类型</p>
<p>\$(selector).offset({left:100, top: 150});</p>
<p>注意：使用offset操作，如果元素没有设置定位(默认position:static)，则会把position修改为relative.会修改left、top</p>
<p><strong>position()</strong></p>
<p>获取相对于其最近的有定位的父元素的位置。相当于之前JS中的offsetLeft和offsetTop</p>
<p>// 获取，返回值为对象：{left:num, top:num}</p>
<p>\$(selector).position();</p>
<p>注意：position方法只能获取，不能设置</p>
<h2 id="序列化表单提交内容"><a href="#序列化表单提交内容" class="headerlink" title="序列化表单提交内容"></a>序列化表单提交内容</h2><h3 id="serialize"><a href="#serialize" class="headerlink" title="serialize()"></a>serialize()</h3><p>序列表表格内容为字符串。</p>
<h3 id="serializeArray"><a href="#serializeArray" class="headerlink" title="serializeArray()"></a>serializeArray()</h3><p>序列化表格元素 (类似 ‘.serialize()’ 方法) 返回 JSON 数据结构数据。</p>
<p>返回的JSON对象是由一个对象数组组成的，其中每个对象包含一个或两个名值对——name参数和value参数（如果value不为空的话）。</p>
<p>jQuery基础课程 — 其他知识</p>
<h2 id="jQuery事件"><a href="#jQuery事件" class="headerlink" title="jQuery事件"></a>jQuery事件</h2><h3 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h3><p>jQuery的事件机制，指的是：jQuery对JavaScript操作DOM事件的封装，包括了：事件绑定、事件解绑、事件触发。</p>
<p>JavaScript：</p>
<p>btn.onclick = function() {}; //给这个按钮绑定事件</p>
<p>jQuery：</p>
<p>\$btn.click(function() {}); //给按钮绑定事件</p>
<p>click是一个方法，内部是对onclick事件的封装</p>
<h3 id="事件的发展历程（了解）"><a href="#事件的发展历程（了解）" class="headerlink" title="事件的发展历程（了解）"></a>事件的发展历程（了解）</h3><p>简单事件绑定 >> bind事件绑定 >> delegate事件绑定 >> on</p>
<p><strong>简单事件绑定：</strong></p>
<p>click(handler) 单击事件</p>
<p>dbclick(handler) 双击事件</p>
<p>blur(handler) 失去焦点事件</p>
<p>focus(handler) 获得焦点事件</p>
<p>mouseenter(handler) 鼠标进入事件</p>
<p>mouseleave(handler) 鼠标离开事件</p>
<p>keydown(handler) 键盘按下事件</p>
<p>keyup(handler) 键盘弹起事件</p>
<p><strong>bind方式</strong></p>
<p>作用：给匹配到的元素直接绑定事件（不推荐，1.7以后的jQuery版本被on取代）</p>
<p>// 绑定单击事件处理程序</p>
<p>第一个参数：事件类型</p>
<p>第二个参数：事件处理程序</p>
<p>\$(“p”).bind(“click mouseenter”, function(e){</p>
<p>//事件响应方法</p>
<p>});</p>
<p>优点：可以同时绑定多个事件，比如：bind(“mouseenter mouseleave”, function(){})</p>
<p>缺点：仍然无法给动态创建的元素绑定事件</p>
<p><strong>delegate方式</strong></p>
<p>作用：给匹配到的元素绑定事件，对支持动态创建的元素有效（特点：节省资源，支持动态创建的元素）（不推荐，1.7以后的jQuery版本被on取代）</p>
<p>// 第一个参数：selector，要绑定事件的元素</p>
<p>// 第二个参数：事件类型</p>
<p>// 第三个参数：事件处理函数</p>
<p>\$(“.parentBox”).delegate(“p”, “click”, function(){</p>
<p>//为 .parentBox下面的所有的p标签绑定事件</p>
<p>});</p>
<p>与前两种方式最大的优势：减少事件绑定次数提高效率，支持动态创建出来的元素绑定事件</p>
<h3 id="事件绑定（重点）"><a href="#事件绑定（重点）" class="headerlink" title="事件绑定（重点）"></a>事件绑定（重点）</h3><p>我们现在用on的方式来绑定事件（最现代的方式，强烈建议使用的方式）</p>
<p>jQuery1.7版本后，jQuery用on统一了所有的事件处理的方法</p>
<p>作用：给匹配的元素绑定事件，包括了上面所有绑定事件方式的优点</p>
<p>语法：</p>
<p>//<br>第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件）</p>
<p>// 第二个参数：selector, 执行事件的后代元素</p>
<p>// 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用</p>
<p>// 第四个参数：handler，事件处理函数</p>
<p>\$(selector).on(events[,selector][,data],handler);</p>
<p>// 表示给\$(selector)绑定事件，当必须是它的内部元素span才能执行这个事件</p>
<p>\$(selector).on( “click”,“span”, function() {});</p>
<p>// 绑定多个事件</p>
<p>// 表示给\$(selector)匹配的元素绑定单击和鼠标进入事件</p>
<p>\$(selector).on(“click mouseenter”, function(){});</p>
<h3 id="事件解绑"><a href="#事件解绑" class="headerlink" title="事件解绑"></a>事件解绑</h3><p><strong>unbind() 方式（废弃）</strong></p>
<p>作用：解绑 bind方式绑定的事件</p>
<p>\$(selector).unbind(); //解绑所有的事件</p>
<p>\$(selector).unbind(“click”); //解绑指定的事件</p>
<p><strong>undelegate() 方式（废弃）</strong></p>
<p>作用：解绑delegate方式绑定的事件</p>
<p>\$( selector ).undelegate(); //解绑所有的delegate事件</p>
<p>\$( selector).undelegate( “click” ); //解绑所有的click事件</p>
<p><strong>off解绑on方式绑定的事件（重点）</strong></p>
<p>//解绑 所有类型 所有事件（直接绑定的和委托的都解绑）</p>
<p>\$(selector).off();</p>
<p>//解绑 click事件 所有事件（直接绑定的和委托的都解绑）</p>
<p>\$(selector).off(“click”);</p>
<p>//解绑 click事件 只解绑委托的</p>
<p>\$(selector).off( “click”, “**” );</p>
<p>//第二个参数表示的是要找委托的 选择器“**”表示选择所有委托的</p>
<h3 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h3><p>简单事件触发</p>
<p>\$(selector).click(); //触发 click事件</p>
<p>trigger方法触发事件</p>
<p>\$(selector).trigger(“click”);</p>
<p>triggerHandler触发 事件响应方法，<strong>不触发浏览器行为</strong></p>
<p><strong>比如:文本框获得焦点的默认行为</strong></p>
<p>\$(selector).triggerHandler(“focus”);</p>
<h3 id="jQuery事件对象介绍"><a href="#jQuery事件对象介绍" class="headerlink" title="jQuery事件对象介绍"></a>jQuery事件对象介绍</h3><p>event.type 事件类型：click，dbclick…</p>
<p>event.which 鼠标的按键类型：左1 中2 右3</p>
<p><strong>event.pageX  鼠标相对于页面左边的位置</strong></p>
<p>event.target  触发该事件的元素（事件目标）</p>
<p>event.currentTarget 当前对象（相当于this）</p>
<p>event.delegateTarget 代理对象</p>
<p><strong>event.keyCode 键盘按键代码</strong></p>
<p>event.stopPropagation()； 阻止事件冒泡</p>
<p>event.preventDefault();  阻止默认行为</p>
<p>return false;</p>
<p>event.data 传递给事件处理程序的额外数据</p>
<p>return false; // JQ的事件中return false可以阻止冒泡和默认行为 JS中只阻止默认行为</p>
<p>this：事件处理函数被哪个元素对象调用，this就指向哪个元素对象。</p>
<h2 id="jQuery补充（了解）"><a href="#jQuery补充（了解）" class="headerlink" title="jQuery补充（了解）"></a>jQuery补充（了解）</h2><h3 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h3><p>// 链式编程代码示例</p>
<p>\$(“li”).parent(“ul”).parent().siblings(“div”).children(“div”).html(“内容”);</p>
<p>链式编程原理：return this;</p>
<p>通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回<br>this</p>
<p>end(); // 结束当前链最近的一次过滤操作，并且返回匹配元素之前的一次状态。</p>
<h3 id="隐式迭代"><a href="#隐式迭代" class="headerlink" title="隐式迭代"></a>隐式迭代</h3><p>隐式迭代：在方法的内部会对匹配到的所有元素进行循环遍历，执行相应的方法；无需我们再手动地进行循，方便我们使用。</p>
<p>// 设置操作</p>
<p>\$(“div”).css(“color”, “red”);</p>
<p>如果是获取多个元素的值，大部分情况下返回第一个元素的值。</p>
<p>// 获取操作</p>
<p>\$(“div”).css(“color”); // 返回第一个元素的值</p>
<h3 id="each方法"><a href="#each方法" class="headerlink" title="each方法"></a>each方法</h3><p>大部分情况下是不需要使用each方法的，因为jQuery的隐式迭代特性。但是如果要对每个元素做不同的处理，这时候就要用each方法了。</p>
<p>作用：遍历jQuery对象集合，为每个匹配的元素执行一次指定函数</p>
<p>// 参数一表示当前元素在所有匹配元素中的索引号</p>
<p>// 参数二表示当前元素（DOM对象）</p>
<p>\$(selector).each(function(index,element){});</p>
<h3 id="多库共存"><a href="#多库共存" class="headerlink" title="多库共存"></a>多库共存</h3><p>此处多库共存指的是：jQuery占用了\$<br>和jQuery这两个变量名。当在一个页面中引用了jQuery，并且引用的其他库（或者其他版本的jQuery库）中也用到了\$或者jQuery这两个变量名，这时就有了多库共存的问题。</p>
<p>// 模拟另外的库使用了 \$ 这个变量名。此时，就与jQuery库产生了冲突</p>
<p>var \$ = { name : “itecast” };</p>
<p>解决方式：</p>
<p>//让jQuery释放对\$的控制权，让其他库能够使用\$。此后，只能用jQuery来调用jQuery提供的方法</p>
<p>\$.noConflict();</p>
<h2 id="jQuery插件（了解）"><a href="#jQuery插件（了解）" class="headerlink" title="jQuery插件（了解）"></a>jQuery插件（了解）</h2><p>jQuery虽然功能强大，但也不是包含所有的功能，可以通过插件来扩展它的功能：</p>
<p>当你需要某个插件的时候，你可以“安装”到jQuery上面，然后使用。</p>
<p>当你不再需要这个插件，那你就可以从jQuery上“卸载”它。</p>
<p>（联想：手机软件，安装的app就好比插件，用的时候安装上，不用的时候卸载掉）</p>
<h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>jQuery.color.js</p>
<p>animate()自定义动画：不支持背景的动画效果<a href="http://www.w3school.com.cn/jquery/effect_animate.asp" target="_blank" rel="external">animate动画支持的属性列表</a></p>
<p>使用步骤：</p>
<p>1.引入jQuery文件</p>
<p>2.引入插件</p>
<p>3.使用插件</p>
<h3 id="制作插件"><a href="#制作插件" class="headerlink" title="制作插件"></a>制作插件</h3><p>如何创建jQuery插件：<a href="http://learn.jquery.com/plugins/basic-plugin-creation/" target="_blank" rel="external">http://learn.jquery.com/plugins/basic-plugin-creation/</a></p>
<p>为\$函数扩展方法</p>
<p>\$.pluginName = function() {};</p>
<p>为jQuery对象扩展方法</p>
<p>\$.fn. pluginName = function() {};</p>
<h3 id="jQueryUI"><a href="#jQueryUI" class="headerlink" title="jQueryUI"></a>jQueryUI</h3><p>使用场景：网站的管理后台</p>
<p>jQueryUI专指由jQuery官方维护的UI（用户接口）方向的插件。</p>
<p>官方API：<a href="http://api.jqueryui.com/category/all/" target="_blank" rel="external">http://api.jqueryui.com/category/all/</a></p>
<p>其他教程：<a href="http://www.runoob.com/jqueryui/jqueryui-intro.html" target="_blank" rel="external">jQueryUI教程</a></p>
<p>基本使用:</p>
<p>1.引入jQueryUI的样式文件</p>
<p>2.引入jQuery</p>
<p>3.引入jQueryUI的JS文件</p>
<p>4.使用jQueryUI功能</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;动画函数&quot;&gt;&lt;a href=&quot;#动画函数&quot; class=&quot;headerlink&quot; title=&quot;动画函数&quot;&gt;&lt;/a&gt;动画函数&lt;/h2&gt;&lt;p&gt;jQuery提供的一组常见的动画效果，这些动画是标准的、有规律的效果；同时还提供给我们了自定义动画的功能。&lt;/p&gt;
&lt;h3 id=&quot;隐藏显示动画&quot;&gt;&lt;a href=&quot;#隐藏显示动画&quot; class=&quot;headerlink&quot; title=&quot;隐藏显示动画&quot;&gt;&lt;/a&gt;隐藏显示动画&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;show()方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;形式一：&lt;/p&gt;
&lt;p&gt;// 不带参数，没有动画&lt;/p&gt;
&lt;p&gt;\$(selector).show();//作用等同于css(“display”, ”block”)&lt;/p&gt;
    
    </summary>
    
      <category term="前端基础" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>浅谈jQuery</title>
    <link href="http://yoursite.com/2016/03/14/%E6%B5%85%E8%B0%88jQuery/"/>
    <id>http://yoursite.com/2016/03/14/浅谈jQuery/</id>
    <published>2016-03-14T04:03:42.000Z</published>
    <updated>2017-02-23T11:19:31.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为何要学jQuery"><a href="#为何要学jQuery" class="headerlink" title="为何要学jQuery"></a>为何要学jQuery</h2><h3 id="JS的缺点"><a href="#JS的缺点" class="headerlink" title="JS的缺点"></a>JS的缺点</h3><p><img src="media/4a787a9d22366f220c521682190a4bc6.png" alt=""></p>
<p>使用jQuery可以方便地解决这些问题</p>
<h3 id="jQuery是什么"><a href="#jQuery是什么" class="headerlink" title="jQuery是什么"></a>jQuery是什么</h3><p>animate.js是我们自己封装的库，而jQuery是别人帮我们封装好的库。</p>
<p>JS库就是把常用的代码放到一个单独的文件中，用的时候直接引用到页面里面就可以了。</p>
<p>jQuery是JS的一个库，封装了开发过程中常用的功能，能够提高开发效率。</p>
<a id="more"></a>
<h3 id="jQuery学什么"><a href="#jQuery学什么" class="headerlink" title="jQuery学什么"></a>jQuery学什么</h3><p>本阶段主要学习如何使用jQuery，其实就是学习jQuery封装好的一些功能方法，这些方法叫做API（Application<br>Programming Interface应用程序编程接口）。</p>
<p>这些API的共同特点是：几乎全都是方法。</p>
<p>所以，在使用时，都是方法调用，要加小括号()，小括号里面是相应的参数，参数不同，功能不同。</p>
<h3 id="使用jQuery"><a href="#使用jQuery" class="headerlink" title="使用jQuery"></a>使用jQuery</h3><p>使用步骤：</p>
<p>1引包 2写入口函数 3实现功能（事件处理）</p>
<p>入口函数就是指程序运行的时候最开始调用的函数，也就是程序开始的地方</p>
<h2 id="开始使用jQuery"><a href="#开始使用jQuery" class="headerlink" title="开始使用jQuery"></a>开始使用jQuery</h2><h3 id="版本介绍"><a href="#版本介绍" class="headerlink" title="版本介绍"></a>版本介绍</h3><p>最常用的两个版本：</p>
<p>1.12.x和最新推出的3.0.0</p>
<p>两个版本的区别：3.0版本，不支持IE6、7、8 <strong>PC端的开发主要使用1.12.x版本</strong></p>
<p>这几天主要学习1.12.x版本：</p>
<p><img src="media/698bd6222703e7f491608e63836ede50.png" alt=""></p>
<p>未压缩版（开发版）：代码可读性高，推荐在<strong>开发和学习环境</strong>中使用，方便查看源代码。</p>
<p>压缩版：去除了注释、换行、空格、并且将一些变量替换成了a,b,c之类的简单字符，基本没有可读性，推荐在<strong>生产和测试环境</strong>中使用，因为文件较小，减少网络压力。</p>
<h3 id="引包注意"><a href="#引包注意" class="headerlink" title="引包注意"></a>引包注意</h3><p>第一点：在使用jQuery之前，先把jQuery文件引到页面中来，如果在使用jQuery之前，没有引用jQuery文件，会报错：</p>
<p>第二点：src路径一定要写正确 如果src路径写错，也会报错：</p>
<h3 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h3><p><strong>jQuery的入口函数:</strong></p>
<p>第一种：</p>
<p>\$(document).ready(function(){ //内容 });</p>
<p>第二种：</p>
<p>\$(function(){ //内容 });</p>
<p>以上两种写法，作用完全相同，用哪个都可以</p>
<p><strong>JS的入口函数：</strong></p>
<p>window.onload = function() { //内容 };</p>
<p><strong>jQuery入口函数与JS入口函数的区别</strong></p>
<p>区别一：书写个数不同</p>
<p>JS入口函数只能出现一次，出现多次会存在事件覆盖的问题。</p>
<p>jQuery的入口函数，可以出现任意多次，不会覆盖。</p>
<p>区别二：执行时机不同</p>
<p>JS入口函数是在所有资源加载完成后，才执行。（包括：页面、外部js文件、外部css文件、图片等）</p>
<p>jQuery入口函数，是在文档加载完成后就执行。文档加载完成指的是：DOM树加载完成后，就可以操作DOM了，不用等到所有的外部资源都加载完成。</p>
<h3 id="符号"><a href="#符号" class="headerlink" title="\$ 符号"></a>\$ 符号</h3><p><strong>\$就是一个普通的字符</strong>，可以用于变量名或函数名</p>
<p>JS命名规范允许出现的字符有：数字、字母、下划线、\$</p>
<p>var \$ = “字符串”;</p>
<p>var \$ = 123;</p>
<p>function \$(){</p>
<p>alert(“我是函数\$”);</p>
<p>}</p>
<p>\$(); // 调用上面我们自定义的函数\$</p>
<p><strong>jQuery中的\$实际是一个函数</strong></p>
<p>// jQuery中使用\$的主要场景</p>
<p>\$(document）.ready(function(){}); // 调用入口函数</p>
<p>\$(function(){}); // 调用入口函数</p>
<p>\$(“#btnShow”) // 获取id属性为btnShow的元素</p>
<p>\$(“div”) // 获取所有的div元素</p>
<p>jQuery里面的\$函数，根据传入参数的不同，进行不同的调用，实现不同的功能。返回的是jQuery对象</p>
<p>jQuery这个JS库，为了避免冲突，给这个最重要的\$函数还起了另外一个名字：jQuery</p>
<p>jQuery函数跟\$函数的关系：jQuery === \$;</p>
<h2 id="jQuery对象"><a href="#jQuery对象" class="headerlink" title="jQuery对象"></a>jQuery对象</h2><h3 id="jQuery对象与DOM对象"><a href="#jQuery对象与DOM对象" class="headerlink" title="jQuery对象与DOM对象"></a>jQuery对象与DOM对象</h3><p><strong>DOM对象</strong>此处指的是：使用JS操作DOM的方法返回的对象</p>
<p>var btn = document.getElementById(“btnShow”); //普通的DOM对象</p>
<p><strong>jQuery对象</strong>此处指的是：使用jQuery操作DOM的方法返回的对象</p>
<p>var \$btn = \$(“#btnShow”); // jQuery的DOM对象</p>
<p>jQuery拿到普通的DOM对象后会对其进行包装，让其成为具有jQuery方法的jQuery对象</p>
<h3 id="jQuery对象转DOM对象"><a href="#jQuery对象转DOM对象" class="headerlink" title="jQuery对象转DOM对象"></a>jQuery对象转DOM对象</h3><p>第一种方式</p>
<p>var btn1 = \$btn[0]; //通过索引的方式把DOM对象取出来（推荐使用此方式）</p>
<p>第二种方式</p>
<p>var btn2 = \$btn.get(0);//调用get()方法也可以</p>
<p>这两种方式使用哪一种都可以</p>
<h3 id="DOM对象转jQuery对象"><a href="#DOM对象转jQuery对象" class="headerlink" title="DOM对象转jQuery对象"></a>DOM对象转jQuery对象</h3><p>\$(普通的DOM对象)</p>
<p><strong>图解：</strong></p>
<p><img src="media/fa429616801982ad68d2ad0f92265394.png" alt=""></p>
<h2 id="jQuery选择器（重点）"><a href="#jQuery选择器（重点）" class="headerlink" title="jQuery选择器（重点）"></a>jQuery选择器（重点）</h2><h3 id="JS中选择DOM元素的方法"><a href="#JS中选择DOM元素的方法" class="headerlink" title="JS中选择DOM元素的方法"></a>JS中选择DOM元素的方法</h3><p>考虑兼容性的话，JS提供的选择DOM的方法只有两个：</p>
<table>
<thead>
<tr>
<th><strong>JavaScript选择元素的方法：</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>document.getElementById();</td>
<td>通过id属性获取指定元素 返回唯一的DOM对象</td>
</tr>
<tr>
<td>document.getElementsByTagName();</td>
<td>通过标签名获取指定元素 返回DOM对象数组（即使只有一个元素）</td>
</tr>
</tbody>
</table>
<p>JS提供的选择DOM的方法太少，无法满足开发的需要，所以我们使用jQuery选择器来弥补这方面的不足</p>
<h3 id="什么是jQuery选择器"><a href="#什么是jQuery选择器" class="headerlink" title="什么是jQuery选择器"></a>什么是jQuery选择器</h3><p>jQuery选择器非常强大，它提供了一组方法，让我们更方便地获取页面中的元素。（类比：CSS的选择器）</p>
<p>强大的原因：jQuery实现了从CSS1到CSS3所有的选择器以及其他常用的选择器</p>
<p>各种选择器之间可以相互代替，所以，平时真正用到的只是最常用的选择器</p>
<h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><table>
<thead>
<tr>
<th><strong>符号(名称)</strong></th>
<th><strong>说明</strong></th>
<th><strong>用法</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>#</td>
<td>Id选择器</td>
<td>\$(“#btnShow”).css(“color”, “red”); 选择id为btnShow的一个元素（返回值为jQuery对象，下同）</td>
</tr>
<tr>
<td>.</td>
<td>类名选择器</td>
<td>\$(“.liItem”).css(“color”, “red”); 选择含有类liItem的所有元素</td>
</tr>
<tr>
<td>标签名</td>
<td>标签选择器</td>
<td>\$(“li”).css(“color”, “red”); 选择标签名为li的所有元素</td>
</tr>
<tr>
<td>用逗号隔开</td>
<td>并集选择器</td>
<td>\$(“div,p,li”).css(“color”, “red”); div、p、li都会被选中</td>
</tr>
<tr>
<td>挨在一起</td>
<td>交集选择器</td>
<td>\$(“li.current”).css(“color”, “red”); 选择标签名为li并且类名为current的元素</td>
</tr>
</tbody>
</table>
<p><strong>\@基本选择器</strong></p>
<p>//id选择器 类名选择器 标签选择器 交集选择器 并集选择器</p>
<h3 id="层级选择器、过滤选择器"><a href="#层级选择器、过滤选择器" class="headerlink" title="层级选择器、过滤选择器"></a>层级选择器、过滤选择器</h3><table>
<thead>
<tr>
<th><strong>符号(名称)</strong></th>
<th><strong>说明</strong></th>
<th><strong>用法</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>层级选择器</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>空格</td>
<td>后代选择器</td>
<td>\$(“#j_wrap li”).css(“color”, “red”); 选择id为j_wrap的元素的所有后代元素li</td>
</tr>
<tr>
<td>></td>
<td>子代选择器</td>
<td>\$(“#j_wrap > ul > li”).css(“color”, “red”); 选择id为j_wrap的元素的所有子元素ul的所有子元素li</td>
</tr>
<tr>
<td><strong>常用的过滤选择器</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>:eq(index)</td>
<td>选择匹配元素中索引号为index的一个元素，index从0开始</td>
<td>\$(“li:eq(2)”).css(“color”, ”red”); 选择li元素中索引号为2的一个元素</td>
</tr>
<tr>
<td>:odd</td>
<td>选择匹配元素中索引号为奇数的所有元素，index从0开始</td>
<td>\$(“li:odd”).css(“color”, “red”); 选择li元素中索引号为奇数的所有元素</td>
</tr>
<tr>
<td>:even</td>
<td>选择匹配元素中索引号为偶数的所有元素，index从0开始</td>
<td>\$(“li:odd”).css(“color”, “red”); 选择li元素中索引号为偶数的所有元素</td>
</tr>
</tbody>
</table>
<h3 id="筛选选择器（注：都是方法）"><a href="#筛选选择器（注：都是方法）" class="headerlink" title="筛选选择器（注：都是方法）"></a>筛选选择器（注：都是方法）</h3><table>
<thead>
<tr>
<th><strong>符号(名称)</strong></th>
<th><strong>说明</strong></th>
<th><strong>用法</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>find(selector)</td>
<td>查找指定元素的所有后代元素（子子孙孙）</td>
<td>\$(“#j_wrap”).find(“li”).css(“color”, “red”); 选择id为j_wrap的所有后代元素li</td>
</tr>
<tr>
<td>children(selector)</td>
<td>查找指定元素的直接子元素（亲儿子元素）</td>
<td>\$(“#j_wrap”).children(“ul”).css(“color”, “red”); 选择id为j_wrap的所有子代元素ul</td>
</tr>
<tr>
<td>siblings(selector)</td>
<td>查找所有其他的兄弟元素（不包括自己）</td>
<td>\$(“#j_liItem”).siblings().css(“color”, “red”); 选择id为j_liItem的所有兄弟元素</td>
</tr>
<tr>
<td>next(selector)</td>
<td>查找下一个兄弟元素</td>
<td>\$(“#j_liItem”).next().css(“color”, “red”); 选择id为j_liItem的下一个兄弟元素</td>
</tr>
<tr>
<td>parent(selector)</td>
<td>查找父元素（亲的）</td>
<td>\$(“#j_liItem”).parent(“ul”).css(“color”, “red”); 选择id为j_liItem的父元素</td>
</tr>
<tr>
<td>eq(index)</td>
<td>查找指定元素的第index个元素，index是索引号，从0开始</td>
<td>\$(“li”).eq(2).css(“color”, “red”); 选择所有li元素中的第二个</td>
</tr>
</tbody>
</table>
<p>jQuery基础课程 — DOM操作</p>
<h2 id="样式操作（重点）"><a href="#样式操作（重点）" class="headerlink" title="样式操作（重点）"></a>样式操作（重点）</h2><h3 id="获取样式"><a href="#获取样式" class="headerlink" title="获取样式"></a>获取样式</h3><p>// 参数表示要获取的 样式属性名称</p>
<p>\$(selector).css(“font-size”);</p>
<p>此时，会返回”font-size”样式属性对应的值。</p>
<h3 id="设置样式"><a href="#设置样式" class="headerlink" title="设置样式"></a>设置样式</h3><p>设置<strong>单个</strong>样式：</p>
<p>// 第一个参数表示：样式属性名称</p>
<p>// 第二个参数表示：样式属性值</p>
<p>\$(selector).css(“color”, “red”);</p>
<p>设置<strong>多个</strong>样式：</p>
<p>// 参数为对象</p>
<p>\$(selector).css({“color”: “red”,“font-size”:“30px”});</p>
<h2 id="类名操作（重点）"><a href="#类名操作（重点）" class="headerlink" title="类名操作（重点）"></a>类名操作（重点）</h2><h3 id="添加类名"><a href="#添加类名" class="headerlink" title="添加类名"></a>添加类名</h3><p>addClass(className) 为指定元素添加类名</p>
<p>\$(selector).addClass(“liItem”);</p>
<p>注意：已经说了是添加类名了，把名字传入即可，不要加点！</p>
<h3 id="移除类名"><a href="#移除类名" class="headerlink" title="移除类名"></a>移除类名</h3><p>removeClass(className) 为指定元素移除类名</p>
<p>\$(selector).removeClass(“liItem”); //移除指定类名</p>
<p>\$(selector).removeClass(); //不指定参数，表示移除所有类名</p>
<h3 id="判断有没有某个类名"><a href="#判断有没有某个类名" class="headerlink" title="判断有没有某个类名"></a>判断有没有某个类名</h3><p>hasClass(calssName) 判断指定元素是否包含某个类名</p>
<p>\$(selector).hasClass(“liItem”);//返回true或false</p>
<h3 id="切换类名"><a href="#切换类名" class="headerlink" title="切换类名"></a>切换类名</h3><p>toggleClass(className) 切换类名，如果没有指定类名就添加，有就移除。</p>
<p>\$(selector).toggleClass(“liItem”);</p>
<h3 id="Data属性"><a href="#Data属性" class="headerlink" title="Data属性"></a>Data属性</h3><p>在元素上存放数据,返回jQuery对象。</p>
<p>data(obj) 可传入key-value形式的数据。</p>
<p><strong>key</strong>:存储的数据名</p>
<p><strong>value</strong>:将要存储的任意数据</p>
<ul>
<li><p>一个参数是获取</p>
</li>
<li><p>两个参数是设置</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为何要学jQuery&quot;&gt;&lt;a href=&quot;#为何要学jQuery&quot; class=&quot;headerlink&quot; title=&quot;为何要学jQuery&quot;&gt;&lt;/a&gt;为何要学jQuery&lt;/h2&gt;&lt;h3 id=&quot;JS的缺点&quot;&gt;&lt;a href=&quot;#JS的缺点&quot; class=&quot;headerlink&quot; title=&quot;JS的缺点&quot;&gt;&lt;/a&gt;JS的缺点&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;media/4a787a9d22366f220c521682190a4bc6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用jQuery可以方便地解决这些问题&lt;/p&gt;
&lt;h3 id=&quot;jQuery是什么&quot;&gt;&lt;a href=&quot;#jQuery是什么&quot; class=&quot;headerlink&quot; title=&quot;jQuery是什么&quot;&gt;&lt;/a&gt;jQuery是什么&lt;/h3&gt;&lt;p&gt;animate.js是我们自己封装的库，而jQuery是别人帮我们封装好的库。&lt;/p&gt;
&lt;p&gt;JS库就是把常用的代码放到一个单独的文件中，用的时候直接引用到页面里面就可以了。&lt;/p&gt;
&lt;p&gt;jQuery是JS的一个库，封装了开发过程中常用的功能，能够提高开发效率。&lt;/p&gt;
    
    </summary>
    
      <category term="前端基础" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础三</title>
    <link href="http://yoursite.com/2015/11/21/JavaScript%E5%9F%BA%E7%A1%80%E4%B8%89/"/>
    <id>http://yoursite.com/2015/11/21/JavaScript基础三/</id>
    <published>2015-11-21T04:27:22.000Z</published>
    <updated>2017-02-22T14:26:18.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h1><p><strong>事件：</strong></p>
<p>onclick onmouseover onmouseout onfocus onblure</p>
<h3 id="事件对象简介"><a href="#事件对象简介" class="headerlink" title="事件对象简介"></a>事件对象简介</h3><p><strong>\@事件对象简介</strong></p>
<p>在触发事件时，会产生一个<strong>事件对象event</strong>，这个对象中包含着<strong>与事件有关的信息</strong>。</p>
<p>所有浏览器都支持event对象，但支持的<strong>方式不同</strong>。</p>
<a id="more"></a>
<p>比如鼠标操作时候，会添加鼠标位置的相关信息到事件对象中。</p>
<p>普通浏览器支持 传入参数</p>
<p>ie 678 支持 window.event</p>
<p><strong>\@事件对象的兼容性写法</strong></p>
<p>var event = event || <strong>window</strong>.<strong>event</strong>;</p>
<p><img src="media/1f659b5c82eebd3fee8781f880fc1f74.png" alt=""></p>
<h3 id="三个重要座标"><a href="#三个重要座标" class="headerlink" title="三个重要座标"></a>三个重要座标</h3><p><strong>\@三个重要座标</strong></p>
<p><strong>clientX clientY</strong></p>
<p>当前窗口的左上角为基准点</p>
<p><img src="media/b78ef9c7d0f6333875863e1bbdc946fc.png" alt=""></p>
<p><strong>pageX pageY</strong></p>
<p>以当前文档的左上角为基准点</p>
<p><img src="media/edd047763f6dc61b0262dbf5be17f2a7.png" alt=""></p>
<p>IE678不支持pageX和pageY 但是我们可以采取另一种方式</p>
<p>var pageY = event.<strong>pageY</strong> || event.<strong>clientY</strong> +<br><strong>document</strong>.<strong>documentElement</strong>.<strong>scrollTop</strong>;</p>
<p>var pageX = event.<strong>pageX</strong> || event.<strong>clientX</strong> +<br><strong>document</strong>.<strong>documentElement</strong>.<strong>scrollLeft</strong>;</p>
<p><strong>screenX screenY</strong></p>
<p>当前屏幕的左上角为基准点</p>
<p><img src="media/0b98b4c16c83add1952a01ae60443f72.png" alt=""></p>
<h2 id="放大镜特效"><a href="#放大镜特效" class="headerlink" title="放大镜特效"></a>放大镜特效</h2><p><strong>\@计算鼠标在盒子中的位置</strong></p>
<p><img src="media/cc64dfba516151331e0db1bf090afb29.png" alt=""></p>
<p>制作方法：</p>
<p><strong>鼠标经过显示盒子</strong></p>
<p>鼠标经过small，让mask和big显示；鼠标离开small，让mask和big隐藏。</p>
<p><strong>鼠标经过遮罩跟随</strong></p>
<p>给small绑定鼠标移动事件</p>
<p>获取鼠标在small 内的坐标</p>
<p>计算鼠标在盒子中的座标（鼠标pageX-box到页面左侧的距离；鼠标pageY-box到页面顶部的距离）</p>
<p>然后赋值给mask的top和left（位置是按照左上角算的，所以top值要减去高度的一半，left值要减去宽度的一半）</p>
<p><strong>限定遮罩运动范围</strong></p>
<p>x 最小为0；最大为200，这个200是 small的宽度 -<br>mask的宽度（mask可以向右移动的最大值）</p>
<p><img src="media/8c62cd0a133155423796210705803957.png" alt=""></p>
<p><strong>按比例显示大图片</strong></p>
<p><img src="media/6d4aa8984b894fa121a697dd9e5474ad.png" alt=""></p>
<p>小盒子移动，大盒子要根据比例来移动，比例为：</p>
<p>大图 在 大盒子 里移动的距离 / 小黄 在 小图 里移动的距离</p>
<p>（大图片 - 大盒子 ） / （小盒子 - 小遮罩 ）</p>
<p>800 - 400 / 350 - 175</p>
<p>因为是反方向移动 计算时记得加负号呦！</p>
<h2 id="可拖拽特效"><a href="#可拖拽特效" class="headerlink" title="可拖拽特效"></a>可拖拽特效</h2><p>常用事件：</p>
<p>onmouseover 鼠标经过</p>
<p>onmouseout 鼠标离开</p>
<p>onmousedown 鼠标按下</p>
<p>onmouseup 鼠标弹起</p>
<p>onmousemove 鼠标移动</p>
<p><strong>\@可拖拽特效</strong></p>
<p>在拖动区域按下鼠标后，在文档中移动鼠标，盒子跟着鼠标坐标走。</p>
<p>鼠标在文档中弹起后，将事件清空。</p>
<p>盒子的位置要进行调整，当鼠标按下时，记录鼠标在盒子中的位置，鼠标移动计算盒子位置的时候减去。</p>
<p><img src="media/993fa9c8df7499f4386b78b5c10c6895.png" alt=""></p>
<p><strong>清除选中的内容</strong></p>
<p>window.getSelection ? window.getSelection().removeAllRanges() :<br>document.selection.empty();</p>
<p>正常浏览器支持：window.getSelection()</p>
<p>IE678以下支持：document.selection 　　</p>
<h2 id="注册事件的三种方式"><a href="#注册事件的三种方式" class="headerlink" title="注册事件的三种方式"></a>注册事件的三种方式</h2><p>element.addEventListener(“事件类型”,”事件处理函数”,”是否使用捕获”)</p>
<p>addEventListener的好处是不会将其他事件覆盖，但是有兼容性问题</p>
<p>removeEventListener可以移除指定事件</p>
<p>addEventListener便于管理事件队列 但一般用on的就可以了比较简单</p>
<h2 id="事件的三个阶段"><a href="#事件的三个阶段" class="headerlink" title="事件的三个阶段"></a>事件的三个阶段</h2><p>1捕获阶段</p>
<p>2目标阶段 执行当前对象的事件处理程序</p>
<p>3冒泡阶段</p>
<p><img src="media/e27914a9104ff4022607de1089e73b44.png" alt=""></p>
<h2 id="鼠标事件和键盘事件"><a href="#鼠标事件和键盘事件" class="headerlink" title="鼠标事件和键盘事件"></a>鼠标事件和键盘事件</h2><p><strong>常用鼠标事件：</strong></p>
<p>mousedown、mouseup、mousemove、mouseover、mouseout、click、dblclick</p>
<p>onmousedown鼠标按下 onmouseup鼠标弹起 onmouseclick=onmousedown+onmouseup</p>
<p><strong>常用键盘事件：</strong></p>
<p><strong>keydown</strong>、keypress、<strong>keyup</strong></p>
<p>onkeydown键盘按下 onkeyup键盘弹起 onkeypress=onkeydown+onkeyup</p>
<p>onkeydown onkeyup 输出的是<strong>键盘码</strong> onkeypress输出的是<strong>ASCII码表</strong></p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式在网络上有很多资料和工具，用的时候直接在网上搜即可</p>
<h3 id="声明和使用"><a href="#声明和使用" class="headerlink" title="声明和使用"></a>声明和使用</h3><p><strong>\@正则的声明和使用</strong></p>
<p>通过<strong>构造函数</strong>定义</p>
<p>var 变量名= new RegExp(/表达式/);</p>
<p>通过<strong>直接量</strong>定义（简单方便，我们一般用这个）</p>
<p>var 变量名= /表达式/;</p>
<p>常用方法，可用于检测传入的字符串是否符合该规则并返回布尔值</p>
<p>exp.test(“要检测的字符串”)</p>
<h3 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h3><p><strong>\@预定义类和转义符</strong></p>
<p>. [\^\n\r] 除了换行和回车之外的任意字符</p>
<p>\d [0-9] 数字字符digit</p>
<p>\D [\^0-9] 非数字字符</p>
<p>\w [a-zA-Z0-9_] 单词字符(所有的字母数字和_) word</p>
<p>\W [\^a-zA-Z0-9_] 非单词字符</p>
<p>\s [\f\r\n\t\v] 不可见字符 space</p>
<p>\S [\^\f\r\n\t\v] 可见字符</p>
<p><strong>转义符</strong></p>
<p>\f 表示换页 form feed</p>
<p>\t 表示水平制表符 table</p>
<p>\v 表示垂直制表符 vertical table</p>
<p><img src="media/4f92cc6364a631ea154406d261f28246.png" alt=""></p>
<p>\r,\n,\r\n的区别</p>
<p>在万恶的旧社会，打字机换行（\n<br>newline）之后只会下移一行，需要回到一行的开头（\r return）才能继续打字</p>
<p>老式的操作系统也继承了打字机的这一特性，但用户换行之后一般都是要回到开头的，因此新式的操作系统为了方便将键盘上的Enter键的含义修改为\r\n或者直接将\n的含义改为“移动到下一行的开头”。</p>
<p>说到转义字符你有没有想起HTML的转义字符呢？（<strong>字符实体</strong>）</p>
<p><strong>\@基本语法补充</strong></p>
<p>| 表示或 或的优先级最低 可以通过()提升优先级</p>
<h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><p><strong>\@字符类</strong></p>
<p>简单类[abc] 表示该位置可以出现的字符</p>
<p>负向类[\^abc] 表示该位置不可以出现的字符</p>
<p>范围类[a-e] 表示该位置可以出现的字符的范围</p>
<p>组合类[a-xA-E0-9] 范围类的组合</p>
<p><strong>\@验证密码强度</strong></p>
<h3 id="边界-量词-括号"><a href="#边界-量词-括号" class="headerlink" title="边界 量词 括号"></a>边界 量词 括号</h3><p><strong>\@边界</strong></p>
<p>\^ 会匹配行或者字符串的起始位置</p>
<p>\^只有在[]内才表示非 在外边表示开始</p>
<p>\$ 会匹配行或字符串的结尾位置</p>
<p>\^\$在一起 表示必须是这个（精确匹配）</p>
<p><strong>\@量词</strong></p>
<p>“*“ 重复零次或更多 x>=0</p>
<p>“+” 重复一次或更多次 x>=1</p>
<p>“?” 重复零次或一次 x=(0||1)</p>
<p>{n} n次 x=n</p>
<p>{n,} 重复n次或更多 x>=n</p>
<p>{n,m} 重复出现的次数比n多但比m少 n\&lt;=x\&lt;=m</p>
<p><strong>\@括号总结</strong></p>
<p>()表示一组</p>
<p>[]表示一个字符的位置</p>
<p>{}表示次数</p>
<p><strong>\@验证座机\@验证姓名\@完整版表单验证</strong></p>
<h3 id="常见项目的匹配"><a href="#常见项目的匹配" class="headerlink" title="常见项目的匹配"></a>常见项目的匹配</h3><p>常见项目的匹配<strong>网上有很多</strong>（例如搜索常用正则表达式大全），无需记忆，能看懂即可</p>
<p>匹配国内电话号码：</p>
<p>/\^0\d{2,3}-\d{7,8}\$/</p>
<p>匹配姓名：</p>
<p>/\^[\u4e00-\u9fa5]{2,}\$/</p>
<p>匹配腾讯QQ号：</p>
<p>/\^[1-9]\d{4,10}\$/</p>
<p>匹配手机号：</p>
<p>/\^(13[0-9]|14[57]|15[0-9]|18[0-9])\d{8}\$/</p>
<p>匹配邮箱：</p>
<p>/\^\w+([+-.]\w+)*\@\w+([-.]\w+)*\.\w+([-.]\w+)*\$/</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;事件对象&quot;&gt;&lt;a href=&quot;#事件对象&quot; class=&quot;headerlink&quot; title=&quot;事件对象&quot;&gt;&lt;/a&gt;事件对象&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;事件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;onclick onmouseover onmouseout onfocus onblure&lt;/p&gt;
&lt;h3 id=&quot;事件对象简介&quot;&gt;&lt;a href=&quot;#事件对象简介&quot; class=&quot;headerlink&quot; title=&quot;事件对象简介&quot;&gt;&lt;/a&gt;事件对象简介&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;\@事件对象简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在触发事件时，会产生一个&lt;strong&gt;事件对象event&lt;/strong&gt;，这个对象中包含着&lt;strong&gt;与事件有关的信息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所有浏览器都支持event对象，但支持的&lt;strong&gt;方式不同&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="前端基础" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础二</title>
    <link href="http://yoursite.com/2015/10/22/JavaScript%E5%9F%BA%E7%A1%80%E4%BA%8C/"/>
    <id>http://yoursite.com/2015/10/22/JavaScript基础二/</id>
    <published>2015-10-22T08:26:55.000Z</published>
    <updated>2017-02-22T14:26:01.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h1><h2 id="增-删-改-查-下面有详细介绍"><a href="#增-删-改-查-下面有详细介绍" class="headerlink" title="增 删 改 查 (下面有详细介绍)"></a>增 删 改 查 (下面有详细介绍)</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>//document.createElement</p>
<p>//innerHTML</p>
<p>//cloneNode</p>
<p>//appendChild</p>
<p>//insertBefore</p>
<a id="more"></a>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>//innerHTML</p>
<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p>//innerText</p>
<p>//setAttibute</p>
<p>//style</p>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>//document.getElementById</p>
<p>//document.getElementsByTagName</p>
<p>//document.getElemnetsByClassName</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="异常的最大特征就是，会报错，后面的代码将不会继续执行"><a href="#异常的最大特征就是，会报错，后面的代码将不会继续执行" class="headerlink" title="异常的最大特征就是，会报错，后面的代码将不会继续执行"></a>异常的最大特征就是，会报错，后面的代码将不会继续执行</h3><ul>
<li><p>语法异常 语法错误导致的异常</p>
</li>
<li><p>浏览器差异导致的异常</p>
</li>
<li><p>运行时异常</p>
</li>
</ul>
<h3 id="异常处理语句"><a href="#异常处理语句" class="headerlink" title="异常处理语句"></a>异常处理语句</h3><p>try{</p>
<p>//可能会出错的代码</p>
<p>//1.打开了资源</p>
<p>//2.操作资源</p>
<p>}catch (e){</p>
<p>//e 就是异常信息</p>
<p>//出现异常后的处理代码</p>
<p>}finally{</p>
<p>//不管怎么样，有没有异常出现，都会执行的代码</p>
<p>//3.释放资源</p>
<p>}</p>
<h3 id="手动抛出异常"><a href="#手动抛出异常" class="headerlink" title="手动抛出异常"></a>手动抛出异常</h3><p>//语法： throw anything</p>
<p>//catch(e) 这里的e 就会是你throw的这个东西</p>
<p>try{</p>
<p>throw {</p>
<p>errMsg:”您的代码出错了！”,</p>
<p>errCode:-1</p>
<p>};</p>
<p>}catch (e){</p>
<p>console.log(e);</p>
<p>}</p>
<h2 id="DOM基本概念"><a href="#DOM基本概念" class="headerlink" title="DOM基本概念"></a>DOM基本概念</h2><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>DOM Document Object Model 文档对象模型</p>
<p>就是把HTML文档模型化，当作对象来处理</p>
<p>DOM提供的一系列属性和方法可以视作一个工具箱，极大地方便了我们对文档的处理。</p>
<h3 id="内容概念"><a href="#内容概念" class="headerlink" title="内容概念"></a>内容概念</h3><p><strong>文档</strong>(Document)：就是指HTML或者XML文件</p>
<p><strong>节点</strong>(Node)：HTML文档中的所有内容都可以称之为节点，常见的节点有</p>
<p><strong>元素节点</strong> 属性节点 文本节点 注释节点</p>
<p><strong>元素</strong>(Element)：HTML文档中的标签可以称为元素</p>
<h3 id="结构概念"><a href="#结构概念" class="headerlink" title="结构概念"></a>结构概念</h3><p>父节点 当前节点的父级</p>
<p>子节点 当前节点的子级</p>
<p>兄弟节点 和当前节点同属一个父级的节点</p>
<h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><p>getElementById</p>
<p>通过id寻找一个元素（找到的是一个元素对象）<br>该方法只能被document对象调用（同一个文档中id不能重复）</p>
<p>getElement<strong>s</strong>ByTagName</p>
<p>通过标签名寻找一类元素（找到的是由元素对象组成的伪数组）</p>
<p>即可以被document调用，又可以被元素对象调用，被元素对象调用时表示在该元素对象内部执行查找</p>
<h2 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h2><p>元素对象.属性名 = “属性值”;</p>
<p>等价于</p>
<p>\&lt;标签 属性名=”属性值”></p>
<h2 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h2><p>事件三要素</p>
<p>事件源.事件 = function(){ 事件处理程序 };</p>
<p>等价于</p>
<p>\&lt;标签 事件=”事件处理程序”></p>
<p><strong>对象方法中的this永远指的是该方法所属的那个对象</strong></p>
<h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><h3 id="常用标签属性"><a href="#常用标签属性" class="headerlink" title="常用标签属性"></a>常用标签属性</h3><p>DOM对象的属性和HTML的标签属性几乎是一致的，常用的有<strong>src、title、className、href和style</strong></p>
<p>其中className对应就是标签的class属性，但是由于class在JS中是关键字，所以变成了className</p>
<h3 id="内部文本属性"><a href="#内部文本属性" class="headerlink" title="内部文本属性"></a>内部文本属性</h3><p><strong>innerHTML</strong></p>
<p>获取和设置标签中的内容，设置的内容会当作节点对象被解析到DOM树上</p>
<p><strong>innerText</strong></p>
<p>获取和设置标签中的内容，设置的内容会被当作普通文本（有兼容性问题，旧版ff不支持）</p>
<p><strong>textContent</strong></p>
<p>获取和设置标签中的内容，设置的内容会被当作普通文本（有兼容性问题，旧版IE不支持）</p>
<p><strong>可以通过能力检测封装一个自己的设置内部文本的方法并放到自己的JS工具包中</strong></p>
<h3 id="常用表单属性"><a href="#常用表单属性" class="headerlink" title="常用表单属性"></a>常用表单属性</h3><p>常见的表单元素属性有： type、value、checked、selected、disabled</p>
<p>type可以设置input元素的类型</p>
<p>value可以设置input元素的值</p>
<p>checked可以设置input元素是否选中</p>
<p>selected 可以设置下拉列表select中的option是否被选中</p>
<p>disabled 可以设置input元素是否被禁用</p>
<p><strong>文本框获取焦点和失去焦点</strong></p>
<p><strong>获取焦点</strong>事件是onfocus <strong>失去焦点</strong>事件是onblur (不是所有的标签都有这个事件)<br>更多详细内容可以查阅w3School</p>
<h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p><strong>对象的自定义属性</strong></p>
<p>可以像给对象设置属性一样，给元素对象设置属性</p>
<p><strong>标签的自定义属性</strong></p>
<p>可以通过<strong>getAttribute()</strong>和<strong>setAttribute()</strong>设置和获取<strong>标签属性</strong>，通过<strong>removeAttribute()</strong>移除标签的属性</p>
<p>正常浏览器中 HTML中有规定的属性 两种方式才可以相互设置和获取</p>
<p>总之用setAttribute设置的就用getAttribute获取<br>用对象的自定义属性设置的就用对象的自定义属性获取 以免出问题</p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><p>node.nodeType</p>
<p>1表示元素节点 2表示属性节点 3表示文本节点 8注释</p>
<h3 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h3><p><strong>所有获取节点相关属性都没有兼容性问题</strong></p>
<p>childNodes //子节点</p>
<p>children //子元素 虽然不是早期DOM标准中的方法，但是所有浏览器都支持</p>
<p>nextSibling //下一个兄弟<strong>节点</strong></p>
<p>nextElementSibling //下一个兄弟<strong>元素</strong> 有兼容性问题</p>
<p>previousSibling//上一个兄弟<strong>节点</strong></p>
<p>previousElementSibling //上一个兄弟<strong>元素</strong> 有兼容性问题</p>
<p>firstChild //第一个<strong>节点</strong></p>
<p>firstElementChild //第一个子<strong>元素</strong> 有兼容性问题</p>
<p>lastChild //最后一个子<strong>节点</strong></p>
<p>lastElementChild //最后一个子<strong>元素</strong> 有兼容性问题</p>
<p>parentNode //父节点 （一定是元素节点，所以无需处理）</p>
<h2 id="样式属性"><a href="#样式属性" class="headerlink" title="样式属性"></a>样式属性</h2><p>style属性是对象，style对象的属性是字符串</p>
<p>style只能获取和设置行内样式</p>
<p>DOM对象中style的属性和标签中style内的值几乎一样</p>
<p>只是带有 -<br>的属性名较为特殊（如background-color变成了backgroundColor），因为在JS中 -<br>不能作为标识符</p>
<p><strong>设置和获取样式</strong></p>
<p>//通过对象的style属性只能设置和获取<strong>行内样式</strong></p>
<p>//获取样式的时候 如果行内没有该样式 输出空字符串</p>
<p>//设置样式的时候 赋的值是一个字符串 如果这个属性有单位 一定要节点加单位</p>
<p><strong>什么情况通过class控制样式 什么情况通过style控制样式</strong></p>
<p>不严格的说：</p>
<p>//如果样式很多 通过 直接控制类名 的方式加样式</p>
<p>//如果样式比较少 通过直接设置比较方便</p>
<p>严格来说：</p>
<p>//从标准的角度讲 即使是样式比较少的时候 设置样式也要用类名</p>
<p>//但是有一类情况 是无论如何也必须直接通过JS加的 那就是涉及到计算的时候</p>
<h2 id="动态创建元素"><a href="#动态创建元素" class="headerlink" title="动态创建元素"></a>动态创建元素</h2><h3 id="插入和移除节点"><a href="#插入和移除节点" class="headerlink" title="插入和移除节点"></a>插入和移除节点</h3><p>克隆节点</p>
<p>要克隆的节点.cloneNode(布尔值);</p>
<p>在父元素中的最后追加子元素</p>
<p>father.appendChild(要追加的节点对象);</p>
<p>在父元素中的某个子元素前面插入子元素</p>
<p>father.insertBefore(要插入的节点对象,插到这个节点对象的前面);</p>
<p>从父元素中移除子元素</p>
<p>father.removeChild(要移除的子节点对象);</p>
<p><strong>清空父元素</strong></p>
<p>father.innerHTML=””;在清空内容的时候和事件相关的函数不会被销毁，任然遗留在内存中</p>
<p>因此如果方便的话，建议使用father.removeChild(son)来清除</p>
<h3 id="动态创建结构"><a href="#动态创建结构" class="headerlink" title="动态创建结构"></a>动态创建结构</h3><p>方式一：直接在文档中书写</p>
<p>document.write(“内容”)</p>
<p>方式二：改变元素对象内部的HTML</p>
<p>innerHTML=”内容”</p>
<p>方式三：创建或克隆节点并追加</p>
<p>createElement()</p>
<p>cloneNode()</p>
<p>通过这两种方法创建出来的元素只是保存在内存中，必须放到页面上才行!</p>
<h2 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h2><h3 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h3><ul>
<li><p>charAt() //获取指定位置处字符</p>
</li>
<li><p>charCodeAt() //获取指定位置处字符的ASCII码</p>
</li>
<li><p>str[0] //ES5，IE8+支持 和charAt()等效</p>
</li>
</ul>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><ul>
<li><p>concat() //拼接字符串，和+一样</p>
</li>
<li><p>slice() //从start位置开始，截取到end位置，end取不到</p>
</li>
<li><p>substring() //从start位置开始，截取到end位置，end取不到</p>
</li>
<li><p>substr() //从start位置开始，截取length个字符</p>
</li>
<li><p>trim() //只能去除字符串前后的空白</p>
</li>
<li><p>split() //把字符串切割成字符数组</p>
</li>
</ul>
<h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><ul>
<li><p>indexOf() //返回指定内容在元字符串中的位置, 在数组中的话,返回的是索引</p>
</li>
<li><p>lastIndexOf() //从后往前找，只找第一个匹配的</p>
</li>
</ul>
<h3 id="匹配方法"><a href="#匹配方法" class="headerlink" title="匹配方法"></a>匹配方法</h3><ul>
<li><p>search()</p>
</li>
<li><p>replace()</p>
</li>
</ul>
<h3 id="大小写转换方法"><a href="#大小写转换方法" class="headerlink" title="大小写转换方法"></a>大小写转换方法</h3><ul>
<li><p>to(Locale)UpperCase() //转换大写</p>
</li>
<li><p>to(Locale)LowerCase() //转换小写</p>
</li>
</ul>
<h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><p><img src="media/8f944364eb93ea8e3e2feeca9104ca95.jpg" alt=""></p>
<h2 id="图形属性-offset系列"><a href="#图形属性-offset系列" class="headerlink" title="图形属性 offset系列"></a>图形属性 offset系列</h2><h3 id="offsetWidth和offsetHeight"><a href="#offsetWidth和offsetHeight" class="headerlink" title="offsetWidth和offsetHeight"></a>offsetWidth和offsetHeight</h3><p>用来得到对象的大小</p>
<p><strong>\@offsetHeight和style.height的区别</strong></p>
<p>demo.style.height只能获取<strong>行内样式</strong>，如果样式写到了其他地方，甚至根本就没写，便无法获取</p>
<p>style.height是<strong>字符串（而且带单位）</strong>，offsetHeight是<strong>数值</strong></p>
<p>demo.style.height可以<strong>设置</strong>行内样式，offsetHeight是只读属性</p>
<p>因此，一般用demo.offsetHeight来获取某元素的真实宽度/高度，用style.height来设置宽度/高度</p>
<p><strong>\@offsetHeight的构成</strong></p>
<p>offsetHeight = height+padding+border</p>
<p><strong>包括</strong> 自身高度 内边距 边框 <strong>不包括</strong> 外边距</p>
<p><img src="media/550ce6f09f6dcfe22b31f52c0d082b06.png" alt=""></p>
<h3 id="offsetParent"><a href="#offsetParent" class="headerlink" title="offsetParent"></a>offsetParent</h3><p><strong>\@offsetParent爸爸去哪</strong></p>
<p>返回该对象距离最近的<strong>带有定位</strong>的父级</p>
<p>如果当前元素的所有父级元素都没有定位（position为absolute或relative），offsetParent为body</p>
<p>如果当前元素的父级元素中有定位（position为absolute或relative），offsetParent取最近的那个父级元素</p>
<p>另外注意offsetParent与parentNode的区别parentNode只找自己的上一级（<strong>亲爹</strong>）</p>
<h3 id="offsetLeft和offsetTop"><a href="#offsetLeft和offsetTop" class="headerlink" title="offsetLeft和offsetTop"></a>offsetLeft和offsetTop</h3><p>用来得到对象的位置（注意：没有offsetRight和offsetBottom）</p>
<p><strong>\@offsetLeft的构成</strong></p>
<p>到距离自身最近的（<strong>带有定位</strong>的）父元素的 左侧/顶部 的距离</p>
<p>如果所有父级都没有定位则以body 为准</p>
<p>offsetLeft 是<strong>自身border</strong>左侧到<strong>父级padding</strong>左侧的距离</p>
<p><img src="media/f7c4d62b0113df09505749fa29418c87.png" alt=""></p>
<p><img src="media/af9d7118bdc8e609b5063b33c6f9d28d.png" alt=""></p>
<p><strong>\@offsetLeft和style.left的区别</strong></p>
<p>一、style.left只能获取行内样式</p>
<p>二、offsetLeft<strong>只读</strong>，style.left可读可写</p>
<p>三、offsetLeft是<strong>数值</strong>，style.left是<strong>字符串</strong>并且有单位px</p>
<p>四、如果没有加定位，style.left获取的数值可能是无效的</p>
<p>五、最大区别在于offsetLeft以border左上角为基准，style.left以margin左上角为基准</p>
<p><strong>在行内设置以下属性，并且记得加定位</strong></p>
<p>left:20px; margin:20px;</p>
<p><img src="media/f7ccf1af1f2cd1a0600b55842a07deff.png" alt=""></p>
<p><em>不用死记，offset是计算偏移的，只要记住和定位有关就行了，实在需要详细区分，用的时候自己写个div试一试或者一查文档就知道了。</em></p>
<h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2><p><strong>\@Math对象常用方法</strong></p>
<p>天花板 向上取整 负数取更大的</p>
<p>Math.ceil(x)</p>
<p>地板 向下取整 负数取更小的</p>
<p>Math.floor(x)</p>
<p>就近取整</p>
<p>rounds a number to the nearest integer 就近取整 有的地方就翻译成四舍五入了</p>
<p>//四舍五入 只看尾数的最高位 01234舍 56789入</p>
<p>//就近取整 会整体比较 以.5为界限 小于的舍 大于的入 等于的 正数入负数舍</p>
<p>//虽然原则不一样但是实际上差别不大 只有一种情况会产生分歧 就是-1.5</p>
<p>//四舍五入是-2 而就近取整-1</p>
<p>Math.round(x)</p>
<p>取绝对值</p>
<p>Math.abs(x)</p>
<h2 id="动画原理"><a href="#动画原理" class="headerlink" title="动画原理"></a>动画原理</h2><h3 id="动画原理公式"><a href="#动画原理公式" class="headerlink" title="动画原理公式"></a>动画原理公式</h3><p>动画原理公式： leader = leader + step</p>
<p>leader表示盒子当前位置</p>
<p>step表示步长</p>
<p>box.style.left = box.offsetLeft + 10 + “px”;</p>
<p>让setInterval不断执行某个函数修改盒子的位置属性最后就实现了动画的效果</p>
<h3 id="动画函数封装"><a href="#动画函数封装" class="headerlink" title="动画函数封装"></a>动画函数封装</h3><p><strong>\@动画函数封装</strong></p>
<p>动画函数较为复杂，却又很常用对于这样的函数，我们一般都会进行封装</p>
<p>需求：能够让<strong>任意对象</strong>移动到<strong>指定位置</strong>。</p>
<h3 id="动画函数改进"><a href="#动画函数改进" class="headerlink" title="动画函数改进"></a>动画函数改进</h3><p><strong>\@动画函数改进</strong></p>
<p>然而封装之后的函数还有很多问题，所以我们要对其进行进一步改进</p>
<p>判断运动方向</p>
<p>完善终点检测</p>
<p>终点清除定时器</p>
<p>手动设置对象位置到终点</p>
<p>调用开始先清理定时器，防止多次调用</p>
<h2 id="图形属性scroll系列"><a href="#图形属性scroll系列" class="headerlink" title="图形属性scroll系列"></a>图形属性scroll系列</h2><h3 id="scroll系列"><a href="#scroll系列" class="headerlink" title="scroll系列"></a>scroll系列</h3><p><strong>\@scrollHeight和scrollWidth</strong></p>
<p>对象内部实际内容的高度/宽度</p>
<p><strong>\@scrollTop和scrollLeft</strong></p>
<p>被卷去部分的 顶部/左侧 到可视区域 顶部/左侧 的距离</p>
<p><img src="media/5e66a0c026ff6615afe1147299b53253.png" alt=""></p>
<h3 id="页面滚动座标"><a href="#页面滚动座标" class="headerlink" title="页面滚动座标"></a>页面滚动座标</h3><p><strong>\@获取页面滚动座标</strong></p>
<p>页面滚动座标非常常用，但是有很大的兼容性问题，可以合写为</p>
<p>var scrollTop = window.pageYOffset || document.documentElement.scrollTop ||<br>document.body.scrollTop || 0;</p>
<p><strong>\@封装自己的scroll()</strong></p>
<p>由于非常常用，每次都写上面那一大堆很麻烦。我们可以封装一个自己的scroll()方法，返回页面滚动座标</p>
<h3 id="固定导航案例"><a href="#固定导航案例" class="headerlink" title="固定导航案例"></a>固定导航案例</h3><p><strong>\@固定导航案例</strong></p>
<p>当页面向下滚动的时候 进行判断 如果页面向上走的距离 大于导航栏到页面顶部的距离时<br>将导航栏的定位改为固定定位</p>
<p>小问题：当导航栏改为固定定位的一瞬间，后面的元素会塌陷。解决方案：给下面的元素添加数值为导航栏高度的padding-top</p>
<h2 id="缓动动画"><a href="#缓动动画" class="headerlink" title="缓动动画"></a>缓动动画</h2><h3 id="原理公式"><a href="#原理公式" class="headerlink" title="原理公式"></a>原理公式</h3><p>动画公式</p>
<p>leader = leader + step</p>
<p>匀速动画公式</p>
<p>step = 定值</p>
<p>leader = leader + step</p>
<p>缓动动画公式</p>
<p>step = ( target - leader ) / 10</p>
<p>leader = leader + step</p>
<p><strong>缓动动画的好处</strong></p>
<p>他的移动是<strong>有尽头</strong>的。不像基础匀速运动那样无限移动。</p>
<p>有非常逼真的缓动效果，实现的动画效果<strong>更细腻</strong>。</p>
<p>如果不清除定时器，物体永远<strong>跟着目标</strong>leader在移动。</p>
<p><strong>\@体验缓动动画</strong></p>
<h3 id="函数封装"><a href="#函数封装" class="headerlink" title="函数封装"></a>函数封装</h3><p><strong>\@缓动动画改进</strong></p>
<p>多次点击按钮重复开启定时器</p>
<p>永远无法真正到达目标</p>
<p>到达目标后清理定时器</p>
<p><strong>\@缓动函数封装</strong></p>
<p>需求：能够让<strong>任意对象</strong>移动到<strong>指定位置</strong></p>
<h2 id="封装缓动框架"><a href="#封装缓动框架" class="headerlink" title="封装缓动框架"></a>封装缓动框架</h2><p>详细见html代码</p>
<h2 id="图形属性client系列"><a href="#图形属性client系列" class="headerlink" title="图形属性client系列"></a>图形属性client系列</h2><h3 id="client系列"><a href="#client系列" class="headerlink" title="client系列"></a>client系列</h3><p><strong>\@clientWidth和clientHeight：</strong></p>
<p>偏移offsetWidth: width + padding + border</p>
<p>卷曲scrollWidth: width + padding 不包含border 内部内容的大小</p>
<p>可视clientWidth: width + padding 不包含border</p>
<p><img src="media/372b84c77b3774fe6358cd9d1c6ea76a.png" alt=""></p>
<p><strong>\@clientTop和clientLeft</strong></p>
<p>clientTop和clientLeft没什么用</p>
<p>他们就是borderTop和borderLeft（如果有滚动条会包含滚动条的宽度，但谁见过滚动条在顶部或者左侧的？！）</p>
<p><img src="media/1bcc3a46c2e69fc5cc71bc47a3165ecb.png" alt=""></p>
<h3 id="网页可视区宽高"><a href="#网页可视区宽高" class="headerlink" title="网页可视区宽高"></a>网页可视区宽高</h3><p><strong>\@网页可视区宽高的兼容写法</strong></p>
<p>页面可视区宽高非常常用，但是有很大的兼容性问题<strong>，可以合写为</strong></p>
<p>var clientWidth = window.innerWidth|| document.documentElement.clientWidth||<br>document.body.clientWidth|| 0;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;DOM操作&quot;&gt;&lt;a href=&quot;#DOM操作&quot; class=&quot;headerlink&quot; title=&quot;DOM操作&quot;&gt;&lt;/a&gt;DOM操作&lt;/h1&gt;&lt;h2 id=&quot;增-删-改-查-下面有详细介绍&quot;&gt;&lt;a href=&quot;#增-删-改-查-下面有详细介绍&quot; class=&quot;headerlink&quot; title=&quot;增 删 改 查 (下面有详细介绍)&quot;&gt;&lt;/a&gt;增 删 改 查 (下面有详细介绍)&lt;/h2&gt;&lt;h3 id=&quot;增&quot;&gt;&lt;a href=&quot;#增&quot; class=&quot;headerlink&quot; title=&quot;增&quot;&gt;&lt;/a&gt;增&lt;/h3&gt;&lt;p&gt;//document.createElement&lt;/p&gt;
&lt;p&gt;//innerHTML&lt;/p&gt;
&lt;p&gt;//cloneNode&lt;/p&gt;
&lt;p&gt;//appendChild&lt;/p&gt;
&lt;p&gt;//insertBefore&lt;/p&gt;
    
    </summary>
    
      <category term="前端基础" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础一</title>
    <link href="http://yoursite.com/2015/10/04/JavaScript%E5%9F%BA%E7%A1%80%E4%B8%80/"/>
    <id>http://yoursite.com/2015/10/04/JavaScript基础一/</id>
    <published>2015-10-04T04:07:24.000Z</published>
    <updated>2017-02-22T14:11:04.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Js基础"><a href="#Js基础" class="headerlink" title="Js基础"></a>Js基础</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="JS的组成"><a href="#JS的组成" class="headerlink" title="JS的组成"></a>JS的组成</h3><ul>
<li><p>ECMAScript 规定了js的语法标准以及规范</p>
</li>
<li><p>DOM document object model 文档对象类型<br>提供了一套操作DOM元素的API(应用程序接口)</p>
</li>
<li><p>BOM Browser object model 浏览器对象模型 提供了一套操作浏览器相关内容的API</p>
</li>
</ul>
<a id="more"></a>
<h3 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h3><p><strong>\@常用输出语句</strong></p>
<p><img src="media/8e82caea6927679813eb940aaa22c467.png" alt=""></p>
<h3 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h3><p><strong>\@代码注释</strong></p>
<p>//单行注释</p>
<p>/* 多行注释 */</p>
<p>书写多行注释的时候注意不要发生嵌套</p>
<p>/** + 回车 用于函数的说明</p>
<h3 id="书写位置"><a href="#书写位置" class="headerlink" title="书写位置"></a>书写位置</h3><p><strong>\@书写位置</strong></p>
<p>可以写在HTML页面内的任意位置或者从外部引用（可以类比样式代码的书写位置）</p>
<h3 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h3><p><strong>\@script标签的属性</strong></p>
<p><strong>type类型 src 地址</strong></p>
<p><strong>async</strong>异步加载，加载完成立即执行<br><strong>defer</strong>异步加载，页面上的东西都执行完了才执行<em>（了解即可!!!）</em></p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h3><p><strong>\@变量的命名</strong></p>
<p><strong>规则(必须遵守)</strong></p>
<p>区分大小写</p>
<p>不能是关键字和保留字</p>
<p>由字母、数字、下划线、\$ 组成且开头不能是数字</p>
<p>tips:关键字和保留字那么多，记不住怎么办？</p>
<p>首先，关键字就是你平时用的那些，而保留字在非严格模式下不能使用的只有：</p>
<p><strong>class enum extends super const export import</strong></p>
<p>而且，其实如果你使用了关键webstorm是有提示的，但是常见的几个最好还是记住</p>
<p><strong>规范(建议遵守)</strong></p>
<p>变量的名称要有实际意义</p>
<p>规则中所说的字母包括ASCII和Unicode字母字符，如汉字，但不推荐使用</p>
<p>变量的命名遵守驼峰命名法，首字母小写,第二个单词的首字母大写 例如：userName</p>
<h3 id="变量的声明赋值"><a href="#变量的声明赋值" class="headerlink" title="变量的声明赋值"></a>变量的声明赋值</h3><p><strong>\@变量的声明和赋值</strong></p>
<p>书写格式</p>
<p>var 变量名 = 值</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p><strong>\@交换两个变量的值</strong></p>
<p><strong>\@不使用第三个变量</strong></p>
<h3 id="弱类型"><a href="#弱类型" class="headerlink" title="弱类型"></a>弱类型</h3><p><strong>\@弱类型</strong></p>
<p>JavaScript是弱类型的语言，即声明不同数据类型的变量使用同一个关键字var</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h3><p>声明的时候不用考虑类型，但是处理和计算的时候要考虑类型</p>
<p><strong>简单数据类型(值类型)</strong></p>
<p>number数值型 string字符串型 boolean布尔型 undefined 未定义 null空</p>
<p><strong>复杂数据类型(引用类型)</strong></p>
<p>object对象 function 函数 Array 数组 Data 日期 RegExp 正则 Math String Number<br>Boolean</p>
<p><strong>使用typeof关键字可以查看变量的数据类型</strong></p>
<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p><strong>\@数值类型</strong></p>
<p><strong>字面量</strong></p>
<p>var num = 数字;</p>
<p><strong>浮点数</strong></p>
<p>计算浮点数时会丢失精度</p>
<p>我们通常用整数的计算来表示浮点数的计算</p>
<p>不要以两个浮点数是否相等作为条件判断的依据（判断范围还是可以的）</p>
<p><strong>NaN</strong></p>
<p>NaN是数值类型</p>
<p>NaN不等于自身</p>
<p>isNaN( ) 不是有意义的数值返回true</p>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p><strong>\@字符串型</strong></p>
<p><strong>字面量</strong></p>
<p>var str = “字符串”;</p>
<p><strong>字符串的长度</strong></p>
<p>str.length</p>
<p>length就是长度的意思</p>
<p><strong>转义符</strong></p>
<p>\n 换行 \’单引号 \”双引号 \\斜杠</p>
<p><strong>字符串的不可变性</strong></p>
<p>由于字符串有不可变性，在大量拼接字符串的时候会非常消耗内存。</p>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p><strong>\@布尔类型</strong></p>
<p>所有类型的值都可以转化成布尔值</p>
<p>会转化成false的值有： 空字符串 数值零NaN undefined null</p>
<h3 id="undefined类型"><a href="#undefined类型" class="headerlink" title="undefined类型"></a>undefined类型</h3><p><strong>\@undefined</strong></p>
<p>表示声明但未赋值的变量</p>
<p>手动赋值为 undefined对象属性不存在的时候,这个属性的值为undefined</p>
<p>变量不可能自动为 null 除非手动赋值</p>
<p>当给别人提供一个返回对象的方法或者函数的时候<br>当函数中创建这个对象失败，或者获取对象失败，无法正常返回对象的时候，就应该返回null</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="转换成字符串"><a href="#转换成字符串" class="headerlink" title="转换成字符串"></a>转换成字符串</h3><p><strong>\@转换成字符串</strong></p>
<p>将任意类型转化为字符串</p>
<p>String(值)</p>
<p>大部分类型都有toString方法</p>
<p>值.toString()</p>
<p>小技巧</p>
<p>值+””</p>
<h3 id="转化成数值型"><a href="#转化成数值型" class="headerlink" title="转化成数值型"></a>转化成数值型</h3><p><strong>\@转换成数值</strong></p>
<p>将任意类型转化为数值型</p>
<p>Number(值)</p>
<p>将字符串转化为数值</p>
<p>parseInt(“字符串”) parseFloat(“字符串”)</p>
<p>小技巧</p>
<p>值-0</p>
<h3 id="转化成布尔值"><a href="#转化成布尔值" class="headerlink" title="转化成布尔值"></a>转化成布尔值</h3><p><strong>\@转换成布尔值</strong></p>
<p>将任意类型转化为布尔值</p>
<p>Boolean(值)</p>
<p>条件判断中会自动转换</p>
<p>if(值)</p>
<p>小技巧</p>
<p>!!值</p>
<h2 id="获取数据类型"><a href="#获取数据类型" class="headerlink" title="获取数据类型"></a>获取数据类型</h2><h3 id="typeof-关键字"><a href="#typeof-关键字" class="headerlink" title="typeof 关键字"></a>typeof 关键字</h3><p>语法 typeof 变量</p>
<p>返回值: 字符串的 类型 (返回的内容也是字符串)</p>
<p>使用typeof关键字去获取复杂数据类型的类型的时候 只能获取到object</p>
<p>typof是个关键字，后面加括号，只是对后面的代码进行分组，提升了优先级</p>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p><strong>\@运算符</strong></p>
<h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><p><strong>\@递增和递减</strong></p>
<p>递增++ 递减–</p>
<p>a++ 先参与运算 后自加</p>
<p>++a 先自加 后参与运算</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><strong>\@逻辑运算符</strong></p>
<ul>
<li><p>&amp;&amp; 与</p>
<ol>
<li><p>两个操作数都为true，结果为true</p>
<p>只要有一个操作数为false，结果为false</p>
</li>
</ol>
</li>
<li><p>|| 或</p>
<ol>
<li><p>只要有一个操作数为true，结果为true</p>
<p>两个操作数都为false，结果为false</p>
</li>
</ol>
</li>
<li><p>! 非</p>
<ol>
<li><p>逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反</p>
<p>只有一个操作数</p>
</li>
</ol>
</li>
</ul>
<p><strong>逻辑运算</strong></p>
<p>&amp;&amp; 和 || 都采取短路运算，即<strong>第一个能够决定结果就不再看第二个</strong>了</p>
<p>&amp;&amp; 的要求比较宽松 要<strong>两个都是true才是true</strong><br>所以看到第一个是false就没有必要继续完后看了</p>
<p>console.log(false &amp;&amp; 不管了);</p>
<p>|| 的要求比较严格 要<strong>两个都是false才是false</strong><br>所以看到第一个是true就没有必要继续完后看了</p>
<p>console.log(true || 不管了);</p>
<p><strong>短路运算（了解）</strong></p>
<p>&amp;&amp;和 ||<br>不但可以操作布尔类型的值，对<strong>其他类型的值</strong>也可以进行操作，并<strong>返回可以决定表达式结果的那个值</strong>。</p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p><strong>\@赋值运算符</strong></p>
<p>a+=b 等价于 a=a+b</p>
<h3 id="关系运法符"><a href="#关系运法符" class="headerlink" title="关系运法符"></a>关系运法符</h3><ul>
<li><p>\&lt; \&lt;= >= ></p>
</li>
<li><p>== != 相等和不相等</p>
</li>
<li><p>=== !== 全等和不全等</p>
</li>
<li><p>注意: 当引用类型的数据和值类型的数据进行运算（+-*/ == > \&lt;）的时候</p>
<ul>
<li><p>会调用引用类型数据的valueOf方法，获取返回值，如果这个返回值可以参与运算，那么就直接用了</p>
</li>
<li><p>如果不能参与运算，再去调用该引用类型数据的toString方法,拿这个返回值来参与运算</p>
</li>
<li><p>例</p>
</li>
</ul>
</li>
</ul>
<p>//字面量</p>
<p>//{}</p>
<p>//[]<br>//1.只要遇到字面量，必然是在创建对象<br>console.log([] == []);//false</p>
<p>console.log({} == {});//false<br>//引用类型的数据和值类型<br>console.log([] == ![]);<br>//调用上述方法后就相当于console.log(“” == false);</p>
<h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><ul>
<li><p>优先级从高到底</p>
<ol>
<li><p>() 优先级最高</p>
<p>一元运算符 ++ – !</p>
<p>算数运算符 先* / % 后 + -</p>
<p>关系运算符 > >= \&lt; \&lt;=</p>
<p>相等运算符 == != === !==</p>
<p>逻辑运算符 先&amp;&amp; 后||</p>
</li>
</ol>
</li>
</ul>
<h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><ul>
<li><p>值类型：直接存储数据本身的数据，就是值类型的数据</p>
</li>
<li><p>引用类型：存储的是数据的地址，数据单独存储，这种数据就是引用类型的数据</p>
</li>
</ul>
<p>特征:</p>
<ul>
<li><p>值类型的数据在赋值的时候，会将存储的数据复制一份交给新的变量，两个变量值相等，但是存储的空间不一样，修改其中一个，另外一个不会受影响</p>
</li>
<li><p>引用类型的数据在赋值的时候，会将对象的地址复制一份交给新的变量，此时两个变量同时指向同一个对象，通过其中一个变量对对象进行修改，另外一个变量也会受到影响</p>
</li>
</ul>
<p>var num = 100;</p>
<p>function test(n){</p>
<p>//n = num //值类型的赋值</p>
<p>n = 1000;</p>
<p>}</p>
<p>test(num);</p>
<p>console.log(num);//100</p>
<p>var obj1 = {</p>
<p>name:”高富帅”;</p>
<p>}</p>
<p>function test(obj){</p>
<p>//obj = obj1; //引用类型的赋值</p>
<p>obj.name = “矮穷丑”;</p>
<p>}</p>
<p>test(obj1);</p>
<p>console.log(obj1.name);//矮穷丑</p>
<p>var obj1 = {</p>
<p>name:”高富帅”</p>
<p>}</p>
<p>function test(obj){</p>
<p>obj.name = “矮穷丑”</p>
<p>obj = {</p>
<p>name : “白富美”</p>
<p>}</p>
<p>obj.name = “土肥圆”;</p>
<p>return obj.name;</p>
<p>}</p>
<p>console.log(test(obj1));//土肥圆</p>
<p>console.log(obj1.name);//矮穷丑</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="选择语句if"><a href="#选择语句if" class="headerlink" title="选择语句if"></a>选择语句if</h3><p>if (condition) {</p>
<p>statement1</p>
<p>} else if (condition) {</p>
<p>statement2</p>
<p>} else {</p>
<p>statement3</p>
<p>}</p>
<h3 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h3><p>表达式1 ? 表达式2 : 表达式3</p>
<h3 id="选择语句switch"><a href="#选择语句switch" class="headerlink" title="选择语句switch"></a>选择语句switch</h3><p>switch (expression) {</p>
<p>case value:</p>
<p>statement</p>
<p>break;</p>
<p>case value:</p>
<p>statement</p>
<p>break;</p>
<p>default:</p>
<p>statement</p>
<p>}</p>
<h3 id="循环语句for"><a href="#循环语句for" class="headerlink" title="循环语句for"></a>循环语句for</h3><p>for (initialization; expression; post-loop-expression)｛</p>
<p>statement</p>
<p>｝</p>
<p>initialization表示：初始化表达式</p>
<p>expression表示：控制表达式</p>
<p>post-loop-expression表示：循环后表达式</p>
<p>三者都是可选的</p>
<h3 id="循环语句-for-in-amp-关键字in的使用"><a href="#循环语句-for-in-amp-关键字in的使用" class="headerlink" title="循环语句 for-in &amp; 关键字in的使用"></a>循环语句 for-in &amp; 关键字in的使用</h3><ul>
<li>for-in 遍历对象的键</li>
</ul>
<p>语法 for (var k in obj)｛</p>
<p>console.log(k);</p>
<p>｝</p>
<ul>
<li><p>注意：对象的属性全都是字符串类型的</p>
</li>
<li><p>注意： 在for-in中使用键访问对象的值的时候，不能使用点语法</p>
</li>
<li><p>只能使用中括号 又叫做 关联数组语法</p>
</li>
<li><p>判断对象是否可以访问某个属性</p>
<ul>
<li>语法： 属性名 in 对象</li>
</ul>
</li>
</ul>
<p>console.log(“toString” in obj);</p>
<ul>
<li>返回值： 布尔值，表示能或者不能</li>
</ul>
<h3 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h3><p>break跳出当前循环，执行循环后的语句</p>
<p>continue跳出当前循环，继续执行循环</p>
<h3 id="循环语句while"><a href="#循环语句while" class="headerlink" title="循环语句while"></a>循环语句while</h3><p><strong>while语句</strong> 先判断后执行</p>
<p>while(expression) statement</p>
<p><strong>do while 语句</strong> 先执行后判断</p>
<p>do {statement} while (expression);</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h3><p>通过构造函数声明（更加通用）</p>
<p>var arr = new Array(“a”, “b”, “c”);</p>
<p>通过字面量声明（更加简便）</p>
<p>var arr = [“a”,”b”,”c”];</p>
<h3 id="数组的赋值和取值"><a href="#数组的赋值和取值" class="headerlink" title="数组的赋值和取值"></a>数组的赋值和取值</h3><p><strong>赋值</strong></p>
<p>数组名[索引号] = 值 //arr[0]=100</p>
<p><strong>取值</strong>（通过数组名和索引即可取到对应的值）</p>
<p>数组名[索引号] //console.log(arr[0])</p>
<h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><p>数组的索引是从0开始的</p>
<p>数组的长度可以通过arr.length获取</p>
<p>由于数组的索引从0开始，所以最后一个值的索引为arr.length-1</p>
<p><strong>通过for循环遍历数组</strong></p>
<p>for (var i = 0; i \&lt;= arr.length - 1; i++) {</p>
<p>console.log(arr[i]);</p>
<p>}</p>
<p>可<strong>简写</strong>为：</p>
<p>for (var i = 0; i \&lt; arr.length; i++) {</p>
<p>console.log(arr[i]);</p>
<p>}</p>
<p><strong>\@数组length的应用</strong></p>
<p>往数组中添加新元素，数组的length会增加</p>
<p>通过给arr.length赋值可以改变数组的长度</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><strong>\@冒泡排序</strong></p>
<p>var arr = [65, 97, 76, 13, 27, 49, 58];<br>//循环控制趟数<br>for (var i = 0; i \&lt; arr.length - 1; i++) {<br>//控制两两比较的次数<br>for (var j = 0; j \&lt; arr.length - 1; j++) {<br>//两两比较 从小到大排序<br>if (arr[j] > arr[j + 1]) {<br>//交换位置<br>var tmp = arr[j];<br>arr[j] = arr[j + 1];<br>arr[j + 1] = tmp;<br>}<br>}<br>}</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的声明和调用"><a href="#函数的声明和调用" class="headerlink" title="函数的声明和调用"></a>函数的声明和调用</h3><p>函数的声明</p>
<p>function 函数名 () {</p>
<p>//函数体</p>
<p>}</p>
<p>函数的调用</p>
<p>函数名();</p>
<h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>有参数的函数的<strong>声明</strong>（声明中的参数只是一个占位符，没有实际的值，是形式参数，即<strong>形参</strong>）</p>
<p>function 函数名 (参数1,参数2,参数3…) {</p>
<p>//函数体</p>
<p>}</p>
<p>有参数的函数的<strong>调用</strong>（调用时传入的参数才是有真正数值的参数，是实际参数，即<strong>实参</strong>）</p>
<p>函数名(参数1,参数2,参数3…);</p>
<h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>在函数中通过return关键字将要返回值返回</p>
<p>return 要返回的值;</p>
<h3 id="函数高级概念"><a href="#函数高级概念" class="headerlink" title="函数高级概念"></a>函数高级概念</h3><p><strong>\@参数详解</strong></p>
<p>在JS中实参的个数和形参的个数可以不一致</p>
<p><strong>\@返回值详解</strong></p>
<p>函数的返回值是什么，调用这个函数就相当于调用什么，如果没有返回值则为undefined</p>
<p>函数在执行完成return语句后便会退出函数，后面的代码不会执行</p>
<p><strong>\@三种定义方式</strong></p>
<p>函数声明</p>
<p>function fn1() {</p>
<p>//函数体</p>
<p>}</p>
<p>函数表达式</p>
<p>var fn2 = function () {</p>
<p>//函数体</p>
<p>};</p>
<p>Function</p>
<p>Var 函数名= new Function fn1()</p>
<p><strong>\@匿名函数</strong></p>
<p>匿名函数（没有名字的函数）</p>
<p>变量 = function () {</p>
<p>//函数体</p>
<p>}</p>
<p><strong>\@递归调用</strong></p>
<p>程序调用自身的编程技巧称为递归</p>
<p><strong>\@回调函数</strong></p>
<p>函数也是一种普通的数据类型</p>
<p>因此函数也可以被当作参数传递</p>
<p>被当作参数传递的函数叫做回调函数</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>从宏观的角度讲，对象是对客观事物的抽象，事物的特征可以用<strong>属性</strong>表示，事物的行为可以用<strong>方法</strong>表示</p>
<p>从微观的角度讲，对象就是一种数据类型，通过对象可以方便地对<strong>变量</strong>和<strong>函数</strong>进行管理</p>
<p>初期我们甚至可以把他简单地理解为一个工具箱</p>
<h3 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h3><p>键值对就是一种对应关系，通过键能够方便地找到值</p>
<p>键:值 key:value k:v</p>
<h3 id="对象的声明"><a href="#对象的声明" class="headerlink" title="对象的声明"></a>对象的声明</h3><p>通过构造函数声明（更加通用）</p>
<p>var obj= new Object();</p>
<p>通过字面量声明（更加简便）</p>
<p>var obj= {};</p>
<p>对象具有属性和方法</p>
<p>属性 用来描述对象的特征 一般是名词 对应变量</p>
<p>方法 用来描述对象的行为 一般是动词 对应函数</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性的定义</p>
<p>对象.属性名 = 值</p>
<p>属性的调用</p>
<p>对象.属性名</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法的定义</p>
<p>对象.方法名 = function(){ //函数体 };</p>
<p>方法的调用</p>
<p>对象.方法名()</p>
<h2 id="关于this-的指向"><a href="#关于this-的指向" class="headerlink" title="关于this 的指向"></a>关于this 的指向</h2><h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文:"></a>全局上下文:</h3><p>全局运行上下文中（在任何函数体外部），this 指代全局对象</p>
<h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文:"></a>函数上下文:</h3><p><strong>对象方法中的this</strong>指的是该方法所属的对象 <strong>直接调用中的this</strong>指的是全局对象<br>总之，函数上下文中（在函数内部），this指的是当前函数所属的对象</p>
<h3 id="构造函数中"><a href="#构造函数中" class="headerlink" title="构造函数中:"></a>构造函数中:</h3><p>当一个函数被作为构造函数使用时（前面加new关键字），new关键字会让this的指向改变，并让其成为当前函数的返回值</p>
<h2 id="批量创建对象"><a href="#批量创建对象" class="headerlink" title="批量创建对象"></a>批量创建对象</h2><h3 id="工厂模式创建对象"><a href="#工厂模式创建对象" class="headerlink" title="工厂模式创建对象"></a>工厂模式创建对象</h3><p><strong>为什么要优化创建对象的方式</strong></p>
<p>因为对象在项目中被大规模的使用，所以每一点小小的改进都会对项目整体效率带来很大的提升，现阶段同学们还不可能有深刻的体会，只是让大家了解一下，后面讲项目大家自然就明白了。</p>
<p><strong>\@工厂模式创建对象</strong></p>
<p>同类型对象，只是一些属性的值不同，通过对象字面量创建对象每次都要写那么多东西很费劲，我们可以<strong>将创建对象的过程封装进一个函数，只把发生变化的属性作为参数传入</strong>，从而简化对象创建的过程。</p>
<p>但是工厂模式只是创建出来一个普通的对象并将其返回，因此无法判断实例的具体类型。</p>
<h3 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h3><p><strong>\@this和new</strong></p>
<p>利用new 关键字可以声明新的对象。new<br>关键字可以让构造函数中this的指向改变，并让构造函数把this返回。</p>
<p><strong>\@构造函数</strong></p>
<p>构造函数也是函数，只不过会默认返回一个对象。</p>
<p><img src="media/d0dab56260f1fc8c61e6c3b34ae78416.png" alt=""></p>
<p><img src="media/4d8d5bb043f33709c9fcd553ebf79fe7.png" alt=""></p>
<p><strong>\@构造函数创建对象</strong></p>
<p>通过构造函数创建对象更方便（不需要创建对象并返回）。更重要的是可以通过<strong>instanceof</strong>来判断实例的类型了。</p>
<h2 id="对象的动态创建"><a href="#对象的动态创建" class="headerlink" title="对象的动态创建"></a>对象的动态创建</h2><h3 id="对象的动态特性"><a href="#对象的动态特性" class="headerlink" title="对象的动态特性"></a>对象的动态特性</h3><p>就是指，在对象创建出来之后，可以随时为对象添加成员的这种特性，就是动态特性</p>
<p>语法: 成员：属性和方法</p>
<h3 id="利用对象动态特性给对象添加成员的方式"><a href="#利用对象动态特性给对象添加成员的方式" class="headerlink" title="利用对象动态特性给对象添加成员的方式"></a>利用对象动态特性给对象添加成员的方式</h3><ul>
<li>点语法</li>
</ul>
<p>对象名.属性名 = 值</p>
<ul>
<li>关联数组语法</li>
</ul>
<p>对象名[“属性名”] = 值</p>
<ul>
<li>案例</li>
</ul>
<p>obj[[]] = “我是一个怪物！！”;</p>
<p>//相当于做了如下操作</p>
<p>//obj[“[object Object]”] = “我是一个怪物！！”;</p>
<h2 id="delete关键字"><a href="#delete关键字" class="headerlink" title="delete关键字"></a>delete关键字</h2><p>语法：delete 变量名/对象.属性名</p>
<p>返回值：boolean类型 表示是否删除成功 不可信！！！</p>
<h3 id="删除未使用var声明的变量-使用var的删不掉"><a href="#删除未使用var声明的变量-使用var的删不掉" class="headerlink" title="删除未使用var声明的变量 (使用var的删不掉)"></a>删除未使用var声明的变量 (使用var的删不掉)</h3><p>a = 10;</p>
<p>console.log(delete a);</p>
<p>console.log(a);</p>
<h3 id="删除对象的属性"><a href="#删除对象的属性" class="headerlink" title="删除对象的属性"></a>删除对象的属性</h3><p>var obj = {</p>
<p>// name : “郑天杨”</p>
<p>// }<br>console.log(delete obj.name);<br>//Object.defineProperty() 表示是否可以删除对象的属性 后面js高级会学</p>
<h3 id="delete删除数组元素"><a href="#delete删除数组元素" class="headerlink" title="delete删除数组元素"></a>delete删除数组元素</h3><p>delete删除数组元素的时候，数组原本的其他数据的索引不会变化而且数组的长度也不会变化！！只是删除了索引及其对应的值</p>
<h2 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h2><h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><p><strong>\@对象字面量</strong></p>
<p>var o = {</p>
<p>name : “zs”,</p>
<p>age : 18,</p>
<p>sayHi : function() {</p>
<p>console.log(this.name);</p>
<p>}</p>
<p>};</p>
<h3 id="对象标记法"><a href="#对象标记法" class="headerlink" title="对象标记法"></a>对象标记法</h3><p><strong>\@对象标记法</strong></p>
<p>JavaScript Object<br>Notation（JavaScript对象标记法）是仿照JS中对象字面量的格式去书写的一串用来记录对象数据的<strong>字符串</strong>，可以用于数据传输。将来学习AJAX会详细学习。</p>
<h3 id="访问属性的两种方式"><a href="#访问属性的两种方式" class="headerlink" title="访问属性的两种方式"></a>访问属性的两种方式</h3><p><strong>\@访问属性的两种方式</strong></p>
<p>点语法（简单）</p>
<p>对象.属性名</p>
<p>中括号（灵活）</p>
<p>对象[“属性名”]</p>
<h3 id="遍历的两种方式"><a href="#遍历的两种方式" class="headerlink" title="遍历的两种方式"></a>遍历的两种方式</h3><p><strong>\@遍历的两种方式</strong></p>
<p>通过for可以对集合进行有序的遍历</p>
<p>通过forin可以对集合进行有序的遍历</p>
<p>for(var k in obj) { 语句 }</p>
<p>k变量代表的是json中的各个属性（key）和 var i = 0中的i是一个意思 名字不同而已</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Js基础&quot;&gt;&lt;a href=&quot;#Js基础&quot; class=&quot;headerlink&quot; title=&quot;Js基础&quot;&gt;&lt;/a&gt;Js基础&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;h3 id=&quot;JS的组成&quot;&gt;&lt;a href=&quot;#JS的组成&quot; class=&quot;headerlink&quot; title=&quot;JS的组成&quot;&gt;&lt;/a&gt;JS的组成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ECMAScript 规定了js的语法标准以及规范&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DOM document object model 文档对象类型&lt;br&gt;提供了一套操作DOM元素的API(应用程序接口)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;BOM Browser object model 浏览器对象模型 提供了一套操作浏览器相关内容的API&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端基础" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
