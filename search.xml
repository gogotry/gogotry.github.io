<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[测试文章3]]></title>
      <url>%2F2017%2F02%2F06%2F%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A03%2F</url>
      <content type="text"><![CDATA[测试文章3]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[测试文章2]]></title>
      <url>%2F2017%2F02%2F06%2F%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A02%2F</url>
      <content type="text"><![CDATA[测试文章222]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[测试文章1]]></title>
      <url>%2F2017%2F02%2F06%2F%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A01%2F</url>
      <content type="text"><![CDATA[测试文章1111]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[readme]]></title>
      <url>%2F2017%2F02%2F06%2Freadme%2F</url>
      <content type="text"><![CDATA[课程笔记反馈 老师录得视频听得不大清楚希望注意一下. 希望老师可以把那个 具体的命令行啥的 写的再详细一点 另外就是那个廖学峰那个文档怎么看，里面好多文件夹，不知道打开哪一个？ SVN有必要掌握吗 会基本使用就可以了 希望老师明天再大概的过一遍， 每个单个知识点都觉得很简单，但是觉得很容易就忘了。 拜托了老师， 祝老师新的一年越长越帅。 开年第一天听课效率还不错,祝老师新年快乐 svn服务器的文件是存在什么地方？ 复习 知识点 Git Github 项目阶段 Git-bash 文件操作相关命令 touch：创建文件 cat：查看文件 less：查看大文本文件 vi：visual interface Esc 退出到命令模式 i 进入插入模式 :q 退出vi :w 保存编辑 :wq 保存并退出 :q! 强制退出不保存修改 vi 的所有操作基本全部是命令，这里掌握基本使用基于可以了 有时候使用 git commit 进行提交的时候希望能多写几行提交日志，这时候可以省略 -m 参数进入 vi 编辑模式 Git参考资料基本命令 git init git status git add git commit git log 添加/删除文件1234567891011121314151617# 添加指定文件到暂存区git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录git add [dir]# 添加当前目录的所有文件到暂存区git add .# 删除工作区文件，并且将这次删除放入暂存区git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]# 改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed] 代码提交123456789101112131415# 提交暂存区到仓库区git commit -m [message]# 提交暂存区的指定文件到仓库区git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区git commit -a# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ... 回退撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [file]# 恢复暂存区的所有文件到工作区git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]# 重置暂存区与工作区，与上一次commit保持一致git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]# 暂时将未提交的变化移除，稍后再移入git stashgit stash pop 分支管理默认在 git 的仓库中，会有个分支的原点：master 1234567891011121314151617181920# 列出所有本地分支git branch# 基于当前分支新建一个分支，但依然停留在当前分支git branch [branch-name]# 基于当前分支新建一个分支，并切换到该分支git checkout -b [branch]# 切换到指定分支，并更新工作区git checkout [branch-name]# 切换到上一个分支，交替和上一个分支进行切换git checkout -# 合并指定分支到当前分支git merge [branch]# 删除分支git branch -d [branch-name] 远程操作1234567891011121314151617181920# 下载一个远程仓库$ git clone [url]# 显示所有远程仓库git remote -v# 显示某个远程仓库的信息git remote show [remote]# 增加一个新的远程仓库，并命名git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]# 上传本地指定分支到远程仓库git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突git push [remote] --force Git 工作流程：分支策略 Git 工作流程 Git FlowGithub Collabrators这种方式公司团队项目使用居多 Github Flow这种方式开源项目使用居多 fork clone 到你的本地 在clone下来的项目中拉出一个新的分支 修改的时候最好是基于 master 拉出一个修改的分支，例如这个分支是用来添加某个功能的 在新分支上开发或者修改完成之后，提交到本地仓库，然后 push 推到自己的账户中 fork 过来的仓库 最后，在 Github 上你 fork 过来的仓库界面中找到 New Pull Request 发起提交请求 对方就会在仓库的 Pull Requests 中收到你发起的提交请求 然后双方就可以使用社会化交流方式进行沟通协作 例如 Code Review 代码审查 最后对方审查通过没有问题之后，选择 Merge Request 到此，一个完整的 Github 工作流结束 这种方式开源项目更多一些（大家都不认识） Gitlab flowGitlab对于第三方代码仓库托管服务有很多，其中 Github 最火，但是如果想要托管私有项目收费比较高，而且在国内受限于网络环境影响，鲜少有公司使用。 也有的公司，例如京东、淘宝这种级别的公司，也不太常用别的第三方的托管服务。 Gitlab 是一个开源的类似于 Github 的一个系统，开源免费部署到自己的公司内容。 与 Github 进行多人协作CollaboratorsPull Request Github PagesGithub Pages 提供了一个免费在线托管静态资源的服务，叫做：Github Pages。 使用方法如下： 在个人的 Github 账户中创建一个仓库 仓库名称必须为 个人账户名称.github.io 往该仓库根目录中提交一个 index.html 文件 然后就可以在地址栏输入 个人账户名称.github.io 地址，就可以看到 index.html 网页内容了 注意：上面创建的仓库名称必须是 个人账户名称.github.io ，否则无法访问 HexoHexo 是基于 Node.js 开发的一个静态博客生成器，提供本地实时预览及部署功能。基本使用方式如下： 123456789npm install -g hexo-clihexo init blogcd blog# 启动本地预览服务，默认是 127.0.0.1:4000hexo server# 新建文章hexo new 文章标题 也可以参考 Hexo 官方文档：https://hexo.io/zh-cn/ , 里面有具体的使用方式。 自动发布 Hexo 搭建的静态博客第一：先修改 _config.yml 配置文件，下面是一个示例： 123deploy: type: git repo: https://heima04:heima123456@github.com/heima04/heima04.github.io.git 上面的配置选项中，一定要注意在 repo 中按照对应的格式加入 Github 用户名和密码。 第二：安装自动发布的插件： 1npm install hexo-deployer-git --save 第三：使用命令一键进行发布： 123hexo generate --deploy# 或者hexo deploy --generate 上面两条命令都可以，发布可能有延时，稍微等待即可。 目标 能掌握 Git-Bash 中 touch、cat、less、vi 命令的基本使用 能掌握 Git 中分支的基本操作（branch、checkout、merge） 能概述 Git-Flow 工作流（Git-Flow 分支管理策略） 能掌握 Github 中多人协同的两种协作方式（Collaborators 和 Pull Request）的基本操作流程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端总结]]></title>
      <url>%2F2017%2F02%2F05%2F%E5%89%8D%E7%AB%AF%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[JavaScript基础 Js基础介绍JS的组成 ECMAScript 规定了js的语法标准以及规范 DOM document object model 文档对象类型提供了一套操作DOM元素的API(应用程序接口) BOM Browser object model 浏览器对象模型 提供了一套操作浏览器相关内容的API 输出语句\@常用输出语句 代码注释\@代码注释 //单行注释 /* 多行注释 */ 书写多行注释的时候注意不要发生嵌套 /** + 回车 用于函数的说明 书写位置\@书写位置 可以写在HTML页面内的任意位置或者从外部引用（可以类比样式代码的书写位置） 标签属性\@script标签的属性 type类型 src 地址 async异步加载，加载完成立即执行defer异步加载，页面上的东西都执行完了才执行（了解即可!!!） 变量变量的命名规范\@变量的命名 规则(必须遵守) 区分大小写 不能是关键字和保留字 由字母、数字、下划线、\$ 组成且开头不能是数字 tips:关键字和保留字那么多，记不住怎么办？ 首先，关键字就是你平时用的那些，而保留字在非严格模式下不能使用的只有： class enum extends super const export import 而且，其实如果你使用了关键webstorm是有提示的，但是常见的几个最好还是记住 规范(建议遵守) 变量的名称要有实际意义 规则中所说的字母包括ASCII和Unicode字母字符，如汉字，但不推荐使用 变量的命名遵守驼峰命名法，首字母小写,第二个单词的首字母大写 例如：userName 变量的声明赋值\@变量的声明和赋值 书写格式 var 变量名 = 值 练习\@交换两个变量的值 \@不使用第三个变量 弱类型\@弱类型 JavaScript是弱类型的语言，即声明不同数据类型的变量使用同一个关键字var 数据类型数据类型声明的时候不用考虑类型，但是处理和计算的时候要考虑类型 简单数据类型(值类型) number数值型 string字符串型 boolean布尔型 undefined 未定义 null空 复杂数据类型(引用类型) object对象 function 函数 Array 数组 Data 日期 RegExp 正则 Math String NumberBoolean 使用typeof关键字可以查看变量的数据类型 数值类型\@数值类型 字面量 var num = 数字; 浮点数 计算浮点数时会丢失精度 我们通常用整数的计算来表示浮点数的计算 不要以两个浮点数是否相等作为条件判断的依据（判断范围还是可以的） NaN NaN是数值类型 NaN不等于自身 isNaN( ) 不是有意义的数值返回true 字符串类型\@字符串型 字面量 var str = “字符串”; 字符串的长度 str.length length就是长度的意思 转义符 \n 换行 \’单引号 \”双引号 \\斜杠 字符串的不可变性 由于字符串有不可变性，在大量拼接字符串的时候会非常消耗内存。 布尔类型\@布尔类型 所有类型的值都可以转化成布尔值 会转化成false的值有： 空字符串 数值零NaN undefined null undefined类型\@undefined 表示声明但未赋值的变量 手动赋值为 undefined对象属性不存在的时候,这个属性的值为undefined 变量不可能自动为 null 除非手动赋值 当给别人提供一个返回对象的方法或者函数的时候当函数中创建这个对象失败，或者获取对象失败，无法正常返回对象的时候，就应该返回null 类型转换转换成字符串\@转换成字符串 将任意类型转化为字符串 String(值) 大部分类型都有toString方法 值.toString() 小技巧 值+”” 转化成数值型\@转换成数值 将任意类型转化为数值型 Number(值) 将字符串转化为数值 parseInt(“字符串”) parseFloat(“字符串”) 小技巧 值-0 转化成布尔值\@转换成布尔值 将任意类型转化为布尔值 Boolean(值) 条件判断中会自动转换 if(值) 小技巧 !!值 获取数据类型typeof 关键字语法 typeof 变量 返回值: 字符串的 类型 (返回的内容也是字符串) 使用typeof关键字去获取复杂数据类型的类型的时候 只能获取到object typof是个关键字，后面加括号，只是对后面的代码进行分组，提升了优先级 操作符\@运算符 一元运算符\@递增和递减 递增++ 递减– a++ 先参与运算 后自加 ++a 先自加 后参与运算 逻辑运算符\@逻辑运算符 &amp;&amp; 与 两个操作数都为true，结果为true 只要有一个操作数为false，结果为false || 或 只要有一个操作数为true，结果为true 两个操作数都为false，结果为false ! 非 逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反 只有一个操作数 逻辑运算 &amp;&amp; 和 || 都采取短路运算，即第一个能够决定结果就不再看第二个了 &amp;&amp; 的要求比较宽松 要两个都是true才是true所以看到第一个是false就没有必要继续完后看了 console.log(false &amp;&amp; 不管了); || 的要求比较严格 要两个都是false才是false所以看到第一个是true就没有必要继续完后看了 console.log(true || 不管了); 短路运算（了解） &amp;&amp;和 ||不但可以操作布尔类型的值，对其他类型的值也可以进行操作，并返回可以决定表达式结果的那个值。 赋值运算符\@赋值运算符 a+=b 等价于 a=a+b 关系运法符 \&lt; \&lt;= >= > == != 相等和不相等 === !== 全等和不全等 注意: 当引用类型的数据和值类型的数据进行运算（+-*/ == > \&lt;）的时候 会调用引用类型数据的valueOf方法，获取返回值，如果这个返回值可以参与运算，那么就直接用了 如果不能参与运算，再去调用该引用类型数据的toString方法,拿这个返回值来参与运算 例 //字面量 //{} //[]//1.只要遇到字面量，必然是在创建对象console.log([] == []);//false console.log({} == {});//false//引用类型的数据和值类型console.log([] == ![]);//调用上述方法后就相当于console.log(“” == false); 运算符的优先级 优先级从高到底 () 优先级最高 一元运算符 ++ – ! 算数运算符 先* / % 后 + - 关系运算符 > >= \&lt; \&lt;= 相等运算符 == != === !== 逻辑运算符 先&amp;&amp; 后|| 值类型和引用类型 值类型：直接存储数据本身的数据，就是值类型的数据 引用类型：存储的是数据的地址，数据单独存储，这种数据就是引用类型的数据 特征: 值类型的数据在赋值的时候，会将存储的数据复制一份交给新的变量，两个变量值相等，但是存储的空间不一样，修改其中一个，另外一个不会受影响 引用类型的数据在赋值的时候，会将对象的地址复制一份交给新的变量，此时两个变量同时指向同一个对象，通过其中一个变量对对象进行修改，另外一个变量也会受到影响 var num = 100; function test(n){ //n = num //值类型的赋值 n = 1000; } test(num); console.log(num);//100 var obj1 = { name:”高富帅”; } function test(obj){ //obj = obj1; //引用类型的赋值 obj.name = “矮穷丑”; } test(obj1); console.log(obj1.name);//矮穷丑 var obj1 = { name:”高富帅” } function test(obj){ obj.name = “矮穷丑” obj = { name : “白富美” } obj.name = “土肥圆”; return obj.name; } console.log(test(obj1));//土肥圆 console.log(obj1.name);//矮穷丑 语句选择语句ifif (condition) { statement1 } else if (condition) { statement2 } else { statement3 } 三元表达式表达式1 ? 表达式2 : 表达式3 选择语句switchswitch (expression) { case value: statement break; case value: statement break; default: statement } 循环语句forfor (initialization; expression; post-loop-expression)｛ statement ｝ initialization表示：初始化表达式 expression表示：控制表达式 post-loop-expression表示：循环后表达式 三者都是可选的 循环语句 for-in &amp; 关键字in的使用 for-in 遍历对象的键 语法 for (var k in obj)｛ console.log(k); ｝ 注意：对象的属性全都是字符串类型的 注意： 在for-in中使用键访问对象的值的时候，不能使用点语法 只能使用中括号 又叫做 关联数组语法 判断对象是否可以访问某个属性 语法： 属性名 in 对象 console.log(“toString” in obj); 返回值： 布尔值，表示能或者不能 break和continuebreak跳出当前循环，执行循环后的语句 continue跳出当前循环，继续执行循环 循环语句whilewhile语句 先判断后执行 while(expression) statement do while 语句 先执行后判断 do {statement} while (expression); 数组数组的声明通过构造函数声明（更加通用） var arr = new Array(“a”, “b”, “c”); 通过字面量声明（更加简便） var arr = [“a”,”b”,”c”]; 数组的赋值和取值赋值 数组名[索引号] = 值 //arr[0]=100 取值（通过数组名和索引即可取到对应的值） 数组名[索引号] //console.log(arr[0]) 数组的遍历数组的索引是从0开始的 数组的长度可以通过arr.length获取 由于数组的索引从0开始，所以最后一个值的索引为arr.length-1 通过for循环遍历数组 for (var i = 0; i \&lt;= arr.length - 1; i++) { console.log(arr[i]); } 可简写为： for (var i = 0; i \&lt; arr.length; i++) { console.log(arr[i]); } \@数组length的应用 往数组中添加新元素，数组的length会增加 通过给arr.length赋值可以改变数组的长度 冒泡排序\@冒泡排序 var arr = [65, 97, 76, 13, 27, 49, 58];//循环控制趟数for (var i = 0; i \&lt; arr.length - 1; i++) {//控制两两比较的次数for (var j = 0; j \&lt; arr.length - 1; j++) {//两两比较 从小到大排序if (arr[j] > arr[j + 1]) {//交换位置var tmp = arr[j];arr[j] = arr[j + 1];arr[j + 1] = tmp;}}} 函数函数的声明和调用函数的声明 function 函数名 () { //函数体 } 函数的调用 函数名(); 函数的参数有参数的函数的声明（声明中的参数只是一个占位符，没有实际的值，是形式参数，即形参） function 函数名 (参数1,参数2,参数3…) { //函数体 } 有参数的函数的调用（调用时传入的参数才是有真正数值的参数，是实际参数，即实参） 函数名(参数1,参数2,参数3…); 函数的返回值在函数中通过return关键字将要返回值返回 return 要返回的值; 函数高级概念\@参数详解 在JS中实参的个数和形参的个数可以不一致 \@返回值详解 函数的返回值是什么，调用这个函数就相当于调用什么，如果没有返回值则为undefined 函数在执行完成return语句后便会退出函数，后面的代码不会执行 \@三种定义方式 函数声明 function fn1() { //函数体 } 函数表达式 var fn2 = function () { //函数体 }; Function Var 函数名= new Function fn1() \@匿名函数 匿名函数（没有名字的函数） 变量 = function () { //函数体 } \@递归调用 程序调用自身的编程技巧称为递归 \@回调函数 函数也是一种普通的数据类型 因此函数也可以被当作参数传递 被当作参数传递的函数叫做回调函数 对象从宏观的角度讲，对象是对客观事物的抽象，事物的特征可以用属性表示，事物的行为可以用方法表示 从微观的角度讲，对象就是一种数据类型，通过对象可以方便地对变量和函数进行管理 初期我们甚至可以把他简单地理解为一个工具箱 键值对键值对就是一种对应关系，通过键能够方便地找到值 键:值 key:value k:v 对象的声明通过构造函数声明（更加通用） var obj= new Object(); 通过字面量声明（更加简便） var obj= {}; 对象具有属性和方法 属性 用来描述对象的特征 一般是名词 对应变量 方法 用来描述对象的行为 一般是动词 对应函数 属性属性的定义 对象.属性名 = 值 属性的调用 对象.属性名 方法方法的定义 对象.方法名 = function(){ //函数体 }; 方法的调用 对象.方法名() 关于this 的指向全局上下文:全局运行上下文中（在任何函数体外部），this 指代全局对象 函数上下文:对象方法中的this指的是该方法所属的对象 直接调用中的this指的是全局对象总之，函数上下文中（在函数内部），this指的是当前函数所属的对象 构造函数中:当一个函数被作为构造函数使用时（前面加new关键字），new关键字会让this的指向改变，并让其成为当前函数的返回值 批量创建对象工厂模式创建对象为什么要优化创建对象的方式 因为对象在项目中被大规模的使用，所以每一点小小的改进都会对项目整体效率带来很大的提升，现阶段同学们还不可能有深刻的体会，只是让大家了解一下，后面讲项目大家自然就明白了。 \@工厂模式创建对象 同类型对象，只是一些属性的值不同，通过对象字面量创建对象每次都要写那么多东西很费劲，我们可以将创建对象的过程封装进一个函数，只把发生变化的属性作为参数传入，从而简化对象创建的过程。 但是工厂模式只是创建出来一个普通的对象并将其返回，因此无法判断实例的具体类型。 构造函数创建对象\@this和new 利用new 关键字可以声明新的对象。new关键字可以让构造函数中this的指向改变，并让构造函数把this返回。 \@构造函数 构造函数也是函数，只不过会默认返回一个对象。 \@构造函数创建对象 通过构造函数创建对象更方便（不需要创建对象并返回）。更重要的是可以通过instanceof来判断实例的类型了。 对象的动态创建对象的动态特性就是指，在对象创建出来之后，可以随时为对象添加成员的这种特性，就是动态特性 语法: 成员：属性和方法 利用对象动态特性给对象添加成员的方式 点语法 对象名.属性名 = 值 关联数组语法 对象名[“属性名”] = 值 案例 obj[[]] = “我是一个怪物！！”; //相当于做了如下操作 //obj[“[object Object]”] = “我是一个怪物！！”; delete关键字语法：delete 变量名/对象.属性名 返回值：boolean类型 表示是否删除成功 不可信！！！ 删除未使用var声明的变量 (使用var的删不掉)a = 10; console.log(delete a); console.log(a); 删除对象的属性var obj = { // name : “郑天杨” // }console.log(delete obj.name);//Object.defineProperty() 表示是否可以删除对象的属性 后面js高级会学 delete删除数组元素delete删除数组元素的时候，数组原本的其他数据的索引不会变化而且数组的长度也不会变化！！只是删除了索引及其对应的值 其他概念对象字面量\@对象字面量 var o = { name : “zs”, age : 18, sayHi : function() { console.log(this.name); } }; 对象标记法\@对象标记法 JavaScript ObjectNotation（JavaScript对象标记法）是仿照JS中对象字面量的格式去书写的一串用来记录对象数据的字符串，可以用于数据传输。将来学习AJAX会详细学习。 访问属性的两种方式\@访问属性的两种方式 点语法（简单） 对象.属性名 中括号（灵活） 对象[“属性名”] 遍历的两种方式\@遍历的两种方式 通过for可以对集合进行有序的遍历 通过forin可以对集合进行有序的遍历 for(var k in obj) { 语句 } k变量代表的是json中的各个属性（key）和 var i = 0中的i是一个意思 名字不同而已 DOM操作增 删 改 查 (下面有详细介绍)增//document.createElement //innerHTML //cloneNode //appendChild //insertBefore 删//innerHTML 改//innerText //setAttibute //style 查//document.getElementById //document.getElementsByTagName //document.getElemnetsByClassName 异常处理异常的最大特征就是，会报错，后面的代码将不会继续执行 语法异常 语法错误导致的异常 浏览器差异导致的异常 运行时异常 异常处理语句try{ //可能会出错的代码 //1.打开了资源 //2.操作资源 }catch (e){ //e 就是异常信息 //出现异常后的处理代码 }finally{ //不管怎么样，有没有异常出现，都会执行的代码 //3.释放资源 } 手动抛出异常//语法： throw anything //catch(e) 这里的e 就会是你throw的这个东西 try{ throw { errMsg:”您的代码出错了！”, errCode:-1 }; }catch (e){ console.log(e); } DOM基本概念DOMDOM Document Object Model 文档对象模型 就是把HTML文档模型化，当作对象来处理 DOM提供的一系列属性和方法可以视作一个工具箱，极大地方便了我们对文档的处理。 内容概念文档(Document)：就是指HTML或者XML文件 节点(Node)：HTML文档中的所有内容都可以称之为节点，常见的节点有 元素节点 属性节点 文本节点 注释节点 元素(Element)：HTML文档中的标签可以称为元素 结构概念父节点 当前节点的父级 子节点 当前节点的子级 兄弟节点 和当前节点同属一个父级的节点 获取元素getElementById 通过id寻找一个元素（找到的是一个元素对象）该方法只能被document对象调用（同一个文档中id不能重复） getElementsByTagName 通过标签名寻找一类元素（找到的是由元素对象组成的伪数组） 即可以被document调用，又可以被元素对象调用，被元素对象调用时表示在该元素对象内部执行查找 设置属性元素对象.属性名 = “属性值”; 等价于 \&lt;标签 属性名=”属性值”> 绑定事件事件三要素 事件源.事件 = function(){ 事件处理程序 }; 等价于 \&lt;标签 事件=”事件处理程序”> 对象方法中的this永远指的是该方法所属的那个对象 常用属性常用标签属性DOM对象的属性和HTML的标签属性几乎是一致的，常用的有src、title、className、href和style 其中className对应就是标签的class属性，但是由于class在JS中是关键字，所以变成了className 内部文本属性innerHTML 获取和设置标签中的内容，设置的内容会当作节点对象被解析到DOM树上 innerText 获取和设置标签中的内容，设置的内容会被当作普通文本（有兼容性问题，旧版ff不支持） textContent 获取和设置标签中的内容，设置的内容会被当作普通文本（有兼容性问题，旧版IE不支持） 可以通过能力检测封装一个自己的设置内部文本的方法并放到自己的JS工具包中 常用表单属性常见的表单元素属性有： type、value、checked、selected、disabled type可以设置input元素的类型 value可以设置input元素的值 checked可以设置input元素是否选中 selected 可以设置下拉列表select中的option是否被选中 disabled 可以设置input元素是否被禁用 文本框获取焦点和失去焦点 获取焦点事件是onfocus 失去焦点事件是onblur (不是所有的标签都有这个事件)更多详细内容可以查阅w3School 自定义属性对象的自定义属性 可以像给对象设置属性一样，给元素对象设置属性 标签的自定义属性 可以通过getAttribute()和setAttribute()设置和获取标签属性，通过removeAttribute()移除标签的属性 正常浏览器中 HTML中有规定的属性 两种方式才可以相互设置和获取 总之用setAttribute设置的就用getAttribute获取用对象的自定义属性设置的就用对象的自定义属性获取 以免出问题 节点节点类型node.nodeType 1表示元素节点 2表示属性节点 3表示文本节点 8注释 节点层次所有获取节点相关属性都没有兼容性问题 childNodes //子节点 children //子元素 虽然不是早期DOM标准中的方法，但是所有浏览器都支持 nextSibling //下一个兄弟节点 nextElementSibling //下一个兄弟元素 有兼容性问题 previousSibling//上一个兄弟节点 previousElementSibling //上一个兄弟元素 有兼容性问题 firstChild //第一个节点 firstElementChild //第一个子元素 有兼容性问题 lastChild //最后一个子节点 lastElementChild //最后一个子元素 有兼容性问题 parentNode //父节点 （一定是元素节点，所以无需处理） 样式属性style属性是对象，style对象的属性是字符串 style只能获取和设置行内样式 DOM对象中style的属性和标签中style内的值几乎一样 只是带有 -的属性名较为特殊（如background-color变成了backgroundColor），因为在JS中 -不能作为标识符 设置和获取样式 //通过对象的style属性只能设置和获取行内样式 //获取样式的时候 如果行内没有该样式 输出空字符串 //设置样式的时候 赋的值是一个字符串 如果这个属性有单位 一定要节点加单位 什么情况通过class控制样式 什么情况通过style控制样式 不严格的说： //如果样式很多 通过 直接控制类名 的方式加样式 //如果样式比较少 通过直接设置比较方便 严格来说： //从标准的角度讲 即使是样式比较少的时候 设置样式也要用类名 //但是有一类情况 是无论如何也必须直接通过JS加的 那就是涉及到计算的时候 动态创建元素插入和移除节点克隆节点 要克隆的节点.cloneNode(布尔值); 在父元素中的最后追加子元素 father.appendChild(要追加的节点对象); 在父元素中的某个子元素前面插入子元素 father.insertBefore(要插入的节点对象,插到这个节点对象的前面); 从父元素中移除子元素 father.removeChild(要移除的子节点对象); 清空父元素 father.innerHTML=””;在清空内容的时候和事件相关的函数不会被销毁，任然遗留在内存中 因此如果方便的话，建议使用father.removeChild(son)来清除 动态创建结构方式一：直接在文档中书写 document.write(“内容”) 方式二：改变元素对象内部的HTML innerHTML=”内容” 方式三：创建或克隆节点并追加 createElement() cloneNode() 通过这两种方法创建出来的元素只是保存在内存中，必须放到页面上才行! 内置方法字符方法 charAt() //获取指定位置处字符 charCodeAt() //获取指定位置处字符的ASCII码 str[0] //ES5，IE8+支持 和charAt()等效 操作方法 concat() //拼接字符串，和+一样 slice() //从start位置开始，截取到end位置，end取不到 substring() //从start位置开始，截取到end位置，end取不到 substr() //从start位置开始，截取length个字符 trim() //只能去除字符串前后的空白 split() //把字符串切割成字符数组 位置方法 indexOf() //返回指定内容在元字符串中的位置, 在数组中的话,返回的是索引 lastIndexOf() //从后往前找，只找第一个匹配的 匹配方法 search() replace() 大小写转换方法 to(Locale)UpperCase() //转换大写 to(Locale)LowerCase() //转换小写 数组方法 图形属性 offset系列offsetWidth和offsetHeight用来得到对象的大小 \@offsetHeight和style.height的区别 demo.style.height只能获取行内样式，如果样式写到了其他地方，甚至根本就没写，便无法获取 style.height是字符串（而且带单位），offsetHeight是数值 demo.style.height可以设置行内样式，offsetHeight是只读属性 因此，一般用demo.offsetHeight来获取某元素的真实宽度/高度，用style.height来设置宽度/高度 \@offsetHeight的构成 offsetHeight = height+padding+border 包括 自身高度 内边距 边框 不包括 外边距 offsetParent\@offsetParent爸爸去哪 返回该对象距离最近的带有定位的父级 如果当前元素的所有父级元素都没有定位（position为absolute或relative），offsetParent为body 如果当前元素的父级元素中有定位（position为absolute或relative），offsetParent取最近的那个父级元素 另外注意offsetParent与parentNode的区别parentNode只找自己的上一级（亲爹） offsetLeft和offsetTop用来得到对象的位置（注意：没有offsetRight和offsetBottom） \@offsetLeft的构成 到距离自身最近的（带有定位的）父元素的 左侧/顶部 的距离 如果所有父级都没有定位则以body 为准 offsetLeft 是自身border左侧到父级padding左侧的距离 \@offsetLeft和style.left的区别 一、style.left只能获取行内样式 二、offsetLeft只读，style.left可读可写 三、offsetLeft是数值，style.left是字符串并且有单位px 四、如果没有加定位，style.left获取的数值可能是无效的 五、最大区别在于offsetLeft以border左上角为基准，style.left以margin左上角为基准 在行内设置以下属性，并且记得加定位 left:20px; margin:20px; 不用死记，offset是计算偏移的，只要记住和定位有关就行了，实在需要详细区分，用的时候自己写个div试一试或者一查文档就知道了。 Math对象\@Math对象常用方法 天花板 向上取整 负数取更大的 Math.ceil(x) 地板 向下取整 负数取更小的 Math.floor(x) 就近取整 rounds a number to the nearest integer 就近取整 有的地方就翻译成四舍五入了 //四舍五入 只看尾数的最高位 01234舍 56789入 //就近取整 会整体比较 以.5为界限 小于的舍 大于的入 等于的 正数入负数舍 //虽然原则不一样但是实际上差别不大 只有一种情况会产生分歧 就是-1.5 //四舍五入是-2 而就近取整-1 Math.round(x) 取绝对值 Math.abs(x) 动画原理动画原理公式动画原理公式： leader = leader + step leader表示盒子当前位置 step表示步长 box.style.left = box.offsetLeft + 10 + “px”; 让setInterval不断执行某个函数修改盒子的位置属性最后就实现了动画的效果 动画函数封装\@动画函数封装 动画函数较为复杂，却又很常用对于这样的函数，我们一般都会进行封装 需求：能够让任意对象移动到指定位置。 动画函数改进\@动画函数改进 然而封装之后的函数还有很多问题，所以我们要对其进行进一步改进 判断运动方向 完善终点检测 终点清除定时器 手动设置对象位置到终点 调用开始先清理定时器，防止多次调用 图形属性scroll系列scroll系列\@scrollHeight和scrollWidth 对象内部实际内容的高度/宽度 \@scrollTop和scrollLeft 被卷去部分的 顶部/左侧 到可视区域 顶部/左侧 的距离 页面滚动座标\@获取页面滚动座标 页面滚动座标非常常用，但是有很大的兼容性问题，可以合写为 var scrollTop = window.pageYOffset || document.documentElement.scrollTop ||document.body.scrollTop || 0; \@封装自己的scroll() 由于非常常用，每次都写上面那一大堆很麻烦。我们可以封装一个自己的scroll()方法，返回页面滚动座标 固定导航案例\@固定导航案例 当页面向下滚动的时候 进行判断 如果页面向上走的距离 大于导航栏到页面顶部的距离时将导航栏的定位改为固定定位 小问题：当导航栏改为固定定位的一瞬间，后面的元素会塌陷。解决方案：给下面的元素添加数值为导航栏高度的padding-top 缓动动画原理公式动画公式 leader = leader + step 匀速动画公式 step = 定值 leader = leader + step 缓动动画公式 step = ( target - leader ) / 10 leader = leader + step 缓动动画的好处 他的移动是有尽头的。不像基础匀速运动那样无限移动。 有非常逼真的缓动效果，实现的动画效果更细腻。 如果不清除定时器，物体永远跟着目标leader在移动。 \@体验缓动动画 函数封装\@缓动动画改进 多次点击按钮重复开启定时器 永远无法真正到达目标 到达目标后清理定时器 \@缓动函数封装 需求：能够让任意对象移动到指定位置 封装缓动框架详细见html代码 图形属性client系列client系列\@clientWidth和clientHeight： 偏移offsetWidth: width + padding + border 卷曲scrollWidth: width + padding 不包含border 内部内容的大小 可视clientWidth: width + padding 不包含border \@clientTop和clientLeft clientTop和clientLeft没什么用 他们就是borderTop和borderLeft（如果有滚动条会包含滚动条的宽度，但谁见过滚动条在顶部或者左侧的？！） 网页可视区宽高\@网页可视区宽高的兼容写法 页面可视区宽高非常常用，但是有很大的兼容性问题，可以合写为 var clientWidth = window.innerWidth|| document.documentElement.clientWidth||document.body.clientWidth|| 0; 事件对象事件： onclick onmouseover onmouseout onfocus onblure 事件对象简介\@事件对象简介 在触发事件时，会产生一个事件对象event，这个对象中包含着与事件有关的信息。 所有浏览器都支持event对象，但支持的方式不同。 比如鼠标操作时候，会添加鼠标位置的相关信息到事件对象中。 普通浏览器支持 传入参数 ie 678 支持 window.event \@事件对象的兼容性写法 var event = event || window.event; 三个重要座标\@三个重要座标 clientX clientY 当前窗口的左上角为基准点 pageX pageY 以当前文档的左上角为基准点 IE678不支持pageX和pageY 但是我们可以采取另一种方式 var pageY = event.pageY || event.clientY +document.documentElement.scrollTop; var pageX = event.pageX || event.clientX +document.documentElement.scrollLeft; screenX screenY 当前屏幕的左上角为基准点 放大镜特效\@计算鼠标在盒子中的位置 制作方法： 鼠标经过显示盒子 鼠标经过small，让mask和big显示；鼠标离开small，让mask和big隐藏。 鼠标经过遮罩跟随 给small绑定鼠标移动事件 获取鼠标在small 内的坐标 计算鼠标在盒子中的座标（鼠标pageX-box到页面左侧的距离；鼠标pageY-box到页面顶部的距离） 然后赋值给mask的top和left（位置是按照左上角算的，所以top值要减去高度的一半，left值要减去宽度的一半） 限定遮罩运动范围 x 最小为0；最大为200，这个200是 small的宽度 -mask的宽度（mask可以向右移动的最大值） 按比例显示大图片 小盒子移动，大盒子要根据比例来移动，比例为： 大图 在 大盒子 里移动的距离 / 小黄 在 小图 里移动的距离 （大图片 - 大盒子 ） / （小盒子 - 小遮罩 ） 800 - 400 / 350 - 175 因为是反方向移动 计算时记得加负号呦！ 可拖拽特效常用事件： onmouseover 鼠标经过 onmouseout 鼠标离开 onmousedown 鼠标按下 onmouseup 鼠标弹起 onmousemove 鼠标移动 \@可拖拽特效 在拖动区域按下鼠标后，在文档中移动鼠标，盒子跟着鼠标坐标走。 鼠标在文档中弹起后，将事件清空。 盒子的位置要进行调整，当鼠标按下时，记录鼠标在盒子中的位置，鼠标移动计算盒子位置的时候减去。 清除选中的内容 window.getSelection ? window.getSelection().removeAllRanges() :document.selection.empty(); 正常浏览器支持：window.getSelection() IE678以下支持：document.selection 注册事件的三种方式element.addEventListener(“事件类型”,”事件处理函数”,”是否使用捕获”) addEventListener的好处是不会将其他事件覆盖，但是有兼容性问题 removeEventListener可以移除指定事件 addEventListener便于管理事件队列 但一般用on的就可以了比较简单 事件的三个阶段1捕获阶段 2目标阶段 执行当前对象的事件处理程序 3冒泡阶段 鼠标事件和键盘事件常用鼠标事件： mousedown、mouseup、mousemove、mouseover、mouseout、click、dblclick onmousedown鼠标按下 onmouseup鼠标弹起 onmouseclick=onmousedown+onmouseup 常用键盘事件： keydown、keypress、keyup onkeydown键盘按下 onkeyup键盘弹起 onkeypress=onkeydown+onkeyup onkeydown onkeyup 输出的是键盘码 onkeypress输出的是ASCII码表 正则表达式正则表达式在网络上有很多资料和工具，用的时候直接在网上搜即可 声明和使用\@正则的声明和使用 通过构造函数定义 var 变量名= new RegExp(/表达式/); 通过直接量定义（简单方便，我们一般用这个） var 变量名= /表达式/; 常用方法，可用于检测传入的字符串是否符合该规则并返回布尔值 exp.test(“要检测的字符串”) 预定义类\@预定义类和转义符 . [\^\n\r] 除了换行和回车之外的任意字符 \d [0-9] 数字字符digit \D [\^0-9] 非数字字符 \w [a-zA-Z0-9_] 单词字符(所有的字母数字和_) word \W [\^a-zA-Z0-9_] 非单词字符 \s [\f\r\n\t\v] 不可见字符 space \S [\^\f\r\n\t\v] 可见字符 转义符 \f 表示换页 form feed \t 表示水平制表符 table \v 表示垂直制表符 vertical table \r,\n,\r\n的区别 在万恶的旧社会，打字机换行（\nnewline）之后只会下移一行，需要回到一行的开头（\r return）才能继续打字 老式的操作系统也继承了打字机的这一特性，但用户换行之后一般都是要回到开头的，因此新式的操作系统为了方便将键盘上的Enter键的含义修改为\r\n或者直接将\n的含义改为“移动到下一行的开头”。 说到转义字符你有没有想起HTML的转义字符呢？（字符实体） \@基本语法补充 | 表示或 或的优先级最低 可以通过()提升优先级 字符类\@字符类 简单类[abc] 表示该位置可以出现的字符 负向类[\^abc] 表示该位置不可以出现的字符 范围类[a-e] 表示该位置可以出现的字符的范围 组合类[a-xA-E0-9] 范围类的组合 \@验证密码强度 边界 量词 括号\@边界 \^ 会匹配行或者字符串的起始位置 \^只有在[]内才表示非 在外边表示开始 \$ 会匹配行或字符串的结尾位置 \^\$在一起 表示必须是这个（精确匹配） \@量词 “*“ 重复零次或更多 x>=0 “+” 重复一次或更多次 x>=1 “?” 重复零次或一次 x=(0||1) {n} n次 x=n {n,} 重复n次或更多 x>=n {n,m} 重复出现的次数比n多但比m少 n\&lt;=x\&lt;=m \@括号总结 ()表示一组 []表示一个字符的位置 {}表示次数 \@验证座机\@验证姓名\@完整版表单验证 常见项目的匹配常见项目的匹配网上有很多（例如搜索常用正则表达式大全），无需记忆，能看懂即可 匹配国内电话号码： /\^0\d{2,3}-\d{7,8}\$/ 匹配姓名： /\^[\u4e00-\u9fa5]{2,}\$/ 匹配腾讯QQ号： /\^[1-9]\d{4,10}\$/ 匹配手机号： /\^(13[0-9]|14[57]|15[0-9]|18[0-9])\d{8}\$/ 匹配邮箱： /\^\w+([+-.]\w+)*\@\w+([-.]\w+)*\.\w+([-.]\w+)*\$/ 面向对象( 思维方式 )以洗衣服为例 面向过程的思维方式： 把解决问题的关注点放在了解决问题的每一个详细步骤(过程)上 1.收集脏衣服 2.把脏衣服扔到洗衣机中 3.设定洗衣程序 4.开始洗衣服 5.拿出衣服晾晒 面向对象的思维方式： 把解决问题的关注点放在了解决问题所需要的一些列的对象上 1.女朋友 2.洗衣机 什么是对象 万物皆对象 js中的对象是什么？ 无序的键值对儿的集合]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F02%2F05%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
