<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[canvas基础总结]]></title>
      <url>%2F2017%2F01%2F24%2Fcanvas%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[基本篇什么是 Canvascanvas 是 HTML5 提供的一个用于展示绘图效果的标签. canvas 原意画布, 帆布. 在 HTML 页面中用于展示绘图效果. 最早 canvas 是苹果提出的一个方案, 今天已经在大多数浏览器中实现. 1canvas 英 [&apos;kænvəs] 美 [&apos;kænvəs] 帆布 画布 canvas 的基本用法基本语法 1&lt;canvas&gt;&lt;/canvas&gt; 使用 canvas 标签, 即可在页面中开辟一格区域. 可以设置其 width 和 height 设置该区域的尺寸. 默认 canvas 的宽高为 300 和 150. 不要使用 CSS 的方式设置宽高, 应该使用 HTML 属性. 如果浏览器不支持 canvas 标签, 那么就会将其解释为 div 标签. 因此常常在 canvas 中嵌入文本, 以提示用户浏览器的能力. canvas 的兼容性非常强, 只要支持该标签的, 基本功能都一样, 因此不用考虑兼容性问题. canvas 本身不能绘图. 是使用 JavaScript 来完成绘图. canvas 对象提供了各种绘图用的 api. canvas 的使用领域 canvas 的使用领域很多: 游戏 可视化数据(重点) banner 广告 多媒体 未来 模拟仿真 远程操作 图形编辑 我们的课程目标 不是为了做游戏 学会使用基本的 canvas api, 使用 canvas 可以完成简单的绘图 实现数据的可视化 基本绘图基本绘图方法绘图步骤 获得 canvas 对象. 调用 getContext 方法, 提供字符串参数 &#39;2d&#39;. 该方法返回 CanvasRenderingContext2D 类型的对象. 该对象提供基本的绘图命令. 使用 CanvasRenderingContext2D 对象提供的方法进行绘图. 基本绘图命令 设置开始绘图的位置: context.moveTo( x, y ). 设置直线到的位置: context.lineTo( x, y ). 描边绘制: context.stroke(). 填充绘制: context.fill(). 闭合路径: context.closePath(). 01-绘制基本线 1234567891011121314151617var canvas = document.createElement( &apos;canvas&apos; );canvas.width = 500;canvas.height = 400;canvas.style.border = &apos;1px dashed red&apos;;document.body.appendChild( canvas );// 获得 CanvasRenderingContext2D 对象var context = canvas.getContext( &apos;2d&apos; );// 设置 起点context.moveTo( 0, 0 );// 绘制直线context.lineTo( 500, 400 );// 设置 起点context.moveTo( 0, 400 );// 绘制直线context.lineTo( 500, 0 );// 描边显示效果context.stroke(); 运行结果为 计算机直角坐标系 代码分析 需要绘图就需要有 canvas 标签, 该标签用于展示图像. canvas 的宽高不要使用 CSS 来设置, 会有拉伸的问题. 应该直接使用属性设置. 但是 canvas 只是展示图像的标签, 它没有绘图的能力. 需要使用 canvas 的上下文工具来实现绘图. 使用 canvas.getContext( &#39;2d&#39; ) 可以获得绘图工具, 该工具是 CanvasRenderingContext2D 类型的对象. 需要绘图, 首选设置绘图的起点. 使用 canvas 绘图, 需要主要的是他主张先描点, 再连线绘制效果. 因此需要首先设置起点, 然后在起点的基础上描述其他需要的点. 使用 CanvasRenderingContext2D.moveTo( x, y ) 方法设置起点. 其中 x, y 表示的是在坐标系中的位置. 使用 CanvasRenderingContext2D.lineTo( x, y ) 来描述绘制直线的下一个点. 依次类推可以描述多个点. 描点结束后, 需要使用 CanvasRenderingContext2D.stroke() 方法来连线. 开可以显示出效果. getContext 方法语法: Canvas.getContext( typeStr ) 描述: 该方法用于绘制上下文工具. 如果是绘制平面图形使用 &#39;2d&#39; 作为参数, 如果绘制立体图形使用 &#39;webgl&#39;. 使用 &#39;2d&#39; 返回 CanvasRenderingContext2D 类型的对象. 使用 &#39;webgl&#39; 返回 WebGLRenderingContext 类型的对象. moveTo 方法语法: CanvasRenderingContext2D.moveTo( x, y ) 描述: 该方法用于设置绘制起点. 其中参数 x, y 表示在坐标系中的位置, 分别是 x 坐标与 y 坐标. lineTo 方法语法: CanvasRenderingContext2D.lineTo( x, y ) 描述: 该方法用于设置需要绘制直线的另一个点. 最终描边后会连线当前点和方法参数描述的点. 其中参数 x, y 表示在坐标系中的位置, 分别是 x 坐标与 y 坐标. stroke 方法语法: CanvasRenderingContext2D.stroke() 描述: 该方法用于连线, 将描述的所有点按照指定顺序连接起来. 结论 绘图先要获得上下文, 即绘图工具 绘图需要设置开始的坐标 绘图是先描点, 然后一个一个依次连线 依次绘图只能绘制单一样式( 色彩等 ) 直线图形分别绘制下面的案例: 绘制直线计算坐标. 描边调用 CanvasRenderingContext2D.stroke() 方法. 填充使用 CanvasRenderingContext2D.fill() 方法. fill 方法语法: CanvasRenderingContext2D.fill() 描述: 该方法会按照描绘的点的路径来填充图形. 默认是黑色. 非零环绕原则绘制下面的图 填充满足非零环绕数原则 说明: 在 canvas 中使用各种方法描点实际上描述的是一个称为路径( path )的东西. 在 canvas 绘图中, 所有描述的东西都是路径, 只有最后填充或描边的时候才会显示出效果. 每一个路径都是一个状态. 练习: 绘制下面图形 闭合路径closePath 方法语法: CanvasRenderingContext2D.closePath() 描述: 使用该方法可以将最后一个描点与最开始的描点自动连接起来. 案例 123456...ctx.moveTo( 100, 100 );ctx.lineTo( 300, 100 );ctx.lineTo( 300, 200 );ctx.closePath();ctx.stroke(); 结果为: 练习: 使用 closePath 改写非零环绕的案例. 路径的概念 路径就是一次绘图 类比使用油漆刷墙面 首先打底色, 绝对不会一次性使用多个色彩 一定是先画完某一个色彩再考虑另一个色彩 除非需要自己创作才会考虑墙面绘画 路径就好比一桶油漆和一把刷子, 一次性描点绘制. 如果重新更换油漆, 那么是绘制另一个区域. 如果需要开启新的绘制, 那么使用 CanvasRenderingContext2D.beginPath() 方法. 墙面油漆图示 示例 如果需要在一个区域内绘制描边的图形和填充的图形. 例如 线型相关属性设置描边与填充不一定只能使用黑色的细线. 可以利用一些属性设置其效果 CanvasRenderingContext2D.lineWidth 设置线宽. CanvasRenderingContext2D.lineCap 设置线末端类型. CanvasRenderingContext2D.lineJoin 设置相交线的拐点. CanvasRenderingContext2D.getLineDash() 获得线段样式数组. CanvasRenderingContext2D.setLineDash() 设置线段样式. CanvasRenderingContext2D.lineDashOffset 绘制线段偏移量. 设置线宽语法: CanvasRenderingContext2D.lineWidth = number 描述: 设置线宽. 案例 12345678910...ctx.moveTo( 100, 100 );ctx.lineTo( 300, 100 );ctx.stroke();ctx.beginPath();ctx.lineWidth = 10;ctx.moveTo( 100, 250 );ctx.lineTo( 300, 250 );ctx.stroke(); 效果 设置线末端类型语法: CanvasRenderingContext2D.lineCap = value 描述: 设置线型末端的样式, 可取值为: ‘butt’( 默认 ), ‘round’, ‘square’. ‘butt’ 表示两端使用方形结束. ‘round’ 表示两端使用圆角结束. ‘square’ 表示突出的圆角结束. 案例 1234567891011121314151617...ctx.lineWidth = 10;ctx.moveTo( 100, 100 );ctx.lineTo( 300, 100 );ctx.stroke();ctx.beginPath();ctx.lineCap = &apos;round&apos;;ctx.moveTo( 100, 130 );ctx.lineTo( 300, 130 );ctx.stroke();ctx.beginPath();ctx.lineCap = &apos;square&apos;;ctx.moveTo( 100, 160 );ctx.lineTo( 300, 160 );ctx.stroke(); 效果 设置相交线的拐点语法: CanvasRenderingContext2D.lineJoin = value 描述: 设置两条直线的拐点描述方式. 可以取值 ‘round’, ‘bevel’, ‘miter’(默认) ‘round’ 使用圆角连接. ‘bevel’ 使用平切连接. ‘miter’ 使用直角转. 案例 123456789101112131415161718192021...ctx.lineWidth = 10;ctx.lineJoin = &apos;round&apos;;ctx.moveTo( 100, 100 );ctx.lineTo( 200, 200 );ctx.lineTo( 300, 100 );ctx.stroke();ctx.beginPath();ctx.lineJoin = &apos;bevel&apos;;ctx.moveTo( 100, 150 );ctx.lineTo( 200, 250 );ctx.lineTo( 300, 150 );ctx.stroke();ctx.beginPath();ctx.lineJoin = &apos;miter&apos;;ctx.moveTo( 100, 200 );ctx.lineTo( 200, 300 );ctx.lineTo( 300, 200 );ctx.stroke(); 效果 虚线语法: CanvasRenderingContext2D.lineDashOffset = number CanvasRenderingContext2D.getLineDash() CanvasRenderingContext2D.setLineDash() 描述: lineDashOffset用于设置开始绘制虚线的偏移量. 数字的正负表示左右偏移. getLineDash() 与 setLineDash() 方法使用数组描述实线与虚线的长度. 演示 123456789101112131415161718192021222324252627282930313233...ctx.moveTo( 100, 90 );ctx.lineTo( 100, 110 );ctx.moveTo( 300, 90 );ctx.lineTo( 300, 110 );ctx.moveTo( 100, 140 );ctx.lineTo( 100, 160 );ctx.moveTo( 300, 140 );ctx.lineTo( 300, 160 );ctx.moveTo( 100, 190 );ctx.lineTo( 100, 210 );ctx.moveTo( 300, 190 );ctx.lineTo( 300, 210 );ctx.stroke();ctx.beginPath();ctx.moveTo( 100, 100 );ctx.lineTo( 300, 100 );ctx.stroke();ctx.beginPath();ctx.setLineDash( [ 5, 5 ] );ctx.moveTo( 100, 150 );ctx.lineTo( 300, 150 );ctx.stroke();ctx.beginPath();ctx.lineDashOffset = -2;ctx.moveTo( 100, 200 );ctx.lineTo( 300, 200 );ctx.stroke(); 效果 填充与描边样式语法: CanvasRenderingContext2D.strokeStyle = value CanvasRenderingContext2D.fillStyle = value 描述: strokeStyle 可以设置描边颜色, 与 CSS 的语法一样 fillStyle 设置填充颜色, 与 CSS 语法一样 这两个属性还可以设置渐变对象. 案例 123456789for (var i=0;i&lt;6;i++)&#123; for (var j=0;j&lt;6;j++)&#123; ctx.strokeStyle = &apos;rgb(0,&apos; + Math.floor(255-42.5*i) + &apos;,&apos; + Math.floor(255-42.5*j) + &apos;)&apos;; ctx.beginPath(); ctx.arc(12.5+j*25,12.5+i*25,10,0,Math.PI*2,true); ctx.stroke(); &#125;&#125; 效果 实例练习绘制坐标网格绘制下面的效果 绘制坐标系绘制下面的效果 绘制坐标点绘制下面的效果 绘制折线图 中级篇绘制形状绘制图形不仅仅是利用线条来实现绘图, 还可以有快捷的绘制图形的办法 绘制矩形 绘制圆弧 绘制矩形绘制矩形的方法 CanvasRenderingContext2D.strokeRect CanvasRenderingContext2D.fillRect CanvasRenderingContext2D.rect 注意: rect 方法就是矩形路径, 还需要使用 fill 或 stroke 才可以看到效果. 因此一般使用 strokeRect 或 fillRect 直接可以看到结果. 清除矩形区域 CanvasRenderingContext2D.clearRect 绘制矩形框语法: CanvasRenderingContext2D.strokeRect( x, y, width. height ) 描述: 用来绘制一个矩形. 比起直接使用 moveTo 和 lineTo 方法要简单许多. 该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高. 使用该方法不需要使用 moveTo 方法设置起始点, 也不需要调用 stroke 等绘画方法. 绘制的矩形支持 strokeStyle 设置颜色样式. 案例 123...ctx.strokeStyle = &apos;red&apos;;ctx.strokeRect( 100, 100, 200, 100 ); 效果 绘制填充矩形语法: CanvasRenderingContext2D.fillRect( x, y, width. height ) 描述: 用来绘制一个矩形. 比起直接使用 moveTo 和 lineTo 方法要简单许多. 该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高. 使用该方法不需要使用 moveTo 方法设置起始点, 也不需要调用 stroke 等绘画方法. 绘制的矩形支持 fillStyle 设置颜色样式. 案例 123...ctx.fillStyle = &apos;green&apos;;ctx.fillRect( 100, 100, 200, 100 ); 效果 清除矩形区域语法: CanvasRenderingContext2D.clearRect( x, y, width, height ) 描述: 用于清除画布中的矩形区域的内容. 参数 x, y 表示矩形区域左上角的坐标, width 与 height 表示矩形区域的宽高. 案例 123...ctx.fillRect( 100, 100, 200, 100 );ctx.clearRect( 110, 110, 50, 50 ); 效果 案例利用绘制图形与清除矩形区域, 可以实现简单的动画. 例如代码: 12345678910111213141516171819...var x = 10, y = 10, oldx = 10, oldy = 10;var width = 100, height = 50; var intervalId = setInterval(function () &#123; ctx.clearRect( oldx - 1, oldy - 1, width + 2, height + 2 ); ctx.strokeRect( x, y, width, height ); oldx = x; oldy = y; x += 4; y += 2; if ( oldy &gt;= 200 ) &#123; // clearInterval( intervalId ); x = 10, y = 10; &#125;&#125;, 20); 简单效果 有时为了简单常常将整个画布都清除, 这样就不用每次计算清除的问题. 123ctx.clearRect( 0, 0, cas.width, cas.height );// 也可以设置画布宽度, 这样就会自动清除cas.width = cas.width; 绘制圆弧绘制圆弧的方法有 CanvasRenderingContext2D.arc() CanvasRenderingContext2D.arcTo() 绘制圆弧语法: CanvasRenderingContext2D.arc( x, y, radius. startAngle. endAngle, anticlockwise ) 描述: 该方法用于绘制一段弧, 配合开始点的位置 与 stroke 方法或 fill 方法可以绘制扇形. 方法中的前两个参数 x, y 表示绘制圆弧的圆心坐标. 参数 radius 表示圆弧半径, 单位为弧度. 参数 startAngle 与 endAngle 表示开始到结束的角度. 角度以水平向右为 0 弧度, 顺时针为正方向. 参数 anticlockwise 表示是否采用默认的正向角度, 如果传入 true 表示逆指针为正. 该参数可选. 案例 123456789101112131415161718// 在 200, 200 的地方绘制一段半径为 100 的圆弧, 圆心角为 - PI / 2 到 PI / 4...ctx.arc( 200, 200, 100, -Math.PI/2, Math.PI/4 );ctx.stroke();// 为了方便看清楚结构, 绘制坐标轴ctx.beginPath();ctx.strokeStyle = &apos;red&apos;;ctx.moveTo( 50, 200 );ctx.lineTo( 350, 200 );ctx.moveTo( 200, 50 );ctx.lineTo( 200, 350 );ctx.moveTo( 200, 200 );ctx.lineTo( 300, 300 );ctx.stroke(); 效果 注意事项 使用 arc 绘图的时候, 如果没有设置 moveTo 那么会从开始的绘弧的地方作为起始点. 如果设置了 moveTo, 那么会连线该点与圆弧的起点. 如果使用 stroke 方法, 那么会从开始连线到圆弧的起始位置. 如果是 fill 方法, 会自动闭合路径填充. 例如 绘制扇形绘制扇形的重点是需要设置起始位置为圆心点, 然后闭合路径即可 1234567891011121314...ctx.strokeStyle = &apos;red&apos;;ctx.fillStyle = &apos;pink&apos;;ctx.moveTo( 100, 200 );ctx.arc( 100, 200, 100, -Math.PI/3, Math.PI/3 );ctx.closePath();ctx.stroke();ctx.beginPath();ctx.moveTo( 300, 200 );ctx.arc( 300, 200, 100, -Math.PI/3, Math.PI/3 );ctx.closePath();ctx.fill(); 效果 绘制扇形动画绘制扇形动画, 就是每隔几毫秒( 20 毫秒)擦除以前绘制的内容, 然后在以前绘制的基础上比以前多绘制一点东西. 这里多绘制的内容就是由角度决定. 比如一开始角度从 -Math.PI / 2 开始绘制. 那么每次角度都 +0.1, 直到 绘制到 Math.PI * 3 / 2 为止. 12345678910111213141516171819202122...ctx.fillStyle = &apos;green&apos;;var startAngle = -Math.PI / 2, angle = startAngle, x = 200, y = 200, r = 100;var intervalId = setInterval(function () &#123; // 清除之前绘制的内容 ctx.clearRect( 0, 0, cas.width, cas.height ); // 角度增量 angle += 0.1; // 判断是否停止计时器 if ( angle &gt;= Math.PI * 3 / 2 ) &#123; clearInterval( intervalId); angle = Math.PI * 3 / 2; console.log( &apos;绘制完成&apos; ); &#125; // 绘制 ctx.moveTo( x, y ); ctx.arc( x, y, r, startAngle, angle ); ctx.fill();&#125;, 20); 效果 绘制饼形图绘制饼形图最大的特点是角度是叠加的. 开始从 -Math.PI/2 开始绘制, 达到执行角 x 后, 下一个区域从 x 开始绘制, 然后有到一个角 y 停下来. 如此反复到 Math.PI * 3 / 2 结束. 本节看两个案例, 一个固定等分, 一个由数据源来定义角度. 三等分饼形图绘制一个三等分的饼形图, 颜色使用 红, 绿, 蓝. 12345678910111213var x = 200, y = 200, r = 100, step = Math.PI * 2 / 3, // 120 度一个区域 start = -Math.PI / 2, // 起始角度 colors = [ &apos;red&apos;, &apos;green&apos;, &apos;blue&apos; ];for ( var i = 0; i &lt; 3; i++ ) &#123; ctx.beginPath(); ctx.moveTo( x, y ); ctx.fillStyle = colors[ i ]; ctx.arc( x, y, r, start, start+=step ); ctx.fill();&#125; 效果 根据数据定义角度根据数据源定义角度, 就是将所有的数据求和, 按照总和为 2 * Math.PI 的结论计算出每一个数据部分的弧度值. 同时颜色可以提前定义好. 从 Konva 库中分离出来的颜色 1234567891011121314151617var colors = ( &quot;aliceblue,antiquewhite,aqua,aquamarine,azure,beige,bisque,black,blanchedalmond,blue,&quot; + &quot;blueviolet,brown,burlywood,cadetblue,chartreuse,chocolate,coral,cornflowerblue,cornsilk,&quot; + &quot;crimson,cyan,darkblue,darkcyan,darkgoldenrod,darkgray,darkgreen,darkgrey,darkkhaki,darkmagenta,&quot; + &quot;darkolivegreen,darkorange,darkorchid,darkred,darksalmon,darkseagreen,darkslateblue,darkslategray,&quot; + &quot;darkslategrey,darkturquoise,darkviolet,deeppink,deepskyblue,dimgray,dimgrey,dodgerblue,firebrick,&quot; + &quot;floralwhite,forestgreen,fuchsia,gainsboro,ghostwhite,gold,goldenrod,gray,green,greenyellow,grey,&quot; + &quot;honeydew,hotpink,indianred,indigo,ivory,khaki,lavender,lavenderblush,lawngreen,lemonchiffon,&quot; + &quot;lightblue,lightcoral,lightcyan,lightgoldenrodyellow,lightgray,lightgreen,lightgrey,lightpink,&quot; + &quot;lightsalmon,lightseagreen,lightskyblue,lightslategray,lightslategrey,lightsteelblue,lightyellow,&quot; + &quot;lime,limegreen,linen,magenta,maroon,mediumaquamarine,mediumblue,mediumorchid,mediumpurple,&quot; + &quot;mediumseagreen,mediumslateblue,mediumspringgreen,mediumturquoise,mediumvioletred,midnightblue,&quot; + &quot;mintcream,mistyrose,moccasin,navajowhite,navy,oldlace,olive,olivedrab,orange,orangered,orchid,&quot; + &quot;palegoldenrod,palegreen,paleturquoise,palevioletred,papayawhip,peachpuff,peru,pink,plum,powderblue,&quot; + &quot;purple,rebeccapurple,red,rosybrown,royalblue,saddlebrown,salmon,sandybrown,seagreen,seashell,sienna,&quot; + &quot;silver,skyblue,slateblue,slategray,slategrey,snow,springgreen,steelblue,tan,teal,thistle,transparent,&quot; + &quot;tomato,turquoise,violet,wheat,white,whitesmoke,yellow,yellowgreen&quot; ).split( &apos;,&apos; ); 如果得到数据 1var data = [ 123, 156, 47, 100, 80 ]; 那么计算各个部分的比例时, 可以构造一个存储分量值与弧度的对象数组. 12345678var sum = 0;for ( var i = 0; i &lt; data.length; i++ ) &#123; sum += data[ i ];&#125;// 得到总数后, 分量比就有了var odata = data.map(function ( v, i ) &#123; return &#123; value: v, radius: v * 2 * Math.PI / sum &#125;;&#125;); 最后根据数据开始绘图 123456789101112// 开始绘图var start = -Math.PI / 2, x = 200, y = 200, r = 100;for ( var i = 0; i &lt; odata.length; i++ ) &#123; ctx.beginPath(); ctx.fillStyle = colors[ i + 10 ]; ctx.moveTo( x, y ); ctx.arc( x, y, r, start, start+=odata[ i ][ &apos;radius&apos; ] ); ctx.fill();&#125; 效果 绘制相切弧语法: CanvasRenderingContext2D.arcTo( x1, y1, x2, y2, radius ) 描述: 该方法用于绘制圆弧 绘制的规则是当前位置与第一个参考点连线, 绘制的弧与该直线相切. 同时连接两个参考点, 圆弧根据半径与该连线相切 例如有一个起始点 ( 100, 100 ), 那么绘制其点. 颜色设置为红色. 12ctx.fillStyle = &apos;red&apos;;ctx.fillRect( 100 - 4, 100 - 4, 8, 8 ); 然后两个参考点分别为 ( 100, 300 ) 和 ( 300, 300 ), 绘制出该点 12ctx.fillRect( 100 - 4, 300 - 4, 8, 8 );ctx.fillRect( 300 - 4, 300 - 4, 8, 8 ); 连接两个参考点 12345ctx.beginPath();ctx.strokeStyle = &apos;red&apos;;ctx.moveTo( 100, 300 );ctx.lineTo( 300, 300 );ctx.stroke(); 得到效果为 调用 arcTo 方法绘制圆弧. 记得将起始点设置为 ( 100, 100 ) 123456ctx.beginPath();ctx.strokeStyle = &apos;blue&apos;;ctx.moveTo( 100, 100 );ctx.arcTo( 100, 300, 300, 300, 100 );ctx.stroke(); 得到效果 注意: 使用该方法可以使用圆弧连接两条直线, 而不用计算复杂的起始角度与结束角度. 因此用于绘制圆角矩形等案例较多. 绘制圆角矩形封装一个函数, 用于绘制圆角矩形. 参考 rect 方法, 需要坐标参数 x, y. 由于设置圆角, 因此需要设置圆角半径 cornerRadius. 还需要提供宽高. 首先绘制一个矩形边框. 但是需要考虑圆角, 虽然从 x, y 开始绘制, 但是中间要空出 半径的距离. 1234567891011121314151617var x = 100, y = 100, width = 300, height = 100, cornerRadius = 10;ctx.strokeStyle = &apos;red&apos;;ctx.moveTo( x + cornerRadius, y );ctx.lineTo( x + width - cornerRadius, y );ctx.moveTo( x + width, y + cornerRadius );ctx.lineTo( x + width, y + height - cornerRadius );ctx.moveTo( x + width - cornerRadius, y + height );ctx.lineTo( x + cornerRadius, y + height );ctx.moveTo( x, y + height - cornerRadius );ctx.lineTo( x, y + cornerRadius );ctx.stroke(); 效果为 然后再分别绘制四个角, 设置当前位置与参考点的位置. 设置当前位置为一个线端点, 然后参考点依次就是 矩形顶点 和 另一个线段的端点. 12ctx.moveTo( x + cornerRadius, y );ctx.arcTo( x, y, x, y + cornerRadius, cornerRadius ); 即可得到 同理绘制另外三个圆角 12345678ctx.moveTo( x + width - cornerRadius, y );ctx.arcTo( x + width, y, x + width, y + cornerRadius, cornerRadius );ctx.moveTo( x + width, y + height - cornerRadius );ctx.arcTo( x + width, y + height, x + width - cornerRadius, y + height, cornerRadius );ctx.moveTo( x + cornerRadius, y + height );ctx.arcTo( x, y + height, x, y + height - cornerRadius, cornerRadius ); 即可得到 封装成方法就可以绘制更多圆角矩形了. 封装中注意 beginPath() 和 save() 和 restore() 123456789101112131415161718192021222324252627282930313233function cRect ( x, y, width, height, cornerRadius, color ) &#123; ctx.save(); ctx.beginPath(); ctx.strokeStyle = color || &apos;red&apos;; ctx.moveTo( x + cornerRadius, y ); ctx.lineTo( x + width - cornerRadius, y ); ctx.moveTo( x + width, y + cornerRadius ); ctx.lineTo( x + width, y + height - cornerRadius ); ctx.moveTo( x + width - cornerRadius, y + height ); ctx.lineTo( x + cornerRadius, y + height ); ctx.moveTo( x, y + height - cornerRadius ); ctx.lineTo( x, y + cornerRadius ); // 开始绘制四个圆角 ctx.moveTo( x + cornerRadius, y ); ctx.arcTo( x, y, x, y + cornerRadius, cornerRadius ); ctx.moveTo( x + width - cornerRadius, y ); ctx.arcTo( x + width, y, x + width, y + cornerRadius, cornerRadius ); ctx.moveTo( x + width, y + height - cornerRadius ); ctx.arcTo( x + width, y + height, x + width - cornerRadius, y + height, cornerRadius ); ctx.moveTo( x + cornerRadius, y + height ); ctx.arcTo( x, y + height, x, y + height - cornerRadius, cornerRadius ); ctx.stroke(); ctx.restore();&#125; 调用代码 123cRect( 50, 50, 100, 50, 5 );cRect( 100, 120, 100, 80, 8, &apos;blue&apos; );cRect( 300, 100, 200, 100, 10, &apos;green&apos; ); 得到结果为 绘制文本绘制文本的方法 CanvasRenderingContext2D.fillText() CanvasRenderingContext2D.strokeText() CanvasRenderingContext2D.measureText() 文本样式 CanvasRenderingContext2D.font CanvasRenderingContext2D.textAlign CanvasRenderingContext2D.textBaseline 绘制文字语法: CanvasRenderingContext2D.strokeText( text, x, y[, maxWidth] ) CanvasRenderingContext2D.fillText( text, x, y[, maxWidth] ) 描述: 这两个方法的功能都是在给定的 x, y 坐标下绘制文本内容. stroke 绘制描边文字, 文字内空心. fill 绘制填充文字, 即实心文字. 最后一个参数可选, 用于限制文字的总宽. 特殊条件下, 系统会自动调整文字宽度与大小以适应该参数限制. 案例 123456...ctx.strokeRect( 100, 100, 200, 50 );ctx.strokeText( &apos;Hello PM&apos;, 100, 100 );ctx.strokeRect( 100, 200, 200, 50 );ctx.fillText( &apos;Hello PM&apos;, 100, 200 ); 效果 注意: 第一个文字由于中间空心, 所以文字相当于双线显示. 就显得较粗. 根据绘制的矩形块可以发现文字几乎使用该点作为文字基线参考. 计算文本尺寸语法: CanvasRenderingContext2D.measureText() 描述: 该方法返回一个文本尺寸对象, TextMetrics 对象. TextMetrics 对象属性很多, 常用的 width 属性可以获取文字的宽度. 设置文字属性设置文字字体语法: CanvasRenderingContext2D.font = value 描述: 该属性用于设置绘制字体的各种信息, 与 CSS 语法一致, 设置字体形状, 样式, 字号粗细等. 其顺序可以是: style | variant | weight | size/line-height | family. 默认值为 10px sans-serif 修改字号后查看 strokeText 与 fillText 的区别 1234567...ctx.font = &apos;50px 黑体&apos;;ctx.strokeRect( 100, 100, 200, 50 );ctx.strokeText( &apos;Hello PM&apos;, 100, 100 );ctx.strokeRect( 100, 200, 200, 50 );ctx.fillText( &apos;Hello PM&apos;, 100, 200 ); 效果 设置字体水平对齐方式语法: CanvasRenderingContext2D.textAlign = value 描述: 该属性用于设置文字的水平对齐方式. 设置文字居中, 靠左右对齐等. 该属性可以设置的值有: start( 默认 ), end, left, right, center. start 表示根据参考基准点的垂直直线左靠对齐 1234567891011...ctx.moveTo( 150, 100 );ctx.lineTo( 150, 200 );ctx.moveTo( 100, 150 );ctx.lineTo( 200, 150 );ctx.strokeStyle = &apos;red&apos;;ctx.stroke();ctx.font = &apos;30px 黑体&apos;;ctx.textAlign = &apos;start&apos;; // 默认ctx.fillText( &apos;测试文字&apos;, 150, 150 ); 效果 end 表示根据参考基准点的垂直直线右靠对齐 1234...ctx.font = &apos;30px 黑体&apos;;ctx.textAlign = &apos;end&apos;;ctx.fillText( &apos;测试文字&apos;, 150, 150 ); 效果 left 与 right 就是左对齐与右对齐的意思 123456...ctx.font = &apos;30px 黑体&apos;;ctx.textAlign = &apos;left&apos;;ctx.fillText( &apos;left&apos;, 150, 150 );ctx.textAlign = &apos;right&apos;ctx.fillText( &apos;right&apos;, 150, 150 ); 效果 最后 center 就是居中的含义. 123ctx.font = &apos;50px 黑体&apos;ctx.textAlign = &apos;center&apos;;ctx.fillText( &apos;00000&apos;, 150, 150 ); 效果 设置字体垂直对齐方式语法: CanvasRenderingContext2D.textBaseline = value 描述: 该方法设置文字在垂直方向上的对齐方式. 该属性可以取值: top, middle, bottom, hanging, alphabetic, ideographic 基于参考点的直线, 其中 top, middle, buttom 分别表示靠上, 居中, 靠下对齐. alphabetic 表示字母基线, 类似于英文字母的对齐方式. 例如 a, g, f 等字母. ideographic 表意对齐. 使用字母对齐中超出的字母为参考. 即比字母基线略靠下. 所有的对齐方式是根据文字特点相关的. 对于中文主要使用的还是 top, bottom 和 middle. top, middle, bottom 使用的较多 1234567891011121314151617181920212223242526272829303132333435...// ------------------ctx.moveTo( 100, 80 );ctx.lineTo( 500, 80 );ctx.strokeStyle = &apos;red&apos;;ctx.stroke();ctx.font = &apos;30px 黑体&apos;;ctx.textBaseline = &apos;top&apos;;ctx.fillText( &apos;abfghijklpqrty&apos;, 150, 80 );// ------------------ctx.translate( 0, 100 );ctx.moveTo( 100, 80 );ctx.lineTo( 500, 80 );ctx.strokeStyle = &apos;red&apos;;ctx.stroke();ctx.font = &apos;30px 黑体&apos;;ctx.textBaseline = &apos;bottom&apos;;ctx.fillText( &apos;abfghijklpqrty&apos;, 150, 80 );// ------------------ctx.translate( 0, 100 );ctx.moveTo( 100, 80 );ctx.lineTo( 500, 80 );ctx.strokeStyle = &apos;red&apos;;ctx.stroke();ctx.font = &apos;30px 黑体&apos;;ctx.textBaseline = &apos;middle&apos;;ctx.fillText( &apos;abfghijklpqrty&apos;, 150, 80 ); 效果 alphabetic 表示字母参考线, ideographic 会比它低一点, hanging 表示悬挂. 1234567891011121314151617181920212223242526272829303132333435ctx.moveTo( 100, 80 );ctx.lineTo( 500, 80 );ctx.strokeStyle = &apos;red&apos;;ctx.stroke();ctx.font = &apos;30px 黑体&apos;;ctx.textBaseline = &apos;alphabetic&apos;;ctx.fillText( &apos;abfghijklpqrty&apos;, 150, 80 ); // -------------------------------------------------ctx.translate( 0, 100 );ctx.moveTo( 100, 80 );ctx.lineTo( 500, 80 );ctx.strokeStyle = &apos;red&apos;;ctx.stroke();ctx.font = &apos;30px 黑体&apos;;ctx.textBaseline = &apos;ideographic&apos;;ctx.fillText( &apos;abfghijklpqrty&apos;, 150, 80 ); // -------------------------------------------------ctx.translate( 0, 100 );ctx.moveTo( 100, 80 );ctx.lineTo( 500, 80 );ctx.strokeStyle = &apos;red&apos;;ctx.stroke();ctx.font = &apos;30px 黑体&apos;;ctx.textBaseline = &apos;hanging&apos;;ctx.fillText( &apos;abfghijklpqrty&apos;, 150, 80 ); 效果 实际上大多数参考方式只有在特定语言中有作用, 而且与字体也有相对复杂的关系. 例如( 下图是有部分错误的 ): 绘制图片绘制图像虽然只有一个 drawImage 函数, 但是该函数有多重参数形式. CanvasRenderingContext2D.drawImage( img, dx, dy ). CanvasRenderingContext2D.drawImage( img, dx, dy, dWidth, dHeight ). CanvasRenderingContext2D.drawImage( img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight ). 绘制简单图像语法: CanvasRenderingContext2D.drawImage( img, dx, dy ) 描述: 使用三个参数, 允许在画布上的 任意位置 绘制图片. 参数 img 是指图片对象. 可以是 img 标签, 或者是 video 标签, 已经另一个 canvas 等. 需要注意的是如果直接添加 img 对象是不可以的, 需要等待其加载. 准备一张网络图片, 绘制, 便于查看其加载过程. 123456789// 随便从百度中搜索 &apos;美女头像&apos;, 记录一个链接地址var url = &apos;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3289155966,3850025949&amp;fm=116&amp;gp=0.jpg&apos;;// 创建 img 对象var img = new Image(); // 就是 img 标签// 设置 src 属性为 图片img.src = url;// 绘图ctx.drawImage( img, 100, 100 ); 此时没有任何结果, 打开调试工具查看 Net Work 因为加载图片需要时间, 因此将绘制的方法放在 onload 事件中. 1234567891011// 随便从百度中搜索 &apos;美女头像&apos;, 记录一个链接地址var url = &apos;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3289155966,3850025949&amp;fm=116&amp;gp=0.jpg&apos;;// 创建 img 对象var img = new Image(); // 就是 img 标签// 设置 src 属性为 图片img.src = url;// 绘图img.onload = function () &#123; ctx.drawImage( img, 100, 100 );&#125;; 修改后就可得到效果 注意: 这里使用 new Image() 与 document.createElement( &#39;img&#39; ) 是一样的. 在指定区域内绘制图像当图片比较大的时候, 如果使用这样的方式绘图, 那么图片可能会完全覆盖画布. 例如: 因此, 需要将其控制在一个矩形区域内绘制. 语法: CanvasRenderingContext2D.drawImage( img, dx, dy, dWidth, dHeight ) 描述: 参数 dWidth, dHeight 表示绘制的矩形区域. 绘制的 dx, dy 坐标决定了开始. 该方法绘制的图像会在指定范围内被压缩显示. 将上面的图绘制在 100 * 100 的范围内. 12...ctx.drawImage( img, 100, 100, 100, 100 ); 效果 如果希望正常显示, 需要固定一个宽度或者高度, 然后根据比例计算出另一个值. 这里假定高度是 100. 计算宽度后绘图. 123456...var heigth = 100, width;img.onload = function () &#123; width = img.width * height / img.height; ctx.drawImage( img, 100, 100, width, height );&#125;; 效果 绘制任意图像类似于 CSS 中处理按钮等小图标的技巧, 将很多的效果图集中在一张 png 格式的背景透明的图片中, 这样可以提高效率也便于维护. 那么 drawImage 同样支持该方式绘图. 在画布中的指定位子与指定区域内, 绘制图片中的某个矩形区. 语法: CanvasRenderingContext2D.drawImage( img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight ) 描述: 这里的带有 s 前缀的参数就是指图源的矩形区域. 例如将图片的 ( 100, 100, 300, 200 ) 处的内容绘制到页面的 ( 100, 100, 300, 200 ) 的位置. 12&apos;&apos;&apos;ctx.drawImage( img, 100, 100, 300, 200, 100, 100, 300, 200 ); 效果 绘制动画有了图片部分绘制的功能, 我们就可以尝试绘制动画了. 准备一张图片 然后开始的时候绘制第一行的第一张图. 计算它的坐标与宽高 1234567var img = new Image();img.src = &apos;./imgs士兵(1).png&apos;img.onload = function () &#123; var width = img.width / 4; var height = img.heigth / 4; // 第一张图的顶点是 0, 0, 宽高是 width, height&#125;; 那么第一行的第二张图就是 ( 0, width, width, height ), 第三张就是 ( 0, width * 2, width, height ). 因此第一行的第 i 张图就是 12var x = 0;var y = width * ( i - 1 ); 同理得到, 第 j 列的 x 坐标是 height * ( j - 1 ) 现在绘制第一张图 123456789...var img = new Image();img.src = &apos;./imgs/士兵(1).png&apos;img.onload = function () &#123; var width = img.width / 4; var height = img.height / 4; ctx.drawImage( img, 0, 0, width, height, 100, 100, width, height ); &#125;; 效果 ; 现在要求, 每隔 200 毫秒就切换一张图片, 现在只考虑第一行的图片. 12345678910111213...var img = new Image();img.src = &apos;./imgs/士兵(1).png&apos;img.onload = function () &#123; var width = img.width / 4; var height = img.height / 4; var i = 0; setInterval(function () &#123; ctx.clearRect( 0, 0, cas.width, cas.height ); ctx.drawImage( img, width * (i++ % 4), 0, width, height, 100, 100, width, height ); &#125;, 200 );&#125;; 效果 那么扩展一下, 把四行都画出来 高级篇变换Canvas 绘图中支持矩阵变换功能. 其中涉及的常用方法有 CanvasRenderingContext2D.transform() CanvasRenderingContext2D.scale() CanvasRenderingContext2D.translate() CanvasRenderingContext2D.rotate() CanvasRenderingContext2D.setTransForm() 还有一些方法, 暂时没有普及与确定. 因此这里的几个方法才是最常用的方法. 什么是变换计算机图形学是建立在解析几何基础之上的. 也就是说所有绘制的图形都是基于坐标进行计算得到的. 那么利用坐标系位置的调整, 同样的坐标可以得到不同的效果. 例如有一个点 A ( 10, 10 ). 可以在坐标系中绘制出该点. 如果调整坐标系. 比如将坐标系向右移动 10 个单位, 得到 此时同样是 A 点, 坐标就变成了 ( 0, 10 ). 然后再把坐标系向上移动 10 个单位, 得到 那么针对新坐标系, 这个点的坐标就是 ( 0, 0 ). 这个就是坐标变换. 通过移动坐标的位置, 对坐标进行旋转, 以及对坐标轴数据的缩放, 从而使得原有点的坐标发生变化, 或利用原有的坐标点绘制新的效果. 坐标变换有一套完整的数学公式. 利用矩阵可以很容易的表示坐标的所有变换. 这里的 a, b, c, d, e, f 就刚好是 transform 函数的 参数. 其中 a 有时又标记为 m11. 它表示水平缩放. 其中 b 有时又标记为 m12. 它表示水平倾斜. 其中 c 有时又标记为 m21. 它表示垂直倾斜. 其中 d 有时又标记为 m22. 它表示垂直缩放. 其中 e 有时又标记为 dx. 它表示水平移动. 其中 f 有时又标记为 dy. 它表示垂直移动. 演示 123...ctx.transform( 1, 0, 0, 1, 0, 0 );ctx.fillRect( 0, 0, 100, 100 ); 效果 这里矩阵变换会比较复杂, 因此在使用中一般使用简单的, 平移, 旋转 和 缩放 的简单 api. 平移变换平移变换就是将原有坐标轴进行平行移动, 那么坐标轴移动后就可以使用新坐标来绘制图形了. 语法: CanvasRenderingContext2D.translate( x, y ) 描述: 该方法将坐标进行平移. x 表示水平移动, 正数向右, 负数向左. y 表示垂直移动, 正数向下, 负数向上. 变换可以重复调用, 变换是可以累加的. 使用该变换, 常常用于绘制不同位置, 但是形状重复的图形. 注意: 变换也会被 “继承”, 开启新路径后依旧保留原先变换. 旋转变换语法: CanvasRenderingContext2D.rotate( radian ) 描述: 该方法将坐标轴进行旋转变换. 参数是弧度, 表示旋转的方式. 正数表示顺时针旋转, 负数表示逆时针旋转. 该变换常常用于实现旋转动画等. 缩放变换语法: CanvasRenderingContext2D.scale( x, y ) 描述: 该方法实现水平与垂直的缩放. 参数 x 控制水平缩放倍率. 传参 1 表示不作缩放, 传入大于 1 的数字表示扩大. 参数 y 控制垂直缩放倍率. 传参 1 表示不作缩放, 传入大于 1 的数字表示扩大. 该变换常常用于放大与缩小, 以及反转的效果. 环境前面提到 Canvas 是含有状态的, 也就是说需要修改颜色, 直线样式, 绘图方式等效果时需要开启一个新的状态. 但是有时在绘制过程中需要修改状态, 同时绘制完当前状态后又需要回到之前的状态中继续绘制另外的形状. 那么只有再将修改过的样式载更改回来. 如果在该状态中修改的属性较多, 那么每次在回到之前状态时就有很多的代码. Canvas 中引入了状态的保持机制. 使用 CanvasRenderingContext2D.save() 方法可以保存当前状态. 如果需要恢复到已经保存的状态, 只需要调用 CanvasRenderingContext2D.restore() 方法即可. 状态保持的机制是基于状态栈实现的. 也就是说 save 一次就存储一个状态. restore 一次就将刚刚存入的恢复. 如果 save 两次, 就需要 restore 两次, 才可以恢复到最先的状态. 一般在封装绘图的时候都会采用开始绘制之前, save 一次, 然后 开启一个新路径, 然后绘制结束后 restore, 然后再开启一个新路径. 这样保持当前状态不会对其他绘图代码构成影响. 优化canvas 在绘制图片的时候, drawImage 方法还支持将一个 canvas 绘制到另一个 canvas 中. 因此使用该功能, 可以在内存中完成复杂的绘图, 将绘制好的半成品再绘制到 canvas 中合成需要的效果. 画布保存画布在绘制后实际上就是一张图片, 可以直接右键另存为. 同时也支持使用 js 代码将其保存为 base64 编码的字符串. 语法: Canvas.ToDataURL( type, encoderOptions ) 描述: 该方法可以将画布转换成 base64 格式的数据 type 表示输出类型. 例如: image/png 或 image/jpeg 等 encoderOptions 表示图片输出质量, 其取值在 0 到 1 之间. 如果是 1, 表示无损压缩, 必须使用 image/jpeg 或 image/webp 才起作用 1234567891011121314...&lt;img id=&quot;img&quot;/&gt;...var img = document.getElementById( &apos;img&apos; );var cas = document.createElement( &apos;canvas&apos; );cas.width = 100, cas.height = 100;var ctx = cas.getContext( &apos;2d&apos; );ctx.fillStyle = &apos;pink&apos;;ctx.fillRect( 0, 0, 100, 100 );var data = cas.toDataURL( &apos;image/png&apos;, 1 );img.src = data; 渐变和图案绘制图像有两个主要方法, 一个是描边, 一个是填充. 前面介绍过要设置其样式, 可以使用 strokeStyle 和 fillStyle 属性, 只需要给它们提供颜色就可以了. 但是不仅仅是颜色, 它还支持渐变和重复. 相关方法 CanvasRenderingContext2D.createLinearGradient() CanvasRenderingContext2D.createRadialGradient() CanvasRenderingContext2D.createPattern() 线性渐变语法: CanvasRenderingContext2D.createLinearGradient( x0, y0, x1, y1 ) 描述: 该方法返回一个 CanvasGradient 对象. 用于描述渐变的方式. 该方法有两个参数, 用于表示线型渐变的方向与位置. 使用的时候, 首先创建一个 CanvasGradient 对象, 然后利用 addColorStop 方法添加颜色区间. 方法语法: CanvasGradient.addColorStop( rate, color ). 该方法用于设置在某个比例位置的颜色是什么. rate 的取值是 0 到 1 之间. 可以添加多个渐变点. 然后将该对象赋值给 *Style 属性即可. 案例 1234567...var canvasGradient = ctx.createLinearGradient( 0, 25, 200, 25 );canvasGradient.addColorStop( 0, &apos;blue&apos; );canvasGradient.addColorStop( 1, &apos;red&apos; );ctx.fillStyle = canvasGradient;ctx.fillRect( 0, 100, 200, 50 ); 效果 注意: 渐变点的坐标是基于坐标轴来计算的. 放射渐变语法: CanvasRenderingContext2D.createRadialGradient( x0, y0, r0, x1, y1, r1 ) 描述: 该方法实现放射渐变, 渐变的是在两个圆之间. 一般会使用两个内含关系的圆. 前三个参数分别表示其中一个圆的圆心的坐标, 以及半径. 后三个参数分别表示另一个圆的圆心的坐标, 以及半径. 绘制渐变效果用法与线性渐变一样. 案例 1234567var x = cas.width / 2, y = cas.height / 2, r = 100;var g = ctx.createRadialGradient( x + r * 2 / 3, y - r * 2 / 3, 0, x + r / 3, y - r / 3, r * 4 / 3 );g.addColorStop( 0, &apos;#fff&apos; );g.addColorStop( 1, &apos;#f00&apos; );ctx.fillStyle = g;ctx.arc( x, y, r, 0, 2 * Math.PI );ctx.fill(); 效果 重复填充语法: CanvasRenderingContext2D.createPattern( img, repetition ) 描述: 该方法表示使用图片来填充的设置方法. 需要两个参数, 一个是图片, 一个是重复的方式. 图片允许是 img 标签, 图片, canvas 等对象 可选择的重复方式与 CSS 一致. 有: repeat, repeat-x, repeat-y, no-repeat. 如果是 空或””, 但不是 undefined, 默认就是 repeat. 准备一张图片 案例 1234567var img = new Image();img.src = &apos;imgs/04d91106ecb1ec84b6708cd9796fc772.jpg&apos;;img.onload = function () &#123; var p = ctx.createPattern( img, &apos;repeat&apos; ); ctx.fillStyle = p; ctx.fillRect( 50, 50, 550, 350 );&#125;; 效果 阴影在 Canvas 中还可以给绘制的内容设置阴影. 但是一般不这么用, 因为性能不高. 相关属性: CanvasRenderingContext2D.shadowBlur 属性表示模糊程度. CanvasRenderingContext2D.shadowColor 属性表示模糊颜色. CanvasRenderingContext2D.shadowOffsetX 属性表示模糊位置 x 坐标偏移. CanvasRenderingContext2D.shadowOffsetY 属性表示模糊位置 y 坐标偏移.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象基础总结]]></title>
      <url>%2F2017%2F01%2F15%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[面向对象( 思维方式 )以洗衣服为例面向过程的思维方式： 把解决问题的关注点放在了解决问题的每一个详细步骤(过程)上 1.收集脏衣服 2.把脏衣服扔到洗衣机中 3.设定洗衣程序 4.开始洗衣服 5.拿出衣服晾晒 面向对象的思维方式： 把解决问题的关注点放在了解决问题所需要的一些列的对象上 1.女朋友 2.洗衣机 什么是对象万物皆对象 javascript中的对象是什么？无序的键值对儿的集合 面向对象举例JS封装存在的问题问题: 1代码结构混乱 不便于维护 2全局变量增多 造成全局污染 解决: 1对象封装(依然存在相同的问题) 2对象模块化 面向对象的三大特性封装继承现实生活中的继承是指子承父业, JS中的继承是指就是自己没有的东西,别人有,拿来用就是继承 混入式继承(mix-in) 就是用for in 遍历 var obj1 = { name:”zz”, age:18 } var obj2 = {} for(var k in obj1){ obj2[k]=obj1[k]; } console.log(obj2); 多肽(js中不支持多态) 多肽就是父类指针指向子类对象 class Parent{ public string name; public void sayHell(){ } } Parent p = new Parent(); class Son:extends Parent{ } Parent s = new Son(); 创建对象的方式字面量var obj = { name:’zz’, age:18 } 缺陷: 复用性差 使用内置构造函数Objectvar obj2 = new Object(); obj2.name = “”; obj2.age = 18; 缺陷: 1创造出来的对象是空对象 2复用性差 自定义构造函数\@什么是构造函数 构造函数也是一个函数,一般用于初始化对象 \@构造函数的特点 1.构造函数的首字母大写 2.一般和new关键字一起使用 3.构造函数不需要手动写返回语句(会默认返回新创建出来的对象) function Pers(name, age, gender){ this.name = name; this.age = age; this.gender = gender; //return []; } var myObj = new Pers(); \@构造函数的执行过程 1 使用new关键字 创建对象 2 调用构造函数 3 将构造函数内部的this 指针指向使用new关键字创建出来的对象 4 使用this指针在构造函数内部对对象进行初始化 5 默认将创建的对象返回 \@构造函数的注意项目 1 默认不需要返回值 如果写了 1.1如果返回的是值类型的数据 则不会对默认返回值有任何影响 1.2如果返回的是引用类型的数据 则会将该数据返回 2 当把构造函数当做普通函数调用的时候 this 指向 window \@传统构造函数中存在的问题 将函数的声明，放在构造函数外边 在构造函数内部将函数的地址赋值给对象的方法 就可以避免资源浪费，做到所有的对象共享同一个方法 同时也会造成如下的问题： 1.全局变量污染 2.代码结构混乱，不利于维护 3.不安全 原型什么是原型在构建函数创建出来的时候,系统会默认帮构造函数创建并关联一个空的对象,就是对象的原型 原型的作用在原型中的所有方法和属性(成员),都可以被和其关联的构造函数创建出来的所有实例共享 如何访问原型构造函数名.prototype 实例.__proto__(不推荐使用,因为是非标准) 原型的使用1利用对象的动态特性为原型对象添加成员 function Person(){ } Person.prototype.sayHi = function(){ console.log(‘我是原型中的sayHi’); } 2直接替换原型对象 Person.prototype = { sayHi:function(){ console.log(‘我是原型中的sayHi’); } } var aaa = new Person(); aaa.sayHi(); 原型的注意事项1当使用对象去访问属性和方法的时候,会先在自身查找,如果没有才去原型查找 2一般情况下只会将方法放在原型中,属性放在对象中 3当替换原型的时候,替换之前创建的的对象和替换之后创建的对象的原型是不一致的 4对象能够访问的原型，就是在对象创建的那一刻，和构造函数关联的那个原型！ 5只有在获取属性的时候才会在原型中找.当设置属性的时候,会在自身中找,找不到,就新增 访问原型的方式//1 构造函数.prototype function Person() { } var p = new Person(); var yuanxing = Person.prototype; //2 对象.__proto__ Var yuanxing2 = p.__proto__; console.log(Person.prototype === p.__proto__)//true //注意:这是一个非标准属性 (不推荐使用) //调试过程中使用 //单下划线一般是私有属性(不建议外部使用,怕对内部代码造成伤害) \@实例化 实例化出来的对象，就可以称作是构造函数的一个实例 原型的属性constructor1原型中有一个属性constructor,可以访问构造函数 //Person.prototype访问原型 原型.constructor访问构造函数 2每一个构造函数都有一个name 属性 可以访问自己函数名 //console.log(Person.name); 3用函数替换的方法继承 constructor方向会发生改变,所以在此方法中必须手动添加指向 Person.prototype = { constructor: Person, sayHi: function () { console.log(“Hey, man”); } } console.log(Person.prototype.constructor); var p = new Person(); console.log(p.constructor); console.log(p.constructor.name); 继承的实现方式1 混入式继承 2 原型继承 2.1 通过混入的方式为原型新增成员,以实现继承 2.2 直接替换原型对象 3 经典继承(兼容问题) 在使用原型继承的时候,需要创建构造函数,并对原型进行响应的操作 Object.create() var 对象1 = Object.create(对象2);把对象2的当作了对象1(__proto__)的原型 4封装兼容问题 1 检测浏览器 能力if(Object.create) 2 有就直接用 3 没有(else) 就原型继承 原型链\@什么是原型链 js中所有的对象都会有原型，原型也是对象，所以原型对象也有原型，这样就形成了一个链式结构，称之为原型链 \@属性的搜索方式 1.当使用对象访问成员的时候，会现在对象自身进行查找，如果找到了，就直接使用 2.如果没有找到，就去对象的原型中进行查找，如果找到了，就直接使用 3.如果没有找到，就沿着原型链，继续向上查找，直到找到null 注意！！设置属性不遵循属性搜索原则！！ Object.prototype 的成员\@constructor 指向和原型相关的构造函数 \@hasOwnProperty 判断对象自身是否拥有某个属性 对象.hasOwnProperty(“属性名”) \@isPrototypeOf 判断当前对象是不是另外一个对象的原型 当前对象.isPrototypeOf(另外一个对象) \@propertyIsEnumerable 判断属性是否属于对象本身并且可以被遍历 obj.propertyIsEnumerable(“gender”)); \@toString 和 toLocaleString 1 toString和toLocaleString都是将对象转换成字符串的方法 2但是toLocaleString会将对象转换成本地格式的字符串 本地格式是和系统设置相关的！ \@valueOf 1当引用类型的数据和值类型的数据参与运算的时候，会先调用引用类型数据的valueOf方法,获取返回，如果可以参与运算，则直接使用 2如果不能参与运算，则调用toString方法，使用该返回值进行运算 \@__proto__ 指向对象的原型对象！ 函数instanceof关键字判断构造函数的原型是不是在对象的原型链上 语法: 对象 instanceof 构造函数 返回值: 布尔值 创建函数的三种方式\@函数声明 function 函数名(参数列表){ //函数体 } \@函数表达式 var 函数名 = function (参数列表){ //函数体 } \@ Function var 函数名 = new Function(); Function的使用\@不传传参数 var func = new Function(); //创建空函数 \@传一个参数 var func1 = new Function(methodBody);//创建有函数体的函数，methodBody是一个字符串 \@传多个参数 var func2 = new Function(arg1, arg2…argN, methodBody)//创建一个以methodBody为函数体，之前所有的参数为形参名的函数，所有的参数都是字符串！ \@如何解决函数体过长的问题 1 拼接字符串 2 使用模板 3 有兼容问题的解决方案 反引号 `` eval的使用eval是个函数，可以将字符串转换成代码并立即执行！ 语法: eval(符合js语法规范的字符串); \@使用eval处理JSON格式数据的时候的问题 1 JSON和JS的对象的异同 //1.都是键值对的集合 //2.JSON格式的数据的键必须加引号，对象不需要 2 如何把JSON格式的数据转换成js对象 //1.使用JSON对象 //2.如果JSON对象不可用就用 JSON2.js //3.使用eval 当使用eval处理JSON格式数据的时候，eval会将JSON格式字符串中的大括号{}，当做代码段来解析，所以会报错！ \@解决方案 1 将变量声明也同时放在eval中 var jsonStr = “{key: value}”; eval(“var obj=” + jsonStr); 2 在json格式的字符串前后拼接小括号 var jsonStr = “{key: value}”; var obj = eval(“(“ + jsonStr + “)”); \@ Function和eval的异同 都能将字符串转换成代码 2.Funciton创建出来的是函数，需要手动去调用，代码才会执行，而eval会直接将字符串转成代码并执行 问题： 执行效率的问题 安全性问题（XSS） 函数的原型链1 js 中所有函数的构造函数都是Function, 包括Funtion自己 2 Funtion是自己的构造函数,也是自己的实例 3 Function构造函数在原型图中可以担任两个角色，一个是构造函数，一个是实例 4 当作为构造函数的时候，访问原型使用 Function.prototype 5但作为实例的时候，访问原型使用Funciton.__proto__ Object和Function的关系可以通过instanceof关键字来确定两者的关系， Object和Function互为实例！ arguments对象1 arguments是函数内部的一个对象，他是一个伪数组 2 在函数调用的时候，会将函数的实参，依次的存入这个伪数组中。 3 arguments.length 属性，表示函数在调用的时候，传入的实参的个数 4 arguments.callee属性，指的就是arguments对象所在的函数，一般用来在匿名函数中做递归 函数对象的成员1 arguments 2 caller函数的调用环境，如果是在全局，则为null，如果是在其他函数当中调用的，那么caller为所在的那个函数 3 length 函数的形参的个数 4 name 函数的名称 函数声明和函数表达式的函数名为正常的函数名，newFunction创建出来的函数名为 anonymous 静态成员以及实例成员\@静态成员： 通过构造函数访问的成员就是静态成员 一般将工具方法，也就是类似于\$.ajax这种，设置为静态成员 \@实例成员： 通过实例去访问的成员就是实例成员 一般将和对象相关的成员，也就是类似于css方法这种，设置为实例成员 数组,递归,变量提升(面向对象第四天代码)indexOfindexOf在数组中查找元素的时候返回的元素的索引，没找到返回-1 递归\@什么是递归 在函数直接或者间接的调用自己，就是递归 \@递归的两个要素 自己调自己 结束条件 \@化归思想 化繁为简，化难为易的过程， 转化 归结 的简称 \@递归的使用 前n项和 n的m次方 斐波那契数列 递归获取后代元素（重点！！） 方法1 children 方法2 childNodes nodeType类型判断 1元素 2属性 3文本 8注释 词法作用域 作用域就是变量起作用的范围 2.在代码写好的时候，根据代码的书写结构，就可以确定变量的作用域，这种作用域就是词法作用域 词法作用域又叫静态作用域 js中没有块级作用域（代码块限定的作用域叫做块级作用域） 变量提升(hoisting)\@JS代码执行分两个阶段：1.预解析阶段 2.执行阶段 \@在预解析阶段，会对代码中所有的变量声明以及函数声明做提升操作，提升到其所在的作用域的最顶上！ \@特殊情况 函数同名的时候，会全部提升，但是后面的会覆盖掉前面的 函数和变量同名的情况，只会提升函数，忽略掉变量的声明 变量提升是分作用域的 变量提升是分段（script标签）的 5.条件式函数声明（在条件语句中的函数声明），会将条件式函数声明视为函数表达式做处理，只会提升函数名，函数体不提升 函数中形参赋值的过程是在变量提升之前！ 7函数中的形参，就相当于是在函数中声明一个局部的变量 8 重复声明同一个变量的时候, 只会声明第一个, 后面的声明会全部省略掉, 只剩下赋值 \@自调用函数表达式：(function (形参) {})(实参); 作用域链函数可以创建作用域，函数中又可以声明函数，这样就形成了作用域套作用域的链式结构，称作作用域链 变量搜索原则 现在使用变量的作用域中进行查找，如果找到了，就直接使用 如果没有找到，就去上一级作用域链中进行查找，如果找到了，就直接使用 如果没有找到，就沿着作用域链依次向上查找，直到找到全局作用域 绘制作用域链图 首先绘制0级作用域链 在全局作用域中查找变量以及函数的声明，用小方块的形式将其画在0级作用域线上 再从0级作用域链中的函数中引出下一级作用域链 重复以上步骤！！！ 闭包什么是闭包闭包就是指可以访问独立的数据的函数！！！ 闭包要解决的问题函数内部声明的变量无法再函数外部使用 闭包的基本模型function outer(){ var data = “”; function inner(){ return data; } return inner; } var fn = outer(); fn(); 如何使用闭包返回多个函数在函数内部创建一个对象，在对象中封装多个函数，返回对象，在外部就可以使用对象，访问各个方法 闭包的原理上级作用域无法访问下级作用域中的变量，但是下级作用域可以访问上级作用域的变量 闭包的用途 可以用来保护数据，就是变量被保护在外部函数中，想要修改变量只能通过闭包函数，可以在闭包函数中添加一些校验逻辑，以保证数据的合理性以及安全性 可以为函数新增私有的变量 使用闭包解决for循环中注册点击事件的问题\@问题 点击事件在触发的时候，访问的i变量已经变成了最后一个值！！ \@解决方案 通过闭包来创建一个函数，该函数拥有自己独立的一个变量j，在循环的时候，将当前的i的值保存一份交给j，再将该闭包函数注册给点击事件，这样在点击事件触发的时候，就不会去访问全局的i，而是使用自己的j 使用闭包解决for循环中setTimeout代码执行的问题\@setTimeout 延时器:至少t毫秒后(t秒前在执行主逻辑代码,必须全部执行完在执行回调函数)执行callback函数的代码语法: setTimeout(callback,t) setTimeout 的特性: JS是单线程的 同时只能处理一件事情 JS中任务分为主要任务(js的只逻辑代码)次要任务(setTimeout和setInterval的回调函数) 缓存将数据临时的存储起来以提高访问效率 重要的几种缓存\@浏览器缓存 将网站资源，在浏览器端进行保存，用户请求服务器的时候，这些被保存的资源就直接从本地读取，而不会去服务器请求，这样就可以提升用户的访问速率 \@硬件缓存 现将数据从硬盘读取到内存中，再由cpu直接从内存中读取数据，避免了直接让cpu去硬盘中读数据导致系统效率低下的问题 \@CDN Content Delivery Network 在距用户最近的网络节点上缓存一份数据，当用户在去请求数据的时候，就不去较远的服务器获取，而直接在CDN服务器获取，会提升访问效率 \@缓存型数据库 硬盘型数据库（关系型数据库） MySQL Oracle SQLSEVER 内存型数据库（非关系型数据库） Redis MongoDB 使用缓存解决递归实现的斐波那契数列存在的性能问题\@性能问题 由于递归实现的斐波那契数列中，存在大量的重复计算，导致性能低下 \@如何解决 使用缓存，将每次计算后的结果进行保存，在下次获取该数据的时候，就直接去缓存中拿，而避免了重复的计算 闭包优化缓存解决递归实现的斐波那契数列存在的性能问题function createFib(){ var arr = []; function fib(n){ var num = arr[n]; if(!num){ if(n \&lt;= 2){ num = 1; }else{ num = fib(n - 1) + fib(n -2); } arr[n] = num; } return num; } } JQ缓存实现猜想function createCache(){ var cache = {}; var keys = []; return function(key, value){ if(value != undefined){ cache[key] = value; if(keys.push(key) > 20){ delete cache[keys.shift()]; } } return cache[key]; } } jQuery缓存源码分析function createCache(){ var keys = []; function cache(key, value){ if(keys.push(key + “ “) > 20){ delete cache[keys.shift()]; } return (cache[key + “ “] = value); } return cache; } 沙箱模式 一个封闭的隔离的环境！在JS中通过函数来创建沙箱 (function(window){ //变量的声明 //主要的功能代码 //如果需要，就通过window对象向外界暴露接口 })(window) \@沙箱的应用 框架 组件 插件 函数的调用模式\@ 函数调用模式 语法: 函数名() This的指向: window \@ 方法调用模式 语法: 对象.方法名() This的指向: 谁调用就是谁 \@ 构造函数调用模式 语法: new 函数名() This的指向: new 创建出来的对象 \@ 上下文调用模式 要区分一个函数中的this到底是谁，只需要看他是什么调用模式就好了,函数调用模式就是window, 方法调用模式就是调用方法的对象, 构造函数调用模式就是new创建出来的对象！ 两种创建对象的方式\@工厂模式 function createObj(name, age){ var obj = new Object(); obj.name = name; obj.age = age; return obj; } var p = createObj(“郑天羊”, 18); \@寄生模式 function Person(name, age){ var obj = new Object(); obj.name = name; obj.age = age; return obj; } var p = new Person(“郑天羊”, 18); 工厂模式和寄生模式都可以用来创建对象，但是调用模式不一样，工厂模式是函数调用模式，寄生模式是构造函数调用模式！ 上下文调用模式(call与apply)在前三种调用模式中，this的值都是固定的，无法修改的！上下文（context）调用模式（可以用来改变this的指向, 指的就是函数的调用的环境, this的指向 \@左值和右值 lvalue left value 左值: 左值就是指能够正常的在等号的左边被赋值的值 rvalue right value 右值: 右值就是指能够正常的在等号的右边给别人赋值的值 \@ call 函数名.call(obj, arg1…argN); //功能： //1. 调用函数 //2. 改变this指向为第一个参数中的对象 //3. 将第二个及以后的所有参数，依次的传递给函数作为实参 \@ apply 函数名.apply(obj, 数组or伪数组); //功能： //1. 调用函数 //2. 改变this指向为第一个参数中的对象 //3. 将第二个参数的数组或者伪数组，中的元素一一拆解，依次传递给函数作为实参 \@注意事项 如果call和apply的第一个参数为null或者undefined,this将会指向window 2.如果call和apply的第一个参数为值类型的数据，会将值类型的数据转换成其对应的引用类型的数据，this指向该引用类型的数据 tips: 一般情况下apply的传参特性会被使用的居多（转换伪数组为真数组，求最大值） forEach和map的使用都可以用来遍历数组 \@ forEach 数组.forEach(function(value, index, arr){}) //value：正在遍历的数组元素 //index: 正在遍历的数组元素的索引 //arr: 正在遍历的数组 \@ map 数组.map(function(value, index, arr){}) //value：正在遍历的数组元素 //index: 正在遍历的数组元素的索引 //arr: 正在遍历的数组 map是有返回值的，他的返回值是，将每次调用回调函数之后的返回值拼接成一个新的数组，将这个数组返回，作为map的返回值！ \@ map的练习 将数组中的元素转成字符串 var arr = [1, 2, 3, 4]; var strArr = arr.map(String); console.log(strArr); 生成随机数 var arr = [1, 2, 3, 4]; var strArr = arr.map(Math.random); console.log(strArr); 其他知识点Object.defineProperty平时在给对象添加属性的时候，使用的都是点语法，或者关联数组语法,通过这两种方式添加的属性，不能手动去设置属性的特性 特性: 就是属性的描述信息，包括能否修改，能否删除，能否遍历等等 \@Object.defineProperty用来给对象添加属性的 Object.defineProperty(obj, propertyName, descriptor); //obj 就是要给谁添加属性 //propertyName 要添加的属性名 //descriptor 属性的描述信息，也就是特性集合，是一个对象哦~ \@descriptor对象中的属性 * writable 默认为false，表示属性是否可写 * configurable 默认为false， 表示属性是否可以配置（删除） * enumerable 默认为false， 表示属性是否可以被遍历（for-in） * value 用来设置属性的值 * get和set方法，和writable一样都可以用来设置属性是否可以写 Object.defineProperty(obj, “name”, { writable: true, configurable: true, enumerable: true, value: 1888, set: function(value) { this.nameValue = value; }, get: function() { return this.nameValue; } }); 属性的设置器setter和访问器getter，分别是两个方法，一个用来设置属性的值，一个用来获取属性的值,setter和getter一般情况下不和writbale一起使用,如果只有set方法没有get方法，那么这个属性就是一个只写属性,如果只有get方法没有set方法，那么这个属性就是一个只读属性 严格模式严格模式的开启 “use strict” ‘use strict’ \@严格模式中的特点 声明变量必须使用var 对象的属性不能重名 函数的形参名不能重复 八进制常量不允许使用 eval有自己的作用域 事件兼容性处理\@三种注册事件的方式 onclick简单形式 onclick(function(){}) addEventListener(type, handler, useCapture) type: 事件类型, handler:事件处理函数, useCapture: 是否使用捕获 addEventListener(type, eventHandler, useCapture) //type:指的就是事件的类型，不带on //eventHandler: 事件的处理程序，回调函数 //useCapture: 是否在捕获阶段触发事件 默认是false attachEvent(type, handler) attachEvent(type, eventHandler) //type:指的就是事件类型，带on //eventHandler：事件处理程序，回调函数 \@ addEventListener和attachEvent的区别 1.回调函数中获取事件对象的方式不一样，addEventListener通过回调函数的参数获取，attachEvent通过window.event获取 2.回调函数中的this指向不一致，addEventListener中this指向当前dom对象，attachEvent中this指向window \@兼容性处理的通用函数 function registerEvent(ele, type, handler){ if(ele.addEventListener){ ele.addEventListener(type, handler); }else if(ele.attachEvent){ 如果使用下面的代码，那么，在事件触发的时候,回调函数中拿不到事件对象，回调函数中的this也会指向window //ele.attachEvent(“on”+type,handler) 解决上面问题的关键，就在于，不让系统去调这个回调函数了,而是我们自己去调调用的时候，将事件对象window.event作为实参传递给这个回调函数,this的指向需要更改，改成当前的元素 ele 使用call ele.attachEvent(“on” + type, function(){ handler.call(ele, window.event); }) }else{ ele[“on” + type] = handler; } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3基础总结]]></title>
      <url>%2F2017%2F01%2F02%2FCSS3%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[CSS3简介如同人类的的进化一样，CSS3是CSS2的“进化”版本，在CSS2基础上，增强或新增了许多特性，弥补了CSS2的众多不足之处，使得Web开发变得更为高效和便捷。 CSS3的现状1、浏览器支持程度差，需要添加私有前缀 2、移动端支持优于PC端 3、不断改进中 4、应用相对广泛 如何对待1、坚持渐进增强原则 2、考虑用户群体 3、遵照产品的方案 4、听Boss的 准备工作统一环境由于CSS3兼容性问题的普遍存在，为了避免因兼容性带来的干扰，我们约定统一的环境，以保证学习的效率，在最后会单独说明兼容性的问题。 1、Chrome浏览器 version 46+ 2、Firefox浏览器 firefox 42+ 3、PhotoShop CS6（建议） 如何使用手册学会使用工具，可以让我们事半功倍。 [] 表示全部可选项 || 表示或者 | 表示多选一 ？ 表示0个或者1个 * 表示0个或者多个 {} 表示范围 基础知识选择器CSS3新增了许多灵活查找元素的方法，极大的提高了查找元素的效率和精准度。CSS3选择器与jQuery中所提供的绝大部分选择器兼容。 属性选择器参考手册 1、E[attr] 表示存在attr属性即可； 2、E[attr=val] 表示属性值完全等于val 3、E[attr~=val] 表示的一个单独的属性值 这个属性值是以空格分隔的 4、E[attr|=val] 表示的要么一个单独的属性值 要么这个属性值是以“-”分隔的 5、E[attr*=val] 表示的属性值里包含val字符并且在“任意”位置 6、E[attr\^=val] 表示的属性值里包含val字符并且在“开始”位置 7、E[attr\$=val] 表示的属性值里包含val字符并且在“结束”位置 伪类选择器参考手册 重点理解E是用来参考确定其父元素的，nth-child(n)对应根据E元素确定的父元素的所有子元素，nth-of-type(n)的不同之处在于其对应的是只有E元素，会忽略其子元素。（此处要配合案例加强理解） E:nth-child(n) 第n个子元素，计算方法是E元素的全部兄弟元素 E:nth-of-type(n) 第n个子元素，计算方法只是E元素，会忽略其子元素的 存在 E:nth-last-child(n) 同E:nth-child(n) 计算顺序相反。 E:nth-last-of-type(n) 同E:nth-of-type(n) 计算顺序相反。 n遵循线性变化，其取值1、2、3、4、… 关于n的取值范围： 1、当n做为一个独立值时，n取值为n>=1，例如nth-child(n) 2、当n做一个系数时，n取值为n>=0者n\&lt;0，例如nth-child(2n+1)、nth-child(-1n+5)此处需要理解2n+1或者-n+5做为一个整体不能小于1； E:only-child 表示当前以E确定的父元素，除E之外并无其它子元素（独生子）； E:only-of-type表示当前以E确定的父元素， 除E之外不能包含其它和E同类型的子元素； E:target 结合锚点进行使用，处于当前锚点的元素会被选中； E:empty 选中没有任何子节点的E元素； 伪元素选择器E::selection 可改变选中文本的样式 E::placeholder可改变placeholder默认样式，这个存在明显的兼容问题，比如::-webkit-input-placeholder，具体参考手册进行对比。 E:after、E:before在旧版本里是伪类，在新版本里是伪元素，新版本下E:after、E:before会被自动识别为E::after、E::before，按伪元素来对待。 “:” 与 “::” 区别在于区分伪类和伪元素 颜色新增了RGBA、HSLA模式，其中的A表示透明度通道，即可以设置颜色值的透明度，相较opacity，不具有继承性，即不会影响子元素的透明度。 Red、Green、Blue、Alpha即RGBA Hue、Saturation、Lightness、Alpha即HSLA R、G、B 取值范围0~255 H 取值范围0~360，0/360表示黑色、120表示绿色、240表示蓝色 S 取值范围0%~100% L 取值范围0%~100% A 取值范围0~1 关于透明度： 1、opacity子元素会继承父元素的透明度，在实际开发中会带来干扰； 2 、transparent 设置透明度时完全类似于“玻璃”一样的透明； 文本参考手册 文字阴影与边框阴影相似，可分别设置偏移量、模糊度、颜色（可设透明度）。 单行文本溢出，需要配合overflow:hidden; white-space: nowrap; 难理解的点： 自已要多试着理解一下关于white-space的各个属性值之间的差异； 换行符指的我们在键盘上的Enter键，Enter换行符会被当成空行来对待，而由Tab、Space产生的换行，则会视为一个空格。 上述方法只能解决单行文本的溢出问题，多行文本溢出处理可参照下面的方法，但是有比较严重的兼容性，需要慎重选择，比较完备的多行溢出需要JS辅助完成，可自行尝试。 多行文本文字溢出处理，非标准属性，可应用于移动端 了解常握white-space 使用 边框其边框圆角、边框阴影属性，应用十分广泛，兼容性也相对较好，具有符合渐进增强原则的特征，我们需要重点掌握。 边框圆角圆角处理时，脑中要形成圆、圆心、长半径、短半径的概念，正圆是椭圆的一种特殊情况。 可分别设置长、短半径，以“/”进行分隔，遵循“1，2，3，规则，“/”前面的1~4个用来设置横轴半径（分别对应横轴1、2、3、4位置），“/”后面1~4个参数用来设置纵轴半径（分别对应纵轴1、2、3、4位置 ） 参考手册练习熟悉各种简写方式。 表格运用圆角需要要 border-collapse: separate; 当圆角半径小于或等于边框宽度时，元素内角是直角 如何在PS中查看圆角半径？ 边框图片设置的图片将会被“切割”成九宫格形式，然后进行设置。如下图 “切割”完成后生成虚拟的9块图形，然后按对应位置设置背景， 其中四个角位置、形状保持不变，中心位置水平垂直两个方向平铺。如下图 round 会自动调整尺寸，完整显示边框图片。 repeat 单纯平铺多余部分，会被“裁切”而不显示。 background-slice: 27 40 40 27 分别设置裁切如下图 边框阴影水平偏移量 正值向右 负值向左 垂直正值向下 负值向上。 模糊度是不能为负 关于模糊度：从一个颜色值在一定距离内进行一个渐变至透明的过程。 移量和扩展也是数学运算的，即正负会相互抵消。 偏移量和模糊度是可以相加计算，偏移量负号只代表方向。 设置边框阴影不会影响盒子的布局，即不会影响其兄弟元素的布局。 spread可以与blur、h-shadow、v-shadow相互抵消，blur不可为负值 可以设置多重边框阴影，实现更好的效果，增强立体感。 盒模型关于盒模型存在两种形式，分别是W标准盒模型和IE盒模型，如下图所示，其区别主要在于宽度和高度的计算方式，CSS3对盒模型做出了新的定义，即允许开发人员指定盒子宽度和高度的计算方式。 IE模型下 width = padding + content + border; W盒模型下 width = content box-sizing: border-box width = border + padding + content box-sizing: content-box width = content IE盒模型只会出现在IE5版本和IE6+的怪异模式中。 怪异模式 http://www.cnblogs.com/coco1s/p/4034937.html CSS3中可以通过box-sizing 来指定盒模型，即可指定为content-box、border-box; 背景背景在CSS3中也得到很大程度的增强，比如背景图片尺寸、背景裁切区域、背景定位参照点、多重背景等。 cover 会使“最大”边，进行缩放，另一边同比缩放，铺满容器，超出部分会溢出。 contain 会使“最小”边，进行缩放，另一边同比缩放，不一定铺满容器，会完整显示图片。 background-size 与 background-clip无关 background-size 与 background-origin 保持一致 背景图片尺寸在实际开发中应用十分广泛。 参照手册 渐变渐变是CSS3当中比较丰富多彩的一个特性，通过渐变我们可以实现许多炫丽的效果，有效的减少图片的使用数量，并且具有很强的适应性和可扩展性。 可分为线性渐变、径向渐变、重复渐变。 线性渐变指沿着某条直线朝一个方向产生渐变效果。 上图是从黄色渐变到绿色 必要的元素：方向、起始颜色、终止色； 关于方向如下图 关于颜色起止，可以设置多个色值的渐变，并且可以分别设置渐变的距离 如 linear-gradient(to left, yellow 10%, blue 15%, red 50%) 径向渐变指从一个中心点开始沿着四周产生渐变效果 特点： 1、辐射范围 2、中心点 3、颜色的起止 关于中心点：中心位置参照的是盒子的左上角 关于辐射范围：其半径可以不等即可以是椭圆 关于圆的知识同边框圆角章节的介绍 伸缩布局CSS3在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用，使得开发人员一下子就过上了小康的生活。 伸缩盒模型经历了几次演变，大致分为旧版伸缩布局、过渡伸缩布局、新版伸缩布局，同样为了避免混淆，我们以学习新版伸缩布局为主。 新版伸缩布局这里我们需要引入一些新的概念： 主轴：Flex容器的主轴主要用来配置Flex项目。 侧轴：与主轴垂直的轴称作侧轴，是侧轴方向的延伸。 主轴和侧轴并不是固定不变的，通过flex-direction可以调整。 1、指定一个盒子为伸缩盒子 display: flex 2、设置属性来调整此盒的子元素的布局方式 例如 flex-direction 3、明确主侧轴的方向 4、可互换主侧轴，也可改变方向 其相关属性可参照源代码里的解释如flex-direction、flex-wrap、flex-flow、align-items、align-content、justify-content、align-self、flex、order等 另个两个版本伸缩布局其实现思路与新版基本一致，区别在于其属性及属性值不同，熟练掌握新版伸缩布局后，要参照对比另外两个版本的不同。 多列布局类似报纸或杂志中的排版方式，上要用以控制大篇幅文本。 参照手册 过渡过渡是CSS3中具有颠覆性的特征之一，可以实现元素不同状态间的平滑过渡（补间动画），经常用来制作动画效果。 帧动画：通过一帧一帧的关键画面按照固定顺序和速度播放。如电影胶片 补间动画：自动完成从起始状到终止状的的过度。 关于补间动画更多学习可查看http://mux.alimama.com/posts/1009 特点：当前元素只要有“属性”发生变化时，可以平滑的进行过渡。 transition-property设置过渡属性 transition-duration设置过渡时间 transition-timing-function设置过渡速度 transition-delay设置过渡延时 贝塞尔曲线限定了过渡的轨迹。这部分没有提及，有兴趣同学自行查阅相关资料了解一下即可。 以上四属性重在更解，具体细节可参考手册辅助记忆 动画动画是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。 参考手册 转换转换是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、变形、缩放，甚至支持矩阵方式，配合即将学习的过渡和动画知识，可以取代大量之前只能靠Flash才可以实现的效果。 2D 转换 translate(x,y) x、y 可为负值，相对自身移动，并未脱离文档流。 左手坐标系：伸出左手，让拇指和食指成“L”形，大拇指向右，食指向上，中指指向前方。这样我们就建立了一个左手坐标系，拇指、食指和中指分别代表X、Y、Z轴的正方向。 左手法则：左手握住旋转轴，竖起拇指指向旋转轴正方向，正向旋转方向就是其余手指卷曲的方向。 3D坐标轴，用X、Y、Z分别表示空间的3个维度，三条轴上互相垂直。 媒体查询由于网页呈现终端设备越来越趋向于多样化，尤其是移动终端（手机），具有不同屏幕尽寸、不同分辨率，为了保证网页能十分友好的呈现，CSS3为开发人员提供了可以识别呈现终端的方法，这样便可以有针对性的为不同的呈现终端分别进行处理，被广泛应用于响应式开发中。 html 标签方式： css 属性方式： 常使用的是检测设备宽度 参考手册 Web字体开发人员可以为自已的网页指定特殊的字体，无需考虑用户电脑上是否安装了此特殊字体，从此把特殊字体处理成图片的时代便成为了过去。 支持程度比较好，甚至IE低版本浏览器也能支持。 字体格式不同浏览器所支持的字体格式是不一样的，我们有必要了解一下有关字体格式的知识。 1、TureTpe(.ttf)格式 .ttf字体是Windows和Mac的最常见的字体，是一种RAW格式，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOSMobile、Safari4.2+； 2、OpenType(.otf)格式 .otf字体被认为是一种原始的字体格式，其内置在TureType的基础上，支持这种字体的浏览器有Firefox3.5+、Chrome4.0+、Safari3.1+、Opera10.0+、iOSMobile、Safari4.2+； 3、Web Open Font Format(.woff)格式 woff字体是Web字体中最佳格式，他是一个开放的TrueType/OpenType的压缩版本，同时也支持元数据包的分离，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+； 4、Embedded Open Type(.eot)格式 .eot字体是IE专用字体，可以从TrueType创建此格式字体，支持这种字体的浏览器有IE4+； 5、SVG(.svg)格式 .svg字体是基于SVG字体渲染的一种格式，支持这种字体的浏览器有Chrome4+、Safari3.1+、Opera10.0+、iOSMobile Safari3.2+； 关于字体介绍摘自http://www.w3cplus.com/content/css3-font-face/ 了解了上面的知识后，我们就需要为不同的浏览器准备不同格式的字体，通常我们会通过字体生成工具帮我们生成各种格式的字体，因此无需过于在意字体格式间的区别差异。 推荐http://www.zhaozi.cn/、http://www.youziku.com/ 查找更多中文字体 字体图标其实我们可以把文字理解成是一种特殊形状的图片，反之我们是不是也可以把图片制作成字体呢？ 答案是肯定的。 常见的是把网页常用的一些小的图标，借助工具帮我们生成一个字体库，然后就可以像使用文字一样使用图标了。 优点： 1、将所有图标打包成字体库，减少请求； 2、具有矢量性，可保证清晰度； 3、使用灵活，便于维护； Font Awesome 使用介绍 http://fontawesome.dashgame.com/ 定制自已的字体图标库 http://iconfont.cn/ https://icomoon.io/ SVG http://www.iconsvg.com/ 兼容性通过http://caniuse.com/可查询CSS3各特性的支持程度，一般兼容性处理的常见方法是为属性添加私有前缀，如不能解决，应避免使用，无需刻意去处理CSS3的兼容性问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery基础总结]]></title>
      <url>%2F2016%2F12%2F14%2FjQuery%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[为何要学jQueryJS的缺点 使用jQuery可以方便地解决这些问题 jQuery是什么animate.js是我们自己封装的库，而jQuery是别人帮我们封装好的库。 JS库就是把常用的代码放到一个单独的文件中，用的时候直接引用到页面里面就可以了。 jQuery是JS的一个库，封装了开发过程中常用的功能，能够提高开发效率。 jQuery学什么本阶段主要学习如何使用jQuery，其实就是学习jQuery封装好的一些功能方法，这些方法叫做API（ApplicationProgramming Interface应用程序编程接口）。 这些API的共同特点是：几乎全都是方法。 所以，在使用时，都是方法调用，要加小括号()，小括号里面是相应的参数，参数不同，功能不同。 使用jQuery使用步骤： 1引包 2写入口函数 3实现功能（事件处理） 入口函数就是指程序运行的时候最开始调用的函数，也就是程序开始的地方 开始使用jQuery版本介绍最常用的两个版本： 1.12.x和最新推出的3.0.0 两个版本的区别：3.0版本，不支持IE6、7、8 PC端的开发主要使用1.12.x版本 这几天主要学习1.12.x版本： 未压缩版（开发版）：代码可读性高，推荐在开发和学习环境中使用，方便查看源代码。 压缩版：去除了注释、换行、空格、并且将一些变量替换成了a,b,c之类的简单字符，基本没有可读性，推荐在生产和测试环境中使用，因为文件较小，减少网络压力。 引包注意第一点：在使用jQuery之前，先把jQuery文件引到页面中来，如果在使用jQuery之前，没有引用jQuery文件，会报错： 第二点：src路径一定要写正确 如果src路径写错，也会报错： 入口函数jQuery的入口函数: 第一种： \$(document).ready(function(){ //内容 }); 第二种： \$(function(){ //内容 }); 以上两种写法，作用完全相同，用哪个都可以 JS的入口函数： window.onload = function() { //内容 }; jQuery入口函数与JS入口函数的区别 区别一：书写个数不同 JS入口函数只能出现一次，出现多次会存在事件覆盖的问题。 jQuery的入口函数，可以出现任意多次，不会覆盖。 区别二：执行时机不同 JS入口函数是在所有资源加载完成后，才执行。（包括：页面、外部js文件、外部css文件、图片等） jQuery入口函数，是在文档加载完成后就执行。文档加载完成指的是：DOM树加载完成后，就可以操作DOM了，不用等到所有的外部资源都加载完成。 \$ 符号\$就是一个普通的字符，可以用于变量名或函数名 JS命名规范允许出现的字符有：数字、字母、下划线、\$ var \$ = “字符串”; var \$ = 123; function \$(){ alert(“我是函数\$”); } \$(); // 调用上面我们自定义的函数\$ jQuery中的\$实际是一个函数 // jQuery中使用\$的主要场景 \$(document）.ready(function(){}); // 调用入口函数 \$(function(){}); // 调用入口函数 \$(“#btnShow”) // 获取id属性为btnShow的元素 \$(“div”) // 获取所有的div元素 jQuery里面的\$函数，根据传入参数的不同，进行不同的调用，实现不同的功能。返回的是jQuery对象 jQuery这个JS库，为了避免冲突，给这个最重要的\$函数还起了另外一个名字：jQuery jQuery函数跟\$函数的关系：jQuery === \$; jQuery对象jQuery对象与DOM对象DOM对象此处指的是：使用JS操作DOM的方法返回的对象 var btn = document.getElementById(“btnShow”); //普通的DOM对象 jQuery对象此处指的是：使用jQuery操作DOM的方法返回的对象 var \$btn = \$(“#btnShow”); // jQuery的DOM对象 jQuery拿到普通的DOM对象后会对其进行包装，让其成为具有jQuery方法的jQuery对象 jQuery对象转DOM对象第一种方式 var btn1 = \$btn[0]; //通过索引的方式把DOM对象取出来（推荐使用此方式） 第二种方式 var btn2 = \$btn.get(0);//调用get()方法也可以 这两种方式使用哪一种都可以 DOM对象转jQuery对象\$(普通的DOM对象) 图解： jQuery选择器（重点）JS中选择DOM元素的方法考虑兼容性的话，JS提供的选择DOM的方法只有两个： JavaScript选择元素的方法： document.getElementById(); 通过id属性获取指定元素 返回唯一的DOM对象 document.getElementsByTagName(); 通过标签名获取指定元素 返回DOM对象数组（即使只有一个元素） JS提供的选择DOM的方法太少，无法满足开发的需要，所以我们使用jQuery选择器来弥补这方面的不足 什么是jQuery选择器jQuery选择器非常强大，它提供了一组方法，让我们更方便地获取页面中的元素。（类比：CSS的选择器） 强大的原因：jQuery实现了从CSS1到CSS3所有的选择器以及其他常用的选择器 各种选择器之间可以相互代替，所以，平时真正用到的只是最常用的选择器 基本选择器 符号(名称) 说明 用法 # Id选择器 \$(“#btnShow”).css(“color”, “red”); 选择id为btnShow的一个元素（返回值为jQuery对象，下同） . 类名选择器 \$(“.liItem”).css(“color”, “red”); 选择含有类liItem的所有元素 标签名 标签选择器 \$(“li”).css(“color”, “red”); 选择标签名为li的所有元素 用逗号隔开 并集选择器 \$(“div,p,li”).css(“color”, “red”); div、p、li都会被选中 挨在一起 交集选择器 \$(“li.current”).css(“color”, “red”); 选择标签名为li并且类名为current的元素 \@基本选择器 //id选择器 类名选择器 标签选择器 交集选择器 并集选择器 层级选择器、过滤选择器 符号(名称) 说明 用法 层级选择器 空格 后代选择器 \$(“#j_wrap li”).css(“color”, “red”); 选择id为j_wrap的元素的所有后代元素li > 子代选择器 \$(“#j_wrap > ul > li”).css(“color”, “red”); 选择id为j_wrap的元素的所有子元素ul的所有子元素li 常用的过滤选择器 :eq(index) 选择匹配元素中索引号为index的一个元素，index从0开始 \$(“li:eq(2)”).css(“color”, ”red”); 选择li元素中索引号为2的一个元素 :odd 选择匹配元素中索引号为奇数的所有元素，index从0开始 \$(“li:odd”).css(“color”, “red”); 选择li元素中索引号为奇数的所有元素 :even 选择匹配元素中索引号为偶数的所有元素，index从0开始 \$(“li:odd”).css(“color”, “red”); 选择li元素中索引号为偶数的所有元素 筛选选择器（注：都是方法） 符号(名称) 说明 用法 find(selector) 查找指定元素的所有后代元素（子子孙孙） \$(“#j_wrap”).find(“li”).css(“color”, “red”); 选择id为j_wrap的所有后代元素li children(selector) 查找指定元素的直接子元素（亲儿子元素） \$(“#j_wrap”).children(“ul”).css(“color”, “red”); 选择id为j_wrap的所有子代元素ul siblings(selector) 查找所有其他的兄弟元素（不包括自己） \$(“#j_liItem”).siblings().css(“color”, “red”); 选择id为j_liItem的所有兄弟元素 next(selector) 查找下一个兄弟元素 \$(“#j_liItem”).next().css(“color”, “red”); 选择id为j_liItem的下一个兄弟元素 parent(selector) 查找父元素（亲的） \$(“#j_liItem”).parent(“ul”).css(“color”, “red”); 选择id为j_liItem的父元素 eq(index) 查找指定元素的第index个元素，index是索引号，从0开始 \$(“li”).eq(2).css(“color”, “red”); 选择所有li元素中的第二个 jQuery基础课程 — DOM操作 样式操作（重点）获取样式// 参数表示要获取的 样式属性名称 \$(selector).css(“font-size”); 此时，会返回”font-size”样式属性对应的值。 设置样式设置单个样式： // 第一个参数表示：样式属性名称 // 第二个参数表示：样式属性值 \$(selector).css(“color”, “red”); 设置多个样式： // 参数为对象 \$(selector).css({“color”: “red”,“font-size”:“30px”}); 类名操作（重点）添加类名addClass(className) 为指定元素添加类名 \$(selector).addClass(“liItem”); 注意：已经说了是添加类名了，把名字传入即可，不要加点！ 移除类名removeClass(className) 为指定元素移除类名 \$(selector).removeClass(“liItem”); //移除指定类名 \$(selector).removeClass(); //不指定参数，表示移除所有类名 判断有没有某个类名hasClass(calssName) 判断指定元素是否包含某个类名 \$(selector).hasClass(“liItem”);//返回true或false 切换类名toggleClass(className) 切换类名，如果没有指定类名就添加，有就移除。 \$(selector).toggleClass(“liItem”); Data属性在元素上存放数据,返回jQuery对象。 data(obj) 可传入key-value形式的数据。 key:存储的数据名 value:将要存储的任意数据 一个参数是获取 两个参数是设置 动画函数jQuery提供的一组常见的动画效果，这些动画是标准的、有规律的效果；同时还提供给我们了自定义动画的功能。 隐藏显示动画show()方法 形式一： // 不带参数，没有动画 \$(selector).show();//作用等同于css(“display”, ”block”) 形式二： //参数为数值，表示：执行动画时长 \$(selector).show(2000);//单位为毫秒（ms），2000毫秒即2秒 形式三： //参数为字符串，是jQuery预设的值，共有三个，分别是：slow、normal、fast \$(selector).show(“slow”); //slow：600ms、normal：400ms、fast：200ms 形式四： // 参数一可以是数值类型或者字符串类型 // 参数二表示：动画执行完后立即执行的回调函数 \$(selector).show(2000, function() {}); hide()方法 \$(selector).hide(); \$(selector).hide(1000); \$(selector).hide(“slow”); \$(selector).hide(1000, function(){}); 显示隐藏切换 \$(selector).toggle(speed,callback); jQuery预设的三组动画效果的语法几乎一致： 参数可以有两个，第一个是动画的执行时长(可以是指定字符或毫秒)，第二个是动画执行完成后的回调函数。 滑入滑出动画滑入效果 作用：让元素以下拉动画效果展示出来 \$(selector).slideDown(speed,callback); 滑出动画 作用：让元素以上拉动画效果隐藏起来 \$(selector).slideUp(speed,callback); 滑入滑出切换 \$(selector).slideToggle(speed,callback); 淡入淡出动画淡入效果 作用：让元素以淡淡的进入视线的方式展示出来 \$(selector).fadeIn(speed, callback); 淡出效果 作用：让元素以渐渐消失的方式隐藏起来 \$(selector).fadeOut(1000); 淡入淡出切换 作用：通过改变不透明度，切换匹配元素的显示或隐藏状态 \$(selector).fadeToggle(‘fast’,function(){}); 淡淡达到效果 改变不透明度到某个值 与淡入淡出的区别：淡入淡出只能控制元素的不透明度从 完全不透明到完全透明；而fadeTo可以指定元素不透明度的具体值。并且时间参数是必需的！ 作用：调节匹配元素的不透明度 // 用法有别于其他动画效果 // 第一个参数表示：时长 // 第二个参数表示：不透明度值，取值范围：0-1 \$(selector).fadeTo(1000, .5); //0全透，1全不透 // 第一个参数为0，此时作用相当于：.css(“opacity”, .5); \$(selector).fadeTo(0, .5); 动画方法总结 有规律的体现： jQuery提供的这几个动画效果控制的CSS属性包括：高度、宽度、不透明度。{height:400px;width:300px; opacity:.4;} 这三个CSS属性的共性是：属性值只有一个（合写的不行），并且这个值是数值（至少经过准换后能变为数值）。 自定义动画注意：所有能够执行动画的属性必须只有一个数字类型的值。 比如：要改变字体大小，要使用：fontSize（font-size），不要使用：font 动画支持的属性： http://www.w3school.com.cn/jquery/effect_animate.asp 作用：执行一组CSS属性的自定义动画 // 第一个参数表示：要执行动画的CSS属性（必选） // 第二个参数表示：执行动画时长（可选） // 第三个参数表示：动画执行完后立即执行的回调函数（可选） \$(selector).animate({params},speed,callback); 停止动画作用：停止当前正在执行的动画 为什么要停止动画？ 如果多个动画在同一元素上执行，对这个元素来说，后面的动画将被放到队列中，从而形成动画队列。（联想：排队进站） 上一个动画执行完成，下一个动画才能执行，但是这样的效果有时不是我们想要的。 // 第一个参数表示是否清空所有的后续动画 // 第二个参数表示是否立即执行完当前正在执行的动画 \$(selector).stop(clearQueue,jumpToEnd); 解释： 当调用stop()方法后，当前动画停止于当前样式的只（不会到达目标值），队列中的下一个动画会立即开始。 如果参数clearQueue被设置为true，那么队列中剩余的动画就被删除了，永远不会再执行。 如果参数jumpToEnd被设置为true，那么当前动画会停止，但是参与动画的每一个CSS属性将被立即设置为它们的目标值。比如：slideUp()方法，那么元素会立即隐藏掉。如果存在回调函数，回调函数也会立即执行。 另外： 如果元素动画还没有执行完，此时调用sotp()方法，那么当前动画将会停止。并且由于本次动画没有执行完成，本次动画的回调函数也不会被执行（下一次的会照常执行）。 常用方式： \$(selector).stop();//当前动画停止于此刻的样式状态 后面的动画继续执行 节点操作（重点）动态创建元素// \$()函数的另外一个作用：动态创建元素 var \$span = \$(“\我是一个span元素\”); 添加元素（重点）append()（重点） 作用：在被选元素内部的最后一个子元素（或内容）后面插入内容（页面中存在或者创建出来的元素都可以） //在\$(selector)中追加\$node \$(selector).append(\$node); //在\$(selector)中追加div元素，参数为htmlString \$(selector).append(‘\\‘); 如果是页面中存在的元素，那么调用append()后，会把这个元素从原先的位置移除，然后再插入到新的位置。 如果给多个目标追加一个元素，append()方法内部会将这个元素复制多份，然后追加到多个目标中。（最好不要这么做） 常用参数：htmlString 或 jQuery对象 不常用操作（了解即可）：（用法跟append()方法基本一致） prepend() 作用：在元素的第一个子元素前面追加内容或节点 \$(selector).prepend(node); after() 作用：在被选元素之后，作为兄弟元素插入内容或节点 \$(selector).after(node); before() 作用：在被选元素之前，作为兄弟元素插入内容或节点 \$(selector).before(node); html创建元素作用：设置或返回所选元素的html内容（包括 HTML 标记） 设置内容的时候，如果是html标记，会动态创建元素，此时作用跟JS里面的innerHTML属性相同 // 动态创建元素 \$(selector).html(‘\传智播客\’); // 获取html内容 \$(selector).html(); 清空元素//清空指定元素的所有子元素 \$(selector).empty(); \$(selector).html(“”); //”自杀”把自己（包括所有内部元素）从文档中删除掉 \$(selector).remove(); 复制元素// 复制\$(selector)所匹配到的元素 // 返回值为复制的新元素 \$(selector).clone(); 推荐 使用html(“\\”)方法来创建元素 使用html(“”)清空元素（但是这样无法清除对象身上的事件，造成内存泄漏（少量的无所谓）） 代码/文本/值html() 方法 作用：设置或获取匹配元素的代码内容 \$(selector).html(); //获取 \$(selector).html(‘\传智播客\’); //设置 text() 方法 作用：设置或获取匹配元素的文本内容 \$(selector).text();//获取操作不带参数 （注：会把所有匹配到的元素内容拼接为一个字符串，不同于其他获取操作！） \$(selector).text(“我是内容”);//设置操作带参数，参数表示要设置的文本内容 val()方法 作用：设置或返回表单元素的值，例如：input,select,textarea的值 \$(selector).val();// 获取匹配元素的值，只匹配第一个元素 \$(selector).val(“具体值”);// 设置所有匹配到的元素的值 属性操作设置属性： // 第一个参数表示：要设置的属性名称 // 第二个参数表示：该属性的值 \$(selector).attr(“title”, “传智播客”); 获取属性： // 参数为：只传入要获取的属性的名称即可返回指定属性的值 \$(selector).attr(“title”); 移除属性： // 参数为：要移除的属性的名称 \$(selector).removeAttr(“title”); 注意：表单元素中属性值为布尔值的属性，如checked、selected、disabled要使用.prop()方法 \$(selector).prop(“checked”); //获取 \$(selector).prop(“checked”, true ); //设置 细节参考：http://api.jquery.com/prop/ 尺寸位置尺寸操作在jQuery中有一套可以非常方便的操作元素尺寸的系列方法。 height()与width()：设置或者返回元素的高度及高度,返回结果是数值类型。 innerWidth()与innerHeight()：包括padding outerWidth()与outerHeigth()：包括padding、border outWidth(true)与outerHeight(true)：包括padding、border、margin 注：只有height()与width（）可以进行设置操作，innerWidth（）、outWidth（）都是只读属性，只能获取、不能设置。 位置操作scrollTop() 作用：获取或者设置元素垂直方向滚动的位置 //获取 \$(selector).scrollTop(); //设置，参数为数值类型 \$(selector).scrollTop(100); scrollLeft() 作用：获取或者设置元素水平方向滚动的位置 //获取 \$(selector).scrollLeft(); //设置，参数为数值类型 \$(selector).scrollLeft(100); offset() 作用：获取或设置元素相对于document左上角的位置 //无参数表示获取，返回值为：{left:num, top:num}，值是相对于document的位置 \$(selector).offset(); //有参数表示设置，参数推荐使用数值类型 \$(selector).offset({left:100, top: 150}); 注意：使用offset操作，如果元素没有设置定位(默认position:static)，则会把position修改为relative.会修改left、top position() 获取相对于其最近的有定位的父元素的位置。相当于之前JS中的offsetLeft和offsetTop // 获取，返回值为对象：{left:num, top:num} \$(selector).position(); 注意：position方法只能获取，不能设置 序列化表单提交内容serialize()序列表表格内容为字符串。 serializeArray()序列化表格元素 (类似 ‘.serialize()’ 方法) 返回 JSON 数据结构数据。 返回的JSON对象是由一个对象数组组成的，其中每个对象包含一个或两个名值对——name参数和value参数（如果value不为空的话）。 jQuery基础课程 — 其他知识 jQuery事件事件机制jQuery的事件机制，指的是：jQuery对JavaScript操作DOM事件的封装，包括了：事件绑定、事件解绑、事件触发。 JavaScript： btn.onclick = function() {}; //给这个按钮绑定事件 jQuery： \$btn.click(function() {}); //给按钮绑定事件 click是一个方法，内部是对onclick事件的封装 事件的发展历程（了解）简单事件绑定 >> bind事件绑定 >> delegate事件绑定 >> on 简单事件绑定： click(handler) 单击事件 dbclick(handler) 双击事件 blur(handler) 失去焦点事件 focus(handler) 获得焦点事件 mouseenter(handler) 鼠标进入事件 mouseleave(handler) 鼠标离开事件 keydown(handler) 键盘按下事件 keyup(handler) 键盘弹起事件 bind方式 作用：给匹配到的元素直接绑定事件（不推荐，1.7以后的jQuery版本被on取代） // 绑定单击事件处理程序 第一个参数：事件类型 第二个参数：事件处理程序 \$(“p”).bind(“click mouseenter”, function(e){ //事件响应方法 }); 优点：可以同时绑定多个事件，比如：bind(“mouseenter mouseleave”, function(){}) 缺点：仍然无法给动态创建的元素绑定事件 delegate方式 作用：给匹配到的元素绑定事件，对支持动态创建的元素有效（特点：节省资源，支持动态创建的元素）（不推荐，1.7以后的jQuery版本被on取代） // 第一个参数：selector，要绑定事件的元素 // 第二个参数：事件类型 // 第三个参数：事件处理函数 \$(“.parentBox”).delegate(“p”, “click”, function(){ //为 .parentBox下面的所有的p标签绑定事件 }); 与前两种方式最大的优势：减少事件绑定次数提高效率，支持动态创建出来的元素绑定事件 事件绑定（重点）我们现在用on的方式来绑定事件（最现代的方式，强烈建议使用的方式） jQuery1.7版本后，jQuery用on统一了所有的事件处理的方法 作用：给匹配的元素绑定事件，包括了上面所有绑定事件方式的优点 语法： //第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件） // 第二个参数：selector, 执行事件的后代元素 // 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用 // 第四个参数：handler，事件处理函数 \$(selector).on(events[,selector][,data],handler); // 表示给\$(selector)绑定事件，当必须是它的内部元素span才能执行这个事件 \$(selector).on( “click”,“span”, function() {}); // 绑定多个事件 // 表示给\$(selector)匹配的元素绑定单击和鼠标进入事件 \$(selector).on(“click mouseenter”, function(){}); 事件解绑unbind() 方式（废弃） 作用：解绑 bind方式绑定的事件 \$(selector).unbind(); //解绑所有的事件 \$(selector).unbind(“click”); //解绑指定的事件 undelegate() 方式（废弃） 作用：解绑delegate方式绑定的事件 \$( selector ).undelegate(); //解绑所有的delegate事件 \$( selector).undelegate( “click” ); //解绑所有的click事件 off解绑on方式绑定的事件（重点） //解绑 所有类型 所有事件（直接绑定的和委托的都解绑） \$(selector).off(); //解绑 click事件 所有事件（直接绑定的和委托的都解绑） \$(selector).off(“click”); //解绑 click事件 只解绑委托的 \$(selector).off( “click”, “**” ); //第二个参数表示的是要找委托的 选择器“**”表示选择所有委托的 事件触发简单事件触发 \$(selector).click(); //触发 click事件 trigger方法触发事件 \$(selector).trigger(“click”); triggerHandler触发 事件响应方法，不触发浏览器行为 比如:文本框获得焦点的默认行为 \$(selector).triggerHandler(“focus”); jQuery事件对象介绍event.type 事件类型：click，dbclick… event.which 鼠标的按键类型：左1 中2 右3 event.pageX 鼠标相对于页面左边的位置 event.target 触发该事件的元素（事件目标） event.currentTarget 当前对象（相当于this） event.delegateTarget 代理对象 event.keyCode 键盘按键代码 event.stopPropagation()； 阻止事件冒泡 event.preventDefault(); 阻止默认行为 return false; event.data 传递给事件处理程序的额外数据 return false; // JQ的事件中return false可以阻止冒泡和默认行为 JS中只阻止默认行为 this：事件处理函数被哪个元素对象调用，this就指向哪个元素对象。 jQuery补充（了解）链式编程// 链式编程代码示例 \$(“li”).parent(“ul”).parent().siblings(“div”).children(“div”).html(“内容”); 链式编程原理：return this; 通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回this end(); // 结束当前链最近的一次过滤操作，并且返回匹配元素之前的一次状态。 隐式迭代隐式迭代：在方法的内部会对匹配到的所有元素进行循环遍历，执行相应的方法；无需我们再手动地进行循，方便我们使用。 // 设置操作 \$(“div”).css(“color”, “red”); 如果是获取多个元素的值，大部分情况下返回第一个元素的值。 // 获取操作 \$(“div”).css(“color”); // 返回第一个元素的值 each方法大部分情况下是不需要使用each方法的，因为jQuery的隐式迭代特性。但是如果要对每个元素做不同的处理，这时候就要用each方法了。 作用：遍历jQuery对象集合，为每个匹配的元素执行一次指定函数 // 参数一表示当前元素在所有匹配元素中的索引号 // 参数二表示当前元素（DOM对象） \$(selector).each(function(index,element){}); 多库共存此处多库共存指的是：jQuery占用了\$和jQuery这两个变量名。当在一个页面中引用了jQuery，并且引用的其他库（或者其他版本的jQuery库）中也用到了\$或者jQuery这两个变量名，这时就有了多库共存的问题。 // 模拟另外的库使用了 \$ 这个变量名。此时，就与jQuery库产生了冲突 var \$ = { name : “itecast” }; 解决方式： //让jQuery释放对\$的控制权，让其他库能够使用\$。此后，只能用jQuery来调用jQuery提供的方法 \$.noConflict(); jQuery插件（了解）jQuery虽然功能强大，但也不是包含所有的功能，可以通过插件来扩展它的功能： 当你需要某个插件的时候，你可以“安装”到jQuery上面，然后使用。 当你不再需要这个插件，那你就可以从jQuery上“卸载”它。 （联想：手机软件，安装的app就好比插件，用的时候安装上，不用的时候卸载掉） 使用插件jQuery.color.js animate()自定义动画：不支持背景的动画效果animate动画支持的属性列表 使用步骤： 1.引入jQuery文件 2.引入插件 3.使用插件 制作插件如何创建jQuery插件：http://learn.jquery.com/plugins/basic-plugin-creation/ 为\$函数扩展方法 \$.pluginName = function() {}; 为jQuery对象扩展方法 \$.fn. pluginName = function() {}; jQueryUI使用场景：网站的管理后台 jQueryUI专指由jQuery官方维护的UI（用户接口）方向的插件。 官方API：http://api.jqueryui.com/category/all/ 其他教程：jQueryUI教程 基本使用: 1.引入jQueryUI的样式文件 2.引入jQuery 3.引入jQueryUI的JS文件 4.使用jQueryUI功能]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript基础总结]]></title>
      <url>%2F2016%2F12%2F04%2FJavaScript%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[Js基础介绍JS的组成 ECMAScript 规定了js的语法标准以及规范 DOM document object model 文档对象类型提供了一套操作DOM元素的API(应用程序接口) BOM Browser object model 浏览器对象模型 提供了一套操作浏览器相关内容的API 输出语句\@常用输出语句 代码注释\@代码注释 //单行注释 /* 多行注释 */ 书写多行注释的时候注意不要发生嵌套 /** + 回车 用于函数的说明 书写位置\@书写位置 可以写在HTML页面内的任意位置或者从外部引用（可以类比样式代码的书写位置） 标签属性\@script标签的属性 type类型 src 地址 async异步加载，加载完成立即执行defer异步加载，页面上的东西都执行完了才执行（了解即可!!!） 变量变量的命名规范\@变量的命名 规则(必须遵守) 区分大小写 不能是关键字和保留字 由字母、数字、下划线、\$ 组成且开头不能是数字 tips:关键字和保留字那么多，记不住怎么办？ 首先，关键字就是你平时用的那些，而保留字在非严格模式下不能使用的只有： class enum extends super const export import 而且，其实如果你使用了关键webstorm是有提示的，但是常见的几个最好还是记住 规范(建议遵守) 变量的名称要有实际意义 规则中所说的字母包括ASCII和Unicode字母字符，如汉字，但不推荐使用 变量的命名遵守驼峰命名法，首字母小写,第二个单词的首字母大写 例如：userName 变量的声明赋值\@变量的声明和赋值 书写格式 var 变量名 = 值 练习\@交换两个变量的值 \@不使用第三个变量 弱类型\@弱类型 JavaScript是弱类型的语言，即声明不同数据类型的变量使用同一个关键字var 数据类型数据类型声明的时候不用考虑类型，但是处理和计算的时候要考虑类型 简单数据类型(值类型) number数值型 string字符串型 boolean布尔型 undefined 未定义 null空 复杂数据类型(引用类型) object对象 function 函数 Array 数组 Data 日期 RegExp 正则 Math String NumberBoolean 使用typeof关键字可以查看变量的数据类型 数值类型\@数值类型 字面量 var num = 数字; 浮点数 计算浮点数时会丢失精度 我们通常用整数的计算来表示浮点数的计算 不要以两个浮点数是否相等作为条件判断的依据（判断范围还是可以的） NaN NaN是数值类型 NaN不等于自身 isNaN( ) 不是有意义的数值返回true 字符串类型\@字符串型 字面量 var str = “字符串”; 字符串的长度 str.length length就是长度的意思 转义符 \n 换行 \’单引号 \”双引号 \\斜杠 字符串的不可变性 由于字符串有不可变性，在大量拼接字符串的时候会非常消耗内存。 布尔类型\@布尔类型 所有类型的值都可以转化成布尔值 会转化成false的值有： 空字符串 数值零NaN undefined null undefined类型\@undefined 表示声明但未赋值的变量 手动赋值为 undefined对象属性不存在的时候,这个属性的值为undefined 变量不可能自动为 null 除非手动赋值 当给别人提供一个返回对象的方法或者函数的时候当函数中创建这个对象失败，或者获取对象失败，无法正常返回对象的时候，就应该返回null 类型转换转换成字符串\@转换成字符串 将任意类型转化为字符串 String(值) 大部分类型都有toString方法 值.toString() 小技巧 值+”” 转化成数值型\@转换成数值 将任意类型转化为数值型 Number(值) 将字符串转化为数值 parseInt(“字符串”) parseFloat(“字符串”) 小技巧 值-0 转化成布尔值\@转换成布尔值 将任意类型转化为布尔值 Boolean(值) 条件判断中会自动转换 if(值) 小技巧 !!值 获取数据类型typeof 关键字语法 typeof 变量 返回值: 字符串的 类型 (返回的内容也是字符串) 使用typeof关键字去获取复杂数据类型的类型的时候 只能获取到object typof是个关键字，后面加括号，只是对后面的代码进行分组，提升了优先级 操作符\@运算符 一元运算符\@递增和递减 递增++ 递减– a++ 先参与运算 后自加 ++a 先自加 后参与运算 逻辑运算符\@逻辑运算符 &amp;&amp; 与 两个操作数都为true，结果为true 只要有一个操作数为false，结果为false || 或 只要有一个操作数为true，结果为true 两个操作数都为false，结果为false ! 非 逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反 只有一个操作数 逻辑运算 &amp;&amp; 和 || 都采取短路运算，即第一个能够决定结果就不再看第二个了 &amp;&amp; 的要求比较宽松 要两个都是true才是true所以看到第一个是false就没有必要继续完后看了 console.log(false &amp;&amp; 不管了); || 的要求比较严格 要两个都是false才是false所以看到第一个是true就没有必要继续完后看了 console.log(true || 不管了); 短路运算（了解） &amp;&amp;和 ||不但可以操作布尔类型的值，对其他类型的值也可以进行操作，并返回可以决定表达式结果的那个值。 赋值运算符\@赋值运算符 a+=b 等价于 a=a+b 关系运法符 \&lt; \&lt;= >= > == != 相等和不相等 === !== 全等和不全等 注意: 当引用类型的数据和值类型的数据进行运算（+-*/ == > \&lt;）的时候 会调用引用类型数据的valueOf方法，获取返回值，如果这个返回值可以参与运算，那么就直接用了 如果不能参与运算，再去调用该引用类型数据的toString方法,拿这个返回值来参与运算 例 //字面量 //{} //[]//1.只要遇到字面量，必然是在创建对象console.log([] == []);//false console.log({} == {});//false//引用类型的数据和值类型console.log([] == ![]);//调用上述方法后就相当于console.log(“” == false); 运算符的优先级 优先级从高到底 () 优先级最高 一元运算符 ++ – ! 算数运算符 先* / % 后 + - 关系运算符 > >= \&lt; \&lt;= 相等运算符 == != === !== 逻辑运算符 先&amp;&amp; 后|| 值类型和引用类型 值类型：直接存储数据本身的数据，就是值类型的数据 引用类型：存储的是数据的地址，数据单独存储，这种数据就是引用类型的数据 特征: 值类型的数据在赋值的时候，会将存储的数据复制一份交给新的变量，两个变量值相等，但是存储的空间不一样，修改其中一个，另外一个不会受影响 引用类型的数据在赋值的时候，会将对象的地址复制一份交给新的变量，此时两个变量同时指向同一个对象，通过其中一个变量对对象进行修改，另外一个变量也会受到影响 var num = 100; function test(n){ //n = num //值类型的赋值 n = 1000; } test(num); console.log(num);//100 var obj1 = { name:”高富帅”; } function test(obj){ //obj = obj1; //引用类型的赋值 obj.name = “矮穷丑”; } test(obj1); console.log(obj1.name);//矮穷丑 var obj1 = { name:”高富帅” } function test(obj){ obj.name = “矮穷丑” obj = { name : “白富美” } obj.name = “土肥圆”; return obj.name; } console.log(test(obj1));//土肥圆 console.log(obj1.name);//矮穷丑 语句选择语句ifif (condition) { statement1 } else if (condition) { statement2 } else { statement3 } 三元表达式表达式1 ? 表达式2 : 表达式3 选择语句switchswitch (expression) { case value: statement break; case value: statement break; default: statement } 循环语句forfor (initialization; expression; post-loop-expression)｛ statement ｝ initialization表示：初始化表达式 expression表示：控制表达式 post-loop-expression表示：循环后表达式 三者都是可选的 循环语句 for-in &amp; 关键字in的使用 for-in 遍历对象的键 语法 for (var k in obj)｛ console.log(k); ｝ 注意：对象的属性全都是字符串类型的 注意： 在for-in中使用键访问对象的值的时候，不能使用点语法 只能使用中括号 又叫做 关联数组语法 判断对象是否可以访问某个属性 语法： 属性名 in 对象 console.log(“toString” in obj); 返回值： 布尔值，表示能或者不能 break和continuebreak跳出当前循环，执行循环后的语句 continue跳出当前循环，继续执行循环 循环语句whilewhile语句 先判断后执行 while(expression) statement do while 语句 先执行后判断 do {statement} while (expression); 数组数组的声明通过构造函数声明（更加通用） var arr = new Array(“a”, “b”, “c”); 通过字面量声明（更加简便） var arr = [“a”,”b”,”c”]; 数组的赋值和取值赋值 数组名[索引号] = 值 //arr[0]=100 取值（通过数组名和索引即可取到对应的值） 数组名[索引号] //console.log(arr[0]) 数组的遍历数组的索引是从0开始的 数组的长度可以通过arr.length获取 由于数组的索引从0开始，所以最后一个值的索引为arr.length-1 通过for循环遍历数组 for (var i = 0; i \&lt;= arr.length - 1; i++) { console.log(arr[i]); } 可简写为： for (var i = 0; i \&lt; arr.length; i++) { console.log(arr[i]); } \@数组length的应用 往数组中添加新元素，数组的length会增加 通过给arr.length赋值可以改变数组的长度 冒泡排序\@冒泡排序 var arr = [65, 97, 76, 13, 27, 49, 58];//循环控制趟数for (var i = 0; i \&lt; arr.length - 1; i++) {//控制两两比较的次数for (var j = 0; j \&lt; arr.length - 1; j++) {//两两比较 从小到大排序if (arr[j] > arr[j + 1]) {//交换位置var tmp = arr[j];arr[j] = arr[j + 1];arr[j + 1] = tmp;}}} 函数函数的声明和调用函数的声明 function 函数名 () { //函数体 } 函数的调用 函数名(); 函数的参数有参数的函数的声明（声明中的参数只是一个占位符，没有实际的值，是形式参数，即形参） function 函数名 (参数1,参数2,参数3…) { //函数体 } 有参数的函数的调用（调用时传入的参数才是有真正数值的参数，是实际参数，即实参） 函数名(参数1,参数2,参数3…); 函数的返回值在函数中通过return关键字将要返回值返回 return 要返回的值; 函数高级概念\@参数详解 在JS中实参的个数和形参的个数可以不一致 \@返回值详解 函数的返回值是什么，调用这个函数就相当于调用什么，如果没有返回值则为undefined 函数在执行完成return语句后便会退出函数，后面的代码不会执行 \@三种定义方式 函数声明 function fn1() { //函数体 } 函数表达式 var fn2 = function () { //函数体 }; Function Var 函数名= new Function fn1() \@匿名函数 匿名函数（没有名字的函数） 变量 = function () { //函数体 } \@递归调用 程序调用自身的编程技巧称为递归 \@回调函数 函数也是一种普通的数据类型 因此函数也可以被当作参数传递 被当作参数传递的函数叫做回调函数 对象从宏观的角度讲，对象是对客观事物的抽象，事物的特征可以用属性表示，事物的行为可以用方法表示 从微观的角度讲，对象就是一种数据类型，通过对象可以方便地对变量和函数进行管理 初期我们甚至可以把他简单地理解为一个工具箱 键值对键值对就是一种对应关系，通过键能够方便地找到值 键:值 key:value k:v 对象的声明通过构造函数声明（更加通用） var obj= new Object(); 通过字面量声明（更加简便） var obj= {}; 对象具有属性和方法 属性 用来描述对象的特征 一般是名词 对应变量 方法 用来描述对象的行为 一般是动词 对应函数 属性属性的定义 对象.属性名 = 值 属性的调用 对象.属性名 方法方法的定义 对象.方法名 = function(){ //函数体 }; 方法的调用 对象.方法名() 关于this 的指向全局上下文:全局运行上下文中（在任何函数体外部），this 指代全局对象 函数上下文:对象方法中的this指的是该方法所属的对象 直接调用中的this指的是全局对象总之，函数上下文中（在函数内部），this指的是当前函数所属的对象 构造函数中:当一个函数被作为构造函数使用时（前面加new关键字），new关键字会让this的指向改变，并让其成为当前函数的返回值 批量创建对象工厂模式创建对象为什么要优化创建对象的方式 因为对象在项目中被大规模的使用，所以每一点小小的改进都会对项目整体效率带来很大的提升，现阶段同学们还不可能有深刻的体会，只是让大家了解一下，后面讲项目大家自然就明白了。 \@工厂模式创建对象 同类型对象，只是一些属性的值不同，通过对象字面量创建对象每次都要写那么多东西很费劲，我们可以将创建对象的过程封装进一个函数，只把发生变化的属性作为参数传入，从而简化对象创建的过程。 但是工厂模式只是创建出来一个普通的对象并将其返回，因此无法判断实例的具体类型。 构造函数创建对象\@this和new 利用new 关键字可以声明新的对象。new关键字可以让构造函数中this的指向改变，并让构造函数把this返回。 \@构造函数 构造函数也是函数，只不过会默认返回一个对象。 \@构造函数创建对象 通过构造函数创建对象更方便（不需要创建对象并返回）。更重要的是可以通过instanceof来判断实例的类型了。 对象的动态创建对象的动态特性就是指，在对象创建出来之后，可以随时为对象添加成员的这种特性，就是动态特性 语法: 成员：属性和方法 利用对象动态特性给对象添加成员的方式 点语法 对象名.属性名 = 值 关联数组语法 对象名[“属性名”] = 值 案例 obj[[]] = “我是一个怪物！！”; //相当于做了如下操作 //obj[“[object Object]”] = “我是一个怪物！！”; delete关键字语法：delete 变量名/对象.属性名 返回值：boolean类型 表示是否删除成功 不可信！！！ 删除未使用var声明的变量 (使用var的删不掉)a = 10; console.log(delete a); console.log(a); 删除对象的属性var obj = { // name : “郑天杨” // }console.log(delete obj.name);//Object.defineProperty() 表示是否可以删除对象的属性 后面js高级会学 delete删除数组元素delete删除数组元素的时候，数组原本的其他数据的索引不会变化而且数组的长度也不会变化！！只是删除了索引及其对应的值 其他概念对象字面量\@对象字面量 var o = { name : “zs”, age : 18, sayHi : function() { console.log(this.name); } }; 对象标记法\@对象标记法 JavaScript ObjectNotation（JavaScript对象标记法）是仿照JS中对象字面量的格式去书写的一串用来记录对象数据的字符串，可以用于数据传输。将来学习AJAX会详细学习。 访问属性的两种方式\@访问属性的两种方式 点语法（简单） 对象.属性名 中括号（灵活） 对象[“属性名”] 遍历的两种方式\@遍历的两种方式 通过for可以对集合进行有序的遍历 通过forin可以对集合进行有序的遍历 for(var k in obj) { 语句 } k变量代表的是json中的各个属性（key）和 var i = 0中的i是一个意思 名字不同而已 DOM操作增 删 改 查 (下面有详细介绍)增//document.createElement //innerHTML //cloneNode //appendChild //insertBefore 删//innerHTML 改//innerText //setAttibute //style 查//document.getElementById //document.getElementsByTagName //document.getElemnetsByClassName 异常处理异常的最大特征就是，会报错，后面的代码将不会继续执行 语法异常 语法错误导致的异常 浏览器差异导致的异常 运行时异常 异常处理语句try{ //可能会出错的代码 //1.打开了资源 //2.操作资源 }catch (e){ //e 就是异常信息 //出现异常后的处理代码 }finally{ //不管怎么样，有没有异常出现，都会执行的代码 //3.释放资源 } 手动抛出异常//语法： throw anything //catch(e) 这里的e 就会是你throw的这个东西 try{ throw { errMsg:”您的代码出错了！”, errCode:-1 }; }catch (e){ console.log(e); } DOM基本概念DOMDOM Document Object Model 文档对象模型 就是把HTML文档模型化，当作对象来处理 DOM提供的一系列属性和方法可以视作一个工具箱，极大地方便了我们对文档的处理。 内容概念文档(Document)：就是指HTML或者XML文件 节点(Node)：HTML文档中的所有内容都可以称之为节点，常见的节点有 元素节点 属性节点 文本节点 注释节点 元素(Element)：HTML文档中的标签可以称为元素 结构概念父节点 当前节点的父级 子节点 当前节点的子级 兄弟节点 和当前节点同属一个父级的节点 获取元素getElementById 通过id寻找一个元素（找到的是一个元素对象）该方法只能被document对象调用（同一个文档中id不能重复） getElementsByTagName 通过标签名寻找一类元素（找到的是由元素对象组成的伪数组） 即可以被document调用，又可以被元素对象调用，被元素对象调用时表示在该元素对象内部执行查找 设置属性元素对象.属性名 = “属性值”; 等价于 \&lt;标签 属性名=”属性值”> 绑定事件事件三要素 事件源.事件 = function(){ 事件处理程序 }; 等价于 \&lt;标签 事件=”事件处理程序”> 对象方法中的this永远指的是该方法所属的那个对象 常用属性常用标签属性DOM对象的属性和HTML的标签属性几乎是一致的，常用的有src、title、className、href和style 其中className对应就是标签的class属性，但是由于class在JS中是关键字，所以变成了className 内部文本属性innerHTML 获取和设置标签中的内容，设置的内容会当作节点对象被解析到DOM树上 innerText 获取和设置标签中的内容，设置的内容会被当作普通文本（有兼容性问题，旧版ff不支持） textContent 获取和设置标签中的内容，设置的内容会被当作普通文本（有兼容性问题，旧版IE不支持） 可以通过能力检测封装一个自己的设置内部文本的方法并放到自己的JS工具包中 常用表单属性常见的表单元素属性有： type、value、checked、selected、disabled type可以设置input元素的类型 value可以设置input元素的值 checked可以设置input元素是否选中 selected 可以设置下拉列表select中的option是否被选中 disabled 可以设置input元素是否被禁用 文本框获取焦点和失去焦点 获取焦点事件是onfocus 失去焦点事件是onblur (不是所有的标签都有这个事件)更多详细内容可以查阅w3School 自定义属性对象的自定义属性 可以像给对象设置属性一样，给元素对象设置属性 标签的自定义属性 可以通过getAttribute()和setAttribute()设置和获取标签属性，通过removeAttribute()移除标签的属性 正常浏览器中 HTML中有规定的属性 两种方式才可以相互设置和获取 总之用setAttribute设置的就用getAttribute获取用对象的自定义属性设置的就用对象的自定义属性获取 以免出问题 节点节点类型node.nodeType 1表示元素节点 2表示属性节点 3表示文本节点 8注释 节点层次所有获取节点相关属性都没有兼容性问题 childNodes //子节点 children //子元素 虽然不是早期DOM标准中的方法，但是所有浏览器都支持 nextSibling //下一个兄弟节点 nextElementSibling //下一个兄弟元素 有兼容性问题 previousSibling//上一个兄弟节点 previousElementSibling //上一个兄弟元素 有兼容性问题 firstChild //第一个节点 firstElementChild //第一个子元素 有兼容性问题 lastChild //最后一个子节点 lastElementChild //最后一个子元素 有兼容性问题 parentNode //父节点 （一定是元素节点，所以无需处理） 样式属性style属性是对象，style对象的属性是字符串 style只能获取和设置行内样式 DOM对象中style的属性和标签中style内的值几乎一样 只是带有 -的属性名较为特殊（如background-color变成了backgroundColor），因为在JS中 -不能作为标识符 设置和获取样式 //通过对象的style属性只能设置和获取行内样式 //获取样式的时候 如果行内没有该样式 输出空字符串 //设置样式的时候 赋的值是一个字符串 如果这个属性有单位 一定要节点加单位 什么情况通过class控制样式 什么情况通过style控制样式 不严格的说： //如果样式很多 通过 直接控制类名 的方式加样式 //如果样式比较少 通过直接设置比较方便 严格来说： //从标准的角度讲 即使是样式比较少的时候 设置样式也要用类名 //但是有一类情况 是无论如何也必须直接通过JS加的 那就是涉及到计算的时候 动态创建元素插入和移除节点克隆节点 要克隆的节点.cloneNode(布尔值); 在父元素中的最后追加子元素 father.appendChild(要追加的节点对象); 在父元素中的某个子元素前面插入子元素 father.insertBefore(要插入的节点对象,插到这个节点对象的前面); 从父元素中移除子元素 father.removeChild(要移除的子节点对象); 清空父元素 father.innerHTML=””;在清空内容的时候和事件相关的函数不会被销毁，任然遗留在内存中 因此如果方便的话，建议使用father.removeChild(son)来清除 动态创建结构方式一：直接在文档中书写 document.write(“内容”) 方式二：改变元素对象内部的HTML innerHTML=”内容” 方式三：创建或克隆节点并追加 createElement() cloneNode() 通过这两种方法创建出来的元素只是保存在内存中，必须放到页面上才行! 内置方法字符方法 charAt() //获取指定位置处字符 charCodeAt() //获取指定位置处字符的ASCII码 str[0] //ES5，IE8+支持 和charAt()等效 操作方法 concat() //拼接字符串，和+一样 slice() //从start位置开始，截取到end位置，end取不到 substring() //从start位置开始，截取到end位置，end取不到 substr() //从start位置开始，截取length个字符 trim() //只能去除字符串前后的空白 split() //把字符串切割成字符数组 位置方法 indexOf() //返回指定内容在元字符串中的位置, 在数组中的话,返回的是索引 lastIndexOf() //从后往前找，只找第一个匹配的 匹配方法 search() replace() 大小写转换方法 to(Locale)UpperCase() //转换大写 to(Locale)LowerCase() //转换小写 数组方法 图形属性 offset系列offsetWidth和offsetHeight用来得到对象的大小 \@offsetHeight和style.height的区别 demo.style.height只能获取行内样式，如果样式写到了其他地方，甚至根本就没写，便无法获取 style.height是字符串（而且带单位），offsetHeight是数值 demo.style.height可以设置行内样式，offsetHeight是只读属性 因此，一般用demo.offsetHeight来获取某元素的真实宽度/高度，用style.height来设置宽度/高度 \@offsetHeight的构成 offsetHeight = height+padding+border 包括 自身高度 内边距 边框 不包括 外边距 offsetParent\@offsetParent爸爸去哪 返回该对象距离最近的带有定位的父级 如果当前元素的所有父级元素都没有定位（position为absolute或relative），offsetParent为body 如果当前元素的父级元素中有定位（position为absolute或relative），offsetParent取最近的那个父级元素 另外注意offsetParent与parentNode的区别parentNode只找自己的上一级（亲爹） offsetLeft和offsetTop用来得到对象的位置（注意：没有offsetRight和offsetBottom） \@offsetLeft的构成 到距离自身最近的（带有定位的）父元素的 左侧/顶部 的距离 如果所有父级都没有定位则以body 为准 offsetLeft 是自身border左侧到父级padding左侧的距离 \@offsetLeft和style.left的区别 一、style.left只能获取行内样式 二、offsetLeft只读，style.left可读可写 三、offsetLeft是数值，style.left是字符串并且有单位px 四、如果没有加定位，style.left获取的数值可能是无效的 五、最大区别在于offsetLeft以border左上角为基准，style.left以margin左上角为基准 在行内设置以下属性，并且记得加定位 left:20px; margin:20px; 不用死记，offset是计算偏移的，只要记住和定位有关就行了，实在需要详细区分，用的时候自己写个div试一试或者一查文档就知道了。 Math对象\@Math对象常用方法 天花板 向上取整 负数取更大的 Math.ceil(x) 地板 向下取整 负数取更小的 Math.floor(x) 就近取整 rounds a number to the nearest integer 就近取整 有的地方就翻译成四舍五入了 //四舍五入 只看尾数的最高位 01234舍 56789入 //就近取整 会整体比较 以.5为界限 小于的舍 大于的入 等于的 正数入负数舍 //虽然原则不一样但是实际上差别不大 只有一种情况会产生分歧 就是-1.5 //四舍五入是-2 而就近取整-1 Math.round(x) 取绝对值 Math.abs(x) 动画原理动画原理公式动画原理公式： leader = leader + step leader表示盒子当前位置 step表示步长 box.style.left = box.offsetLeft + 10 + “px”; 让setInterval不断执行某个函数修改盒子的位置属性最后就实现了动画的效果 动画函数封装\@动画函数封装 动画函数较为复杂，却又很常用对于这样的函数，我们一般都会进行封装 需求：能够让任意对象移动到指定位置。 动画函数改进\@动画函数改进 然而封装之后的函数还有很多问题，所以我们要对其进行进一步改进 判断运动方向 完善终点检测 终点清除定时器 手动设置对象位置到终点 调用开始先清理定时器，防止多次调用 图形属性scroll系列scroll系列\@scrollHeight和scrollWidth 对象内部实际内容的高度/宽度 \@scrollTop和scrollLeft 被卷去部分的 顶部/左侧 到可视区域 顶部/左侧 的距离 页面滚动座标\@获取页面滚动座标 页面滚动座标非常常用，但是有很大的兼容性问题，可以合写为 var scrollTop = window.pageYOffset || document.documentElement.scrollTop ||document.body.scrollTop || 0; \@封装自己的scroll() 由于非常常用，每次都写上面那一大堆很麻烦。我们可以封装一个自己的scroll()方法，返回页面滚动座标 固定导航案例\@固定导航案例 当页面向下滚动的时候 进行判断 如果页面向上走的距离 大于导航栏到页面顶部的距离时将导航栏的定位改为固定定位 小问题：当导航栏改为固定定位的一瞬间，后面的元素会塌陷。解决方案：给下面的元素添加数值为导航栏高度的padding-top 缓动动画原理公式动画公式 leader = leader + step 匀速动画公式 step = 定值 leader = leader + step 缓动动画公式 step = ( target - leader ) / 10 leader = leader + step 缓动动画的好处 他的移动是有尽头的。不像基础匀速运动那样无限移动。 有非常逼真的缓动效果，实现的动画效果更细腻。 如果不清除定时器，物体永远跟着目标leader在移动。 \@体验缓动动画 函数封装\@缓动动画改进 多次点击按钮重复开启定时器 永远无法真正到达目标 到达目标后清理定时器 \@缓动函数封装 需求：能够让任意对象移动到指定位置 封装缓动框架详细见html代码 图形属性client系列client系列\@clientWidth和clientHeight： 偏移offsetWidth: width + padding + border 卷曲scrollWidth: width + padding 不包含border 内部内容的大小 可视clientWidth: width + padding 不包含border \@clientTop和clientLeft clientTop和clientLeft没什么用 他们就是borderTop和borderLeft（如果有滚动条会包含滚动条的宽度，但谁见过滚动条在顶部或者左侧的？！） 网页可视区宽高\@网页可视区宽高的兼容写法 页面可视区宽高非常常用，但是有很大的兼容性问题，可以合写为 var clientWidth = window.innerWidth|| document.documentElement.clientWidth||document.body.clientWidth|| 0; 事件对象事件： onclick onmouseover onmouseout onfocus onblure 事件对象简介\@事件对象简介 在触发事件时，会产生一个事件对象event，这个对象中包含着与事件有关的信息。 所有浏览器都支持event对象，但支持的方式不同。 比如鼠标操作时候，会添加鼠标位置的相关信息到事件对象中。 普通浏览器支持 传入参数 ie 678 支持 window.event \@事件对象的兼容性写法 var event = event || window.event; 三个重要座标\@三个重要座标 clientX clientY 当前窗口的左上角为基准点 pageX pageY 以当前文档的左上角为基准点 IE678不支持pageX和pageY 但是我们可以采取另一种方式 var pageY = event.pageY || event.clientY +document.documentElement.scrollTop; var pageX = event.pageX || event.clientX +document.documentElement.scrollLeft; screenX screenY 当前屏幕的左上角为基准点 放大镜特效\@计算鼠标在盒子中的位置 制作方法： 鼠标经过显示盒子 鼠标经过small，让mask和big显示；鼠标离开small，让mask和big隐藏。 鼠标经过遮罩跟随 给small绑定鼠标移动事件 获取鼠标在small 内的坐标 计算鼠标在盒子中的座标（鼠标pageX-box到页面左侧的距离；鼠标pageY-box到页面顶部的距离） 然后赋值给mask的top和left（位置是按照左上角算的，所以top值要减去高度的一半，left值要减去宽度的一半） 限定遮罩运动范围 x 最小为0；最大为200，这个200是 small的宽度 -mask的宽度（mask可以向右移动的最大值） 按比例显示大图片 小盒子移动，大盒子要根据比例来移动，比例为： 大图 在 大盒子 里移动的距离 / 小黄 在 小图 里移动的距离 （大图片 - 大盒子 ） / （小盒子 - 小遮罩 ） 800 - 400 / 350 - 175 因为是反方向移动 计算时记得加负号呦！ 可拖拽特效常用事件： onmouseover 鼠标经过 onmouseout 鼠标离开 onmousedown 鼠标按下 onmouseup 鼠标弹起 onmousemove 鼠标移动 \@可拖拽特效 在拖动区域按下鼠标后，在文档中移动鼠标，盒子跟着鼠标坐标走。 鼠标在文档中弹起后，将事件清空。 盒子的位置要进行调整，当鼠标按下时，记录鼠标在盒子中的位置，鼠标移动计算盒子位置的时候减去。 清除选中的内容 window.getSelection ? window.getSelection().removeAllRanges() :document.selection.empty(); 正常浏览器支持：window.getSelection() IE678以下支持：document.selection 注册事件的三种方式element.addEventListener(“事件类型”,”事件处理函数”,”是否使用捕获”) addEventListener的好处是不会将其他事件覆盖，但是有兼容性问题 removeEventListener可以移除指定事件 addEventListener便于管理事件队列 但一般用on的就可以了比较简单 事件的三个阶段1捕获阶段 2目标阶段 执行当前对象的事件处理程序 3冒泡阶段 鼠标事件和键盘事件常用鼠标事件： mousedown、mouseup、mousemove、mouseover、mouseout、click、dblclick onmousedown鼠标按下 onmouseup鼠标弹起 onmouseclick=onmousedown+onmouseup 常用键盘事件： keydown、keypress、keyup onkeydown键盘按下 onkeyup键盘弹起 onkeypress=onkeydown+onkeyup onkeydown onkeyup 输出的是键盘码 onkeypress输出的是ASCII码表 正则表达式正则表达式在网络上有很多资料和工具，用的时候直接在网上搜即可 声明和使用\@正则的声明和使用 通过构造函数定义 var 变量名= new RegExp(/表达式/); 通过直接量定义（简单方便，我们一般用这个） var 变量名= /表达式/; 常用方法，可用于检测传入的字符串是否符合该规则并返回布尔值 exp.test(“要检测的字符串”) 预定义类\@预定义类和转义符 . [\^\n\r] 除了换行和回车之外的任意字符 \d [0-9] 数字字符digit \D [\^0-9] 非数字字符 \w [a-zA-Z0-9_] 单词字符(所有的字母数字和_) word \W [\^a-zA-Z0-9_] 非单词字符 \s [\f\r\n\t\v] 不可见字符 space \S [\^\f\r\n\t\v] 可见字符 转义符 \f 表示换页 form feed \t 表示水平制表符 table \v 表示垂直制表符 vertical table \r,\n,\r\n的区别 在万恶的旧社会，打字机换行（\nnewline）之后只会下移一行，需要回到一行的开头（\r return）才能继续打字 老式的操作系统也继承了打字机的这一特性，但用户换行之后一般都是要回到开头的，因此新式的操作系统为了方便将键盘上的Enter键的含义修改为\r\n或者直接将\n的含义改为“移动到下一行的开头”。 说到转义字符你有没有想起HTML的转义字符呢？（字符实体） \@基本语法补充 | 表示或 或的优先级最低 可以通过()提升优先级 字符类\@字符类 简单类[abc] 表示该位置可以出现的字符 负向类[\^abc] 表示该位置不可以出现的字符 范围类[a-e] 表示该位置可以出现的字符的范围 组合类[a-xA-E0-9] 范围类的组合 \@验证密码强度 边界 量词 括号\@边界 \^ 会匹配行或者字符串的起始位置 \^只有在[]内才表示非 在外边表示开始 \$ 会匹配行或字符串的结尾位置 \^\$在一起 表示必须是这个（精确匹配） \@量词 “*“ 重复零次或更多 x>=0 “+” 重复一次或更多次 x>=1 “?” 重复零次或一次 x=(0||1) {n} n次 x=n {n,} 重复n次或更多 x>=n {n,m} 重复出现的次数比n多但比m少 n\&lt;=x\&lt;=m \@括号总结 ()表示一组 []表示一个字符的位置 {}表示次数 \@验证座机\@验证姓名\@完整版表单验证 常见项目的匹配常见项目的匹配网上有很多（例如搜索常用正则表达式大全），无需记忆，能看懂即可 匹配国内电话号码： /\^0\d{2,3}-\d{7,8}\$/ 匹配姓名： /\^[\u4e00-\u9fa5]{2,}\$/ 匹配腾讯QQ号： /\^[1-9]\d{4,10}\$/ 匹配手机号： /\^(13[0-9]|14[57]|15[0-9]|18[0-9])\d{8}\$/ 匹配邮箱： /\^\w+([+-.]\w+)*\@\w+([-.]\w+)*\.\w+([-.]\w+)*\$/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sublime快捷键]]></title>
      <url>%2F2016%2F11%2F15%2FSublime%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
      <content type="text"><![CDATA[都是个人经验总结,可以在用的途中出现冲突与错误,如果出现问题,可能是编辑器快捷键冲突,请自行修改!!! 操作文件新建文件-输入”html:xt”后 按”Ctrl+E键”或 “tab键” ,可快速生成xhtml 1.0的模板 新建文件-输入”html:5”后 按”Ctrl+E键”或 “tab键” ,可快速生成HTML5的模板 新建文件-输入”!”后 按”Ctrl+E键”或 “tab键” ,可快速生成HTML5的模板 操作编辑器Ctrl+Shift+ [ 折叠代码 (在CSS中表示紧凑格式，在html中为折叠代码) Ctrl+Shift+ ] 折叠代码 (在CSS中表示扩张格式，在html中为恢复折叠代码) Ctrl+Shift+C CSS属性排序 Ctrl+Alt+N 快速创建文件(填上文件扩展名可生成模板，例如：demo.html) Ctrl+Alt+K 刪除不必要的空白 Ctrl+Shift+Alt+F 格式化JS代码 Ctrl+Shift+Alt+M 压缩CSS/JS代码(生成结果为：文件名.min.css、文件名.min.js) Alt+Shift+1 （非小键盘）窗口分屏，恢复默认1屏 Alt+Shift+2 左右分屏-2列 Alt+Shift+3 左右分屏-3列 Alt+Shift+4 左右分屏-4列 Alt+Shift+5 等分4屏 Alt+Shift+8 垂直分屏-2屏 Alt+Shift+9 垂直分屏-3屏 Ctrl+Shift+分屏序号 将当前焦点页分配到分屏序号页 Alt+. 闭合当前标签 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑 操作浏览器F1 Chrome浏览器预览 F2 Firefox浏览器预览 F3 IE浏览器预览 F4 打开调色盘 F11 全屏 F12 默认浏览器预览 操作代码Ctrl+D 选词 （反复按快捷键，即可继续向下同时选中下一个相同的文本进行同时编辑） Ctrl+G 跳转到相应的行 Ctrl+J 合并行（已选择需要合并的多行时） Ctrl+L 选择整行（按住-继续选择下行） Ctrl+M 光标移动至括号内开始或结束的位置 Ctrl+T 词互换 Ctrl+U 软撤销 Ctrl+P 查找当前项目中的文件和快速搜索；输入 \@ 查找文件主标题/函数；或者输入 :跳转到文件某行； Ctrl+R 快速列出/跳转到某个函数 Ctrl+K Backspace 从光标处删除至行首 Ctrl+K+B 开启/关闭侧边栏 Ctrl+KK 从光标处删除至行尾 Ctrl+K+T 折叠属性 Ctrl+K+U 改为大写 Ctrl+K+L 改为小写 Ctrl+K+0 展开所有 Ctrl+Enter 插入行后（快速换行） Ctrl+Tab 当前窗口中的标签页切换 Ctrl+Shift+A 选择光标位置父标签对儿 Ctrl+Shift+D 复制光标所在整行，插入在该行之前 ctrl+shift+F在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找 Ctrl+Shift+K 删除整行 Ctrl+Shift+L 鼠标选中多行（按下快捷键），即可同时编辑这些行 Ctrl+Shift+M 选择括号内的内容（按住-继续选择父括号） Ctrl+Shift+P 打开命令面板 Ctrl+Shift+/ 注释已选择内容 Ctrl+Shift+↑可以移动此行代码，与上行互换 Ctrl+Shift+↓可以移动此行代码，与下行互换 Ctrl+Shift+[ 折叠代码 Ctrl+Shift+] 展开代码 Ctrl+Shift+Enter 光标前插入行 Ctrl+PageDown 、Ctrl+PageUp 文件按开启的前后顺序切换 Ctrl+Z 撤销 Ctrl+Y 恢复撤销 Ctrl+F2 设置/取消书签 Ctrl+/ 注释整行（如已选择内容，同“Ctrl+Shift+/”效果） Ctrl+鼠标左键 可以同时选择要编辑的多处文本 Shift+鼠标右键（或使用鼠标中键）可以用鼠标进行竖向多行选择 Shift+F2 上一个书签 Shift+Tab 去除缩进 Tab 缩进 自动完成 F2 下一个书签 F6 检测语法错误 F9 行排序(按a-z)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[今天开博了]]></title>
      <url>%2F2016%2F11%2F08%2F%E4%BB%8A%E5%A4%A9%E5%BC%80%E5%8D%9A%E4%BA%86%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
