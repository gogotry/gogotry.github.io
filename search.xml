<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[jQuery基础总结]]></title>
      <url>%2F2017%2F01%2F13%2FjQuery%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[为何要学jQueryJS的缺点 使用jQuery可以方便地解决这些问题 jQuery是什么animate.js是我们自己封装的库，而jQuery是别人帮我们封装好的库。 JS库就是把常用的代码放到一个单独的文件中，用的时候直接引用到页面里面就可以了。 jQuery是JS的一个库，封装了开发过程中常用的功能，能够提高开发效率。 jQuery学什么本阶段主要学习如何使用jQuery，其实就是学习jQuery封装好的一些功能方法，这些方法叫做API（ApplicationProgramming Interface应用程序编程接口）。 这些API的共同特点是：几乎全都是方法。 所以，在使用时，都是方法调用，要加小括号()，小括号里面是相应的参数，参数不同，功能不同。 使用jQuery使用步骤： 1引包 2写入口函数 3实现功能（事件处理） 入口函数就是指程序运行的时候最开始调用的函数，也就是程序开始的地方 开始使用jQuery版本介绍最常用的两个版本： 1.12.x和最新推出的3.0.0 两个版本的区别：3.0版本，不支持IE6、7、8 PC端的开发主要使用1.12.x版本 这几天主要学习1.12.x版本： 未压缩版（开发版）：代码可读性高，推荐在开发和学习环境中使用，方便查看源代码。 压缩版：去除了注释、换行、空格、并且将一些变量替换成了a,b,c之类的简单字符，基本没有可读性，推荐在生产和测试环境中使用，因为文件较小，减少网络压力。 引包注意第一点：在使用jQuery之前，先把jQuery文件引到页面中来，如果在使用jQuery之前，没有引用jQuery文件，会报错： 第二点：src路径一定要写正确 如果src路径写错，也会报错： 入口函数jQuery的入口函数: 第一种： \$(document).ready(function(){ //内容 }); 第二种： \$(function(){ //内容 }); 以上两种写法，作用完全相同，用哪个都可以 JS的入口函数： window.onload = function() { //内容 }; jQuery入口函数与JS入口函数的区别 区别一：书写个数不同 JS入口函数只能出现一次，出现多次会存在事件覆盖的问题。 jQuery的入口函数，可以出现任意多次，不会覆盖。 区别二：执行时机不同 JS入口函数是在所有资源加载完成后，才执行。（包括：页面、外部js文件、外部css文件、图片等） jQuery入口函数，是在文档加载完成后就执行。文档加载完成指的是：DOM树加载完成后，就可以操作DOM了，不用等到所有的外部资源都加载完成。 \$ 符号\$就是一个普通的字符，可以用于变量名或函数名 JS命名规范允许出现的字符有：数字、字母、下划线、\$ var \$ = “字符串”; var \$ = 123; function \$(){ alert(“我是函数\$”); } \$(); // 调用上面我们自定义的函数\$ jQuery中的\$实际是一个函数 // jQuery中使用\$的主要场景 \$(document）.ready(function(){}); // 调用入口函数 \$(function(){}); // 调用入口函数 \$(“#btnShow”) // 获取id属性为btnShow的元素 \$(“div”) // 获取所有的div元素 jQuery里面的\$函数，根据传入参数的不同，进行不同的调用，实现不同的功能。返回的是jQuery对象 jQuery这个JS库，为了避免冲突，给这个最重要的\$函数还起了另外一个名字：jQuery jQuery函数跟\$函数的关系：jQuery === \$; jQuery对象jQuery对象与DOM对象DOM对象此处指的是：使用JS操作DOM的方法返回的对象 var btn = document.getElementById(“btnShow”); //普通的DOM对象 jQuery对象此处指的是：使用jQuery操作DOM的方法返回的对象 var \$btn = \$(“#btnShow”); // jQuery的DOM对象 jQuery拿到普通的DOM对象后会对其进行包装，让其成为具有jQuery方法的jQuery对象 jQuery对象转DOM对象第一种方式 var btn1 = \$btn[0]; //通过索引的方式把DOM对象取出来（推荐使用此方式） 第二种方式 var btn2 = \$btn.get(0);//调用get()方法也可以 这两种方式使用哪一种都可以 DOM对象转jQuery对象\$(普通的DOM对象) 图解： jQuery选择器（重点）JS中选择DOM元素的方法考虑兼容性的话，JS提供的选择DOM的方法只有两个： JavaScript选择元素的方法： document.getElementById(); 通过id属性获取指定元素 返回唯一的DOM对象 document.getElementsByTagName(); 通过标签名获取指定元素 返回DOM对象数组（即使只有一个元素） JS提供的选择DOM的方法太少，无法满足开发的需要，所以我们使用jQuery选择器来弥补这方面的不足 什么是jQuery选择器jQuery选择器非常强大，它提供了一组方法，让我们更方便地获取页面中的元素。（类比：CSS的选择器） 强大的原因：jQuery实现了从CSS1到CSS3所有的选择器以及其他常用的选择器 各种选择器之间可以相互代替，所以，平时真正用到的只是最常用的选择器 基本选择器 符号(名称) 说明 用法 # Id选择器 \$(“#btnShow”).css(“color”, “red”); 选择id为btnShow的一个元素（返回值为jQuery对象，下同） . 类名选择器 \$(“.liItem”).css(“color”, “red”); 选择含有类liItem的所有元素 标签名 标签选择器 \$(“li”).css(“color”, “red”); 选择标签名为li的所有元素 用逗号隔开 并集选择器 \$(“div,p,li”).css(“color”, “red”); div、p、li都会被选中 挨在一起 交集选择器 \$(“li.current”).css(“color”, “red”); 选择标签名为li并且类名为current的元素 \@基本选择器 //id选择器 类名选择器 标签选择器 交集选择器 并集选择器 层级选择器、过滤选择器 符号(名称) 说明 用法 层级选择器 空格 后代选择器 \$(“#j_wrap li”).css(“color”, “red”); 选择id为j_wrap的元素的所有后代元素li > 子代选择器 \$(“#j_wrap > ul > li”).css(“color”, “red”); 选择id为j_wrap的元素的所有子元素ul的所有子元素li 常用的过滤选择器 :eq(index) 选择匹配元素中索引号为index的一个元素，index从0开始 \$(“li:eq(2)”).css(“color”, ”red”); 选择li元素中索引号为2的一个元素 :odd 选择匹配元素中索引号为奇数的所有元素，index从0开始 \$(“li:odd”).css(“color”, “red”); 选择li元素中索引号为奇数的所有元素 :even 选择匹配元素中索引号为偶数的所有元素，index从0开始 \$(“li:odd”).css(“color”, “red”); 选择li元素中索引号为偶数的所有元素 筛选选择器（注：都是方法） 符号(名称) 说明 用法 find(selector) 查找指定元素的所有后代元素（子子孙孙） \$(“#j_wrap”).find(“li”).css(“color”, “red”); 选择id为j_wrap的所有后代元素li children(selector) 查找指定元素的直接子元素（亲儿子元素） \$(“#j_wrap”).children(“ul”).css(“color”, “red”); 选择id为j_wrap的所有子代元素ul siblings(selector) 查找所有其他的兄弟元素（不包括自己） \$(“#j_liItem”).siblings().css(“color”, “red”); 选择id为j_liItem的所有兄弟元素 next(selector) 查找下一个兄弟元素 \$(“#j_liItem”).next().css(“color”, “red”); 选择id为j_liItem的下一个兄弟元素 parent(selector) 查找父元素（亲的） \$(“#j_liItem”).parent(“ul”).css(“color”, “red”); 选择id为j_liItem的父元素 eq(index) 查找指定元素的第index个元素，index是索引号，从0开始 \$(“li”).eq(2).css(“color”, “red”); 选择所有li元素中的第二个 样式操作（重点）获取样式// 参数表示要获取的 样式属性名称 \$(selector).css(“font-size”); 此时，会返回”font-size”样式属性对应的值。 设置样式设置单个样式： // 第一个参数表示：样式属性名称 // 第二个参数表示：样式属性值 \$(selector).css(“color”, “red”); 设置多个样式： // 参数为对象 \$(selector).css({“color”: “red”,“font-size”:“30px”}); 类名操作（重点）添加类名addClass(className) 为指定元素添加类名 \$(selector).addClass(“liItem”); 注意：已经说了是添加类名了，把名字传入即可，不要加点！ 移除类名removeClass(className) 为指定元素移除类名 \$(selector).removeClass(“liItem”); //移除指定类名 \$(selector).removeClass(); //不指定参数，表示移除所有类名 判断有没有某个类名hasClass(calssName) 判断指定元素是否包含某个类名 \$(selector).hasClass(“liItem”);//返回true或false 切换类名toggleClass(className) 切换类名，如果没有指定类名就添加，有就移除。 \$(selector).toggleClass(“liItem”); Data属性在元素上存放数据,返回jQuery对象。 data(obj) 可传入key-value形式的数据。 key:存储的数据名 value:将要存储的任意数据 一个参数是获取 两个参数是设置 动画函数jQuery提供的一组常见的动画效果，这些动画是标准的、有规律的效果；同时还提供给我们了自定义动画的功能。 隐藏显示动画show()方法 形式一： // 不带参数，没有动画 \$(selector).show();//作用等同于css(“display”, ”block”) 形式二： //参数为数值，表示：执行动画时长 \$(selector).show(2000);//单位为毫秒（ms），2000毫秒即2秒 形式三： //参数为字符串，是jQuery预设的值，共有三个，分别是：slow、normal、fast \$(selector).show(“slow”); //slow：600ms、normal：400ms、fast：200ms 形式四： // 参数一可以是数值类型或者字符串类型 // 参数二表示：动画执行完后立即执行的回调函数 \$(selector).show(2000, function() {}); hide()方法 \$(selector).hide(); \$(selector).hide(1000); \$(selector).hide(“slow”); \$(selector).hide(1000, function(){}); 显示隐藏切换 \$(selector).toggle(speed,callback); jQuery预设的三组动画效果的语法几乎一致： 参数可以有两个，第一个是动画的执行时长(可以是指定字符或毫秒)，第二个是动画执行完成后的回调函数。 滑入滑出动画滑入效果 作用：让元素以下拉动画效果展示出来 \$(selector).slideDown(speed,callback); 滑出动画 作用：让元素以上拉动画效果隐藏起来 \$(selector).slideUp(speed,callback); 滑入滑出切换 \$(selector).slideToggle(speed,callback); 淡入淡出动画淡入效果 作用：让元素以淡淡的进入视线的方式展示出来 \$(selector).fadeIn(speed, callback); 淡出效果 作用：让元素以渐渐消失的方式隐藏起来 \$(selector).fadeOut(1000); 淡入淡出切换 作用：通过改变不透明度，切换匹配元素的显示或隐藏状态 \$(selector).fadeToggle(‘fast’,function(){}); 淡淡达到效果 改变不透明度到某个值 与淡入淡出的区别：淡入淡出只能控制元素的不透明度从 完全不透明到完全透明；而fadeTo可以指定元素不透明度的具体值。并且时间参数是必需的！ 作用：调节匹配元素的不透明度 // 用法有别于其他动画效果 // 第一个参数表示：时长 // 第二个参数表示：不透明度值，取值范围：0-1 \$(selector).fadeTo(1000, .5); //0全透，1全不透 // 第一个参数为0，此时作用相当于：.css(“opacity”, .5); \$(selector).fadeTo(0, .5); 动画方法总结 有规律的体现： jQuery提供的这几个动画效果控制的CSS属性包括：高度、宽度、不透明度。{height:400px;width:300px; opacity:.4;} 这三个CSS属性的共性是：属性值只有一个（合写的不行），并且这个值是数值（至少经过准换后能变为数值）。 自定义动画注意：所有能够执行动画的属性必须只有一个数字类型的值。 比如：要改变字体大小，要使用：fontSize（font-size），不要使用：font 动画支持的属性： http://www.w3school.com.cn/jquery/effect_animate.asp 作用：执行一组CSS属性的自定义动画 // 第一个参数表示：要执行动画的CSS属性（必选） // 第二个参数表示：执行动画时长（可选） // 第三个参数表示：动画执行完后立即执行的回调函数（可选） \$(selector).animate({params},speed,callback); 停止动画作用：停止当前正在执行的动画 为什么要停止动画？ 如果多个动画在同一元素上执行，对这个元素来说，后面的动画将被放到队列中，从而形成动画队列。（联想：排队进站） 上一个动画执行完成，下一个动画才能执行，但是这样的效果有时不是我们想要的。 // 第一个参数表示是否清空所有的后续动画 // 第二个参数表示是否立即执行完当前正在执行的动画 \$(selector).stop(clearQueue,jumpToEnd); 解释： 当调用stop()方法后，当前动画停止于当前样式的只（不会到达目标值），队列中的下一个动画会立即开始。 如果参数clearQueue被设置为true，那么队列中剩余的动画就被删除了，永远不会再执行。 如果参数jumpToEnd被设置为true，那么当前动画会停止，但是参与动画的每一个CSS属性将被立即设置为它们的目标值。比如：slideUp()方法，那么元素会立即隐藏掉。如果存在回调函数，回调函数也会立即执行。 另外： 如果元素动画还没有执行完，此时调用sotp()方法，那么当前动画将会停止。并且由于本次动画没有执行完成，本次动画的回调函数也不会被执行（下一次的会照常执行）。 常用方式： \$(selector).stop();//当前动画停止于此刻的样式状态 后面的动画继续执行 节点操作（重点）动态创建元素// \$()函数的另外一个作用：动态创建元素 var \$span = \$(“\我是一个span元素\”); 添加元素（重点）append()（重点） 作用：在被选元素内部的最后一个子元素（或内容）后面插入内容（页面中存在或者创建出来的元素都可以） //在\$(selector)中追加\$node \$(selector).append(\$node); //在\$(selector)中追加div元素，参数为htmlString \$(selector).append(‘\\‘); 如果是页面中存在的元素，那么调用append()后，会把这个元素从原先的位置移除，然后再插入到新的位置。 如果给多个目标追加一个元素，append()方法内部会将这个元素复制多份，然后追加到多个目标中。（最好不要这么做） 常用参数：htmlString 或 jQuery对象 不常用操作（了解即可）：（用法跟append()方法基本一致） prepend() 作用：在元素的第一个子元素前面追加内容或节点 \$(selector).prepend(node); after() 作用：在被选元素之后，作为兄弟元素插入内容或节点 \$(selector).after(node); before() 作用：在被选元素之前，作为兄弟元素插入内容或节点 \$(selector).before(node); html创建元素作用：设置或返回所选元素的html内容（包括 HTML 标记） 设置内容的时候，如果是html标记，会动态创建元素，此时作用跟JS里面的innerHTML属性相同 // 动态创建元素 \$(selector).html(‘\传智播客\’); // 获取html内容 \$(selector).html(); 清空元素//清空指定元素的所有子元素 \$(selector).empty(); \$(selector).html(“”); //”自杀”把自己（包括所有内部元素）从文档中删除掉 \$(selector).remove(); 复制元素// 复制\$(selector)所匹配到的元素 // 返回值为复制的新元素 \$(selector).clone(); 推荐 使用html(“\\”)方法来创建元素 使用html(“”)清空元素（但是这样无法清除对象身上的事件，造成内存泄漏（少量的无所谓）） 代码/文本/值html() 方法 作用：设置或获取匹配元素的代码内容 \$(selector).html(); //获取 \$(selector).html(‘\传智播客\’); //设置 text() 方法 作用：设置或获取匹配元素的文本内容 \$(selector).text();//获取操作不带参数 （注：会把所有匹配到的元素内容拼接为一个字符串，不同于其他获取操作！） \$(selector).text(“我是内容”);//设置操作带参数，参数表示要设置的文本内容 val()方法 作用：设置或返回表单元素的值，例如：input,select,textarea的值 \$(selector).val();// 获取匹配元素的值，只匹配第一个元素 \$(selector).val(“具体值”);// 设置所有匹配到的元素的值 属性操作设置属性： // 第一个参数表示：要设置的属性名称 // 第二个参数表示：该属性的值 \$(selector).attr(“title”, “传智播客”); 获取属性： // 参数为：只传入要获取的属性的名称即可返回指定属性的值 \$(selector).attr(“title”); 移除属性： // 参数为：要移除的属性的名称 \$(selector).removeAttr(“title”); 注意：表单元素中属性值为布尔值的属性，如checked、selected、disabled要使用.prop()方法 \$(selector).prop(“checked”); //获取 \$(selector).prop(“checked”, true ); //设置 细节参考：http://api.jquery.com/prop/ 尺寸位置尺寸操作在jQuery中有一套可以非常方便的操作元素尺寸的系列方法。 height()与width()：设置或者返回元素的高度及高度,返回结果是数值类型。 innerWidth()与innerHeight()：包括padding outerWidth()与outerHeigth()：包括padding、border outWidth(true)与outerHeight(true)：包括padding、border、margin 注：只有height()与width（）可以进行设置操作，innerWidth（）、outWidth（）都是只读属性，只能获取、不能设置。 位置操作scrollTop() 作用：获取或者设置元素垂直方向滚动的位置 //获取 \$(selector).scrollTop(); //设置，参数为数值类型 \$(selector).scrollTop(100); scrollLeft() 作用：获取或者设置元素水平方向滚动的位置 //获取 \$(selector).scrollLeft(); //设置，参数为数值类型 \$(selector).scrollLeft(100); offset() 作用：获取或设置元素相对于document左上角的位置 //无参数表示获取，返回值为：{left:num, top:num}，值是相对于document的位置 \$(selector).offset(); //有参数表示设置，参数推荐使用数值类型 \$(selector).offset({left:100, top: 150}); 注意：使用offset操作，如果元素没有设置定位(默认position:static)，则会把position修改为relative.会修改left、top position() 获取相对于其最近的有定位的父元素的位置。相当于之前JS中的offsetLeft和offsetTop // 获取，返回值为对象：{left:num, top:num} \$(selector).position(); 注意：position方法只能获取，不能设置 序列化表单提交内容serialize()序列表表格内容为字符串。 serializeArray()序列化表格元素 (类似 ‘.serialize()’ 方法) 返回 JSON 数据结构数据。 返回的JSON对象是由一个对象数组组成的，其中每个对象包含一个或两个名值对——name参数和value参数（如果value不为空的话）。 jQuery基础课程 — 其他知识 jQuery事件事件机制jQuery的事件机制，指的是：jQuery对JavaScript操作DOM事件的封装，包括了：事件绑定、事件解绑、事件触发。 JavaScript： btn.onclick = function() {}; //给这个按钮绑定事件 jQuery： \$btn.click(function() {}); //给按钮绑定事件 click是一个方法，内部是对onclick事件的封装 事件的发展历程（了解）简单事件绑定 >> bind事件绑定 >> delegate事件绑定 >> on 简单事件绑定： click(handler) 单击事件 dbclick(handler) 双击事件 blur(handler) 失去焦点事件 focus(handler) 获得焦点事件 mouseenter(handler) 鼠标进入事件 mouseleave(handler) 鼠标离开事件 keydown(handler) 键盘按下事件 keyup(handler) 键盘弹起事件 bind方式 作用：给匹配到的元素直接绑定事件（不推荐，1.7以后的jQuery版本被on取代） // 绑定单击事件处理程序 第一个参数：事件类型 第二个参数：事件处理程序 \$(“p”).bind(“click mouseenter”, function(e){ //事件响应方法 }); 优点：可以同时绑定多个事件，比如：bind(“mouseenter mouseleave”, function(){}) 缺点：仍然无法给动态创建的元素绑定事件 delegate方式 作用：给匹配到的元素绑定事件，对支持动态创建的元素有效（特点：节省资源，支持动态创建的元素）（不推荐，1.7以后的jQuery版本被on取代） // 第一个参数：selector，要绑定事件的元素 // 第二个参数：事件类型 // 第三个参数：事件处理函数 \$(“.parentBox”).delegate(“p”, “click”, function(){ //为 .parentBox下面的所有的p标签绑定事件 }); 与前两种方式最大的优势：减少事件绑定次数提高效率，支持动态创建出来的元素绑定事件 事件绑定（重点）我们现在用on的方式来绑定事件（最现代的方式，强烈建议使用的方式） jQuery1.7版本后，jQuery用on统一了所有的事件处理的方法 作用：给匹配的元素绑定事件，包括了上面所有绑定事件方式的优点 语法： //第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件） // 第二个参数：selector, 执行事件的后代元素 // 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用 // 第四个参数：handler，事件处理函数 \$(selector).on(events[,selector][,data],handler); // 表示给\$(selector)绑定事件，当必须是它的内部元素span才能执行这个事件 \$(selector).on( “click”,“span”, function() {}); // 绑定多个事件 // 表示给\$(selector)匹配的元素绑定单击和鼠标进入事件 \$(selector).on(“click mouseenter”, function(){}); 事件解绑unbind() 方式（废弃） 作用：解绑 bind方式绑定的事件 \$(selector).unbind(); //解绑所有的事件 \$(selector).unbind(“click”); //解绑指定的事件 undelegate() 方式（废弃） 作用：解绑delegate方式绑定的事件 \$( selector ).undelegate(); //解绑所有的delegate事件 \$( selector).undelegate( “click” ); //解绑所有的click事件 off解绑on方式绑定的事件（重点） //解绑 所有类型 所有事件（直接绑定的和委托的都解绑） \$(selector).off(); //解绑 click事件 所有事件（直接绑定的和委托的都解绑） \$(selector).off(“click”); //解绑 click事件 只解绑委托的 \$(selector).off( “click”, “**” ); //第二个参数表示的是要找委托的 选择器“**”表示选择所有委托的 事件触发简单事件触发 \$(selector).click(); //触发 click事件 trigger方法触发事件 \$(selector).trigger(“click”); triggerHandler触发 事件响应方法，不触发浏览器行为 比如:文本框获得焦点的默认行为 \$(selector).triggerHandler(“focus”); jQuery事件对象介绍event.type 事件类型：click，dbclick… event.which 鼠标的按键类型：左1 中2 右3 event.pageX 鼠标相对于页面左边的位置 event.target 触发该事件的元素（事件目标） event.currentTarget 当前对象（相当于this） event.delegateTarget 代理对象 event.keyCode 键盘按键代码 event.stopPropagation()； 阻止事件冒泡 event.preventDefault(); 阻止默认行为 return false; event.data 传递给事件处理程序的额外数据 return false; // JQ的事件中return false可以阻止冒泡和默认行为 JS中只阻止默认行为 this：事件处理函数被哪个元素对象调用，this就指向哪个元素对象。 jQuery补充（了解）链式编程// 链式编程代码示例 \$(“li”).parent(“ul”).parent().siblings(“div”).children(“div”).html(“内容”); 链式编程原理：return this; 通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回this end(); // 结束当前链最近的一次过滤操作，并且返回匹配元素之前的一次状态。 隐式迭代隐式迭代：在方法的内部会对匹配到的所有元素进行循环遍历，执行相应的方法；无需我们再手动地进行循，方便我们使用。 // 设置操作 \$(“div”).css(“color”, “red”); 如果是获取多个元素的值，大部分情况下返回第一个元素的值。 // 获取操作 \$(“div”).css(“color”); // 返回第一个元素的值 each方法大部分情况下是不需要使用each方法的，因为jQuery的隐式迭代特性。但是如果要对每个元素做不同的处理，这时候就要用each方法了。 作用：遍历jQuery对象集合，为每个匹配的元素执行一次指定函数 // 参数一表示当前元素在所有匹配元素中的索引号 // 参数二表示当前元素（DOM对象） \$(selector).each(function(index,element){}); 多库共存此处多库共存指的是：jQuery占用了\$和jQuery这两个变量名。当在一个页面中引用了jQuery，并且引用的其他库（或者其他版本的jQuery库）中也用到了\$或者jQuery这两个变量名，这时就有了多库共存的问题。 // 模拟另外的库使用了 \$ 这个变量名。此时，就与jQuery库产生了冲突 var \$ = { name : “itecast” }; 解决方式： //让jQuery释放对\$的控制权，让其他库能够使用\$。此后，只能用jQuery来调用jQuery提供的方法 \$.noConflict(); jQuery插件（了解）jQuery虽然功能强大，但也不是包含所有的功能，可以通过插件来扩展它的功能： 当你需要某个插件的时候，你可以“安装”到jQuery上面，然后使用。 当你不再需要这个插件，那你就可以从jQuery上“卸载”它。 （联想：手机软件，安装的app就好比插件，用的时候安装上，不用的时候卸载掉） 使用插件jQuery.color.js animate()自定义动画：不支持背景的动画效果animate动画支持的属性列表 使用步骤： 1.引入jQuery文件 2.引入插件 3.使用插件 制作插件如何创建jQuery插件：http://learn.jquery.com/plugins/basic-plugin-creation/ 为\$函数扩展方法 \$.pluginName = function() {}; 为jQuery对象扩展方法 \$.fn. pluginName = function() {}; jQueryUI使用场景：网站的管理后台 jQueryUI专指由jQuery官方维护的UI（用户接口）方向的插件。 官方API：http://api.jqueryui.com/category/all/ 其他教程：jQueryUI教程 基本使用: 1.引入jQueryUI的样式文件 2.引入jQuery 3.引入jQueryUI的JS文件 4.使用jQueryUI功能]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript基础总结]]></title>
      <url>%2F2017%2F01%2F03%2Fjavascript%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[介绍JS的组成 ECMAScript 规定了js的语法标准以及规范 DOM document object model 文档对象类型提供了一套操作DOM元素的API(应用程序接口) BOM Browser object model 浏览器对象模型 提供了一套操作浏览器相关内容的API 输出语句\@常用输出语句 代码注释\@代码注释 //单行注释 /* 多行注释 */ 书写多行注释的时候注意不要发生嵌套 /** + 回车 用于函数的说明 书写位置\@书写位置 可以写在HTML页面内的任意位置或者从外部引用（可以类比样式代码的书写位置） 标签属性\@script标签的属性 type类型 src 地址 async异步加载，加载完成立即执行defer异步加载，页面上的东西都执行完了才执行（了解即可!!!） 变量变量的命名规范\@变量的命名 规则(必须遵守) 区分大小写 不能是关键字和保留字 由字母、数字、下划线、\$ 组成且开头不能是数字 tips:关键字和保留字那么多，记不住怎么办？ 首先，关键字就是你平时用的那些，而保留字在非严格模式下不能使用的只有： class enum extends super const export import 而且，其实如果你使用了关键webstorm是有提示的，但是常见的几个最好还是记住 规范(建议遵守) 变量的名称要有实际意义 规则中所说的字母包括ASCII和Unicode字母字符，如汉字，但不推荐使用 变量的命名遵守驼峰命名法，首字母小写,第二个单词的首字母大写 例如：userName 变量的声明赋值\@变量的声明和赋值 书写格式 var 变量名 = 值 练习\@交换两个变量的值 \@不使用第三个变量 弱类型\@弱类型 JavaScript是弱类型的语言，即声明不同数据类型的变量使用同一个关键字var 数据类型数据类型声明的时候不用考虑类型，但是处理和计算的时候要考虑类型 简单数据类型(值类型) number数值型 string字符串型 boolean布尔型 undefined 未定义 null空 复杂数据类型(引用类型) object对象 function 函数 Array 数组 Data 日期 RegExp 正则 Math String NumberBoolean 使用typeof关键字可以查看变量的数据类型 数值类型\@数值类型 字面量 var num = 数字; 浮点数 计算浮点数时会丢失精度 我们通常用整数的计算来表示浮点数的计算 不要以两个浮点数是否相等作为条件判断的依据（判断范围还是可以的） NaN NaN是数值类型 NaN不等于自身 isNaN( ) 不是有意义的数值返回true 字符串类型\@字符串型 字面量 var str = “字符串”; 字符串的长度 str.length length就是长度的意思 转义符 \n 换行 \’单引号 \”双引号 \\斜杠 字符串的不可变性 由于字符串有不可变性，在大量拼接字符串的时候会非常消耗内存。 布尔类型\@布尔类型 所有类型的值都可以转化成布尔值 会转化成false的值有： 空字符串 数值零NaN undefined null undefined类型\@undefined 表示声明但未赋值的变量 手动赋值为 undefined对象属性不存在的时候,这个属性的值为undefined 变量不可能自动为 null 除非手动赋值 当给别人提供一个返回对象的方法或者函数的时候当函数中创建这个对象失败，或者获取对象失败，无法正常返回对象的时候，就应该返回null 类型转换转换成字符串\@转换成字符串 将任意类型转化为字符串 String(值) 大部分类型都有toString方法 值.toString() 小技巧 值+”” 转化成数值型\@转换成数值 将任意类型转化为数值型 Number(值) 将字符串转化为数值 parseInt(“字符串”) parseFloat(“字符串”) 小技巧 值-0 转化成布尔值\@转换成布尔值 将任意类型转化为布尔值 Boolean(值) 条件判断中会自动转换 if(值) 小技巧 !!值 获取数据类型typeof 关键字语法 typeof 变量 返回值: 字符串的 类型 (返回的内容也是字符串) 使用typeof关键字去获取复杂数据类型的类型的时候 只能获取到object typof是个关键字，后面加括号，只是对后面的代码进行分组，提升了优先级 操作符\@运算符 一元运算符\@递增和递减 递增++ 递减– a++ 先参与运算 后自加 ++a 先自加 后参与运算 逻辑运算符\@逻辑运算符 &amp;&amp; 与 两个操作数都为true，结果为true 只要有一个操作数为false，结果为false || 或 只要有一个操作数为true，结果为true 两个操作数都为false，结果为false ! 非 逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反 只有一个操作数 逻辑运算 &amp;&amp; 和 || 都采取短路运算，即第一个能够决定结果就不再看第二个了 &amp;&amp; 的要求比较宽松 要两个都是true才是true所以看到第一个是false就没有必要继续完后看了 console.log(false &amp;&amp; 不管了); || 的要求比较严格 要两个都是false才是false所以看到第一个是true就没有必要继续完后看了 console.log(true || 不管了); 短路运算（了解） &amp;&amp;和 ||不但可以操作布尔类型的值，对其他类型的值也可以进行操作，并返回可以决定表达式结果的那个值。 赋值运算符\@赋值运算符 a+=b 等价于 a=a+b 关系运法符 \&lt; \&lt;= >= > == != 相等和不相等 === !== 全等和不全等 注意: 当引用类型的数据和值类型的数据进行运算（+-*/ == > \&lt;）的时候 会调用引用类型数据的valueOf方法，获取返回值，如果这个返回值可以参与运算，那么就直接用了 如果不能参与运算，再去调用该引用类型数据的toString方法,拿这个返回值来参与运算 例 //字面量 //{} //[]//1.只要遇到字面量，必然是在创建对象console.log([] == []);//false console.log({} == {});//false//引用类型的数据和值类型console.log([] == ![]);//调用上述方法后就相当于console.log(“” == false); 运算符的优先级 优先级从高到底 () 优先级最高 一元运算符 ++ – ! 算数运算符 先* / % 后 + - 关系运算符 > >= \&lt; \&lt;= 相等运算符 == != === !== 逻辑运算符 先&amp;&amp; 后|| 值类型和引用类型 值类型：直接存储数据本身的数据，就是值类型的数据 引用类型：存储的是数据的地址，数据单独存储，这种数据就是引用类型的数据 特征: 值类型的数据在赋值的时候，会将存储的数据复制一份交给新的变量，两个变量值相等，但是存储的空间不一样，修改其中一个，另外一个不会受影响 引用类型的数据在赋值的时候，会将对象的地址复制一份交给新的变量，此时两个变量同时指向同一个对象，通过其中一个变量对对象进行修改，另外一个变量也会受到影响 var num = 100; function test(n){ //n = num //值类型的赋值 n = 1000; } test(num); console.log(num);//100 var obj1 = { name:”高富帅”; } function test(obj){ //obj = obj1; //引用类型的赋值 obj.name = “矮穷丑”; } test(obj1); console.log(obj1.name);//矮穷丑 var obj1 = { name:”高富帅” } function test(obj){ obj.name = “矮穷丑” obj = { name : “白富美” } obj.name = “土肥圆”; return obj.name; } console.log(test(obj1));//土肥圆 console.log(obj1.name);//矮穷丑 语句选择语句ifif (condition) { statement1 } else if (condition) { statement2 } else { statement3 } 三元表达式表达式1 ? 表达式2 : 表达式3 选择语句switchswitch (expression) { case value: statement break; case value: statement break; default: statement } 循环语句forfor (initialization; expression; post-loop-expression)｛ statement ｝ initialization表示：初始化表达式 expression表示：控制表达式 post-loop-expression表示：循环后表达式 三者都是可选的 循环语句 for-in &amp; 关键字in的使用 for-in 遍历对象的键 语法 for (var k in obj)｛ console.log(k); ｝ 注意：对象的属性全都是字符串类型的 注意： 在for-in中使用键访问对象的值的时候，不能使用点语法 只能使用中括号 又叫做 关联数组语法 判断对象是否可以访问某个属性 语法： 属性名 in 对象 console.log(“toString” in obj); 返回值： 布尔值，表示能或者不能 break和continuebreak跳出当前循环，执行循环后的语句 continue跳出当前循环，继续执行循环 循环语句whilewhile语句 先判断后执行 while(expression) statement do while 语句 先执行后判断 do {statement} while (expression); 数组数组的声明通过构造函数声明（更加通用） var arr = new Array(“a”, “b”, “c”); 通过字面量声明（更加简便） var arr = [“a”,”b”,”c”]; 数组的赋值和取值赋值 数组名[索引号] = 值 //arr[0]=100 取值（通过数组名和索引即可取到对应的值） 数组名[索引号] //console.log(arr[0]) 数组的遍历数组的索引是从0开始的 数组的长度可以通过arr.length获取 由于数组的索引从0开始，所以最后一个值的索引为arr.length-1 通过for循环遍历数组 for (var i = 0; i \&lt;= arr.length - 1; i++) { console.log(arr[i]); } 可简写为： for (var i = 0; i \&lt; arr.length; i++) { console.log(arr[i]); } \@数组length的应用 往数组中添加新元素，数组的length会增加 通过给arr.length赋值可以改变数组的长度 冒泡排序\@冒泡排序 var arr = [65, 97, 76, 13, 27, 49, 58];//循环控制趟数for (var i = 0; i \&lt; arr.length - 1; i++) {//控制两两比较的次数for (var j = 0; j \&lt; arr.length - 1; j++) {//两两比较 从小到大排序if (arr[j] > arr[j + 1]) {//交换位置var tmp = arr[j];arr[j] = arr[j + 1];arr[j + 1] = tmp;}}} 函数函数的声明和调用函数的声明 function 函数名 () { //函数体 } 函数的调用 函数名(); 函数的参数有参数的函数的声明（声明中的参数只是一个占位符，没有实际的值，是形式参数，即形参） function 函数名 (参数1,参数2,参数3…) { //函数体 } 有参数的函数的调用（调用时传入的参数才是有真正数值的参数，是实际参数，即实参） 函数名(参数1,参数2,参数3…); 函数的返回值在函数中通过return关键字将要返回值返回 return 要返回的值; 函数高级概念\@参数详解 在JS中实参的个数和形参的个数可以不一致 \@返回值详解 函数的返回值是什么，调用这个函数就相当于调用什么，如果没有返回值则为undefined 函数在执行完成return语句后便会退出函数，后面的代码不会执行 \@三种定义方式 函数声明 function fn1() { //函数体 } 函数表达式 var fn2 = function () { //函数体 }; Function Var 函数名= new Function fn1() \@匿名函数 匿名函数（没有名字的函数） 变量 = function () { //函数体 } \@递归调用 程序调用自身的编程技巧称为递归 \@回调函数 函数也是一种普通的数据类型 因此函数也可以被当作参数传递 被当作参数传递的函数叫做回调函数 对象从宏观的角度讲，对象是对客观事物的抽象，事物的特征可以用属性表示，事物的行为可以用方法表示 从微观的角度讲，对象就是一种数据类型，通过对象可以方便地对变量和函数进行管理 初期我们甚至可以把他简单地理解为一个工具箱 键值对键值对就是一种对应关系，通过键能够方便地找到值 键:值 key:value k:v 对象的声明通过构造函数声明（更加通用） var obj= new Object(); 通过字面量声明（更加简便） var obj= {}; 对象具有属性和方法 属性 用来描述对象的特征 一般是名词 对应变量 方法 用来描述对象的行为 一般是动词 对应函数 属性属性的定义 对象.属性名 = 值 属性的调用 对象.属性名 方法方法的定义 对象.方法名 = function(){ //函数体 }; 方法的调用 对象.方法名() 关于this 的指向全局上下文:全局运行上下文中（在任何函数体外部），this 指代全局对象 函数上下文:对象方法中的this指的是该方法所属的对象 直接调用中的this指的是全局对象总之，函数上下文中（在函数内部），this指的是当前函数所属的对象 构造函数中:当一个函数被作为构造函数使用时（前面加new关键字），new关键字会让this的指向改变，并让其成为当前函数的返回值 批量创建对象工厂模式创建对象为什么要优化创建对象的方式 因为对象在项目中被大规模的使用，所以每一点小小的改进都会对项目整体效率带来很大的提升，现阶段同学们还不可能有深刻的体会，只是让大家了解一下，后面讲项目大家自然就明白了。 \@工厂模式创建对象 同类型对象，只是一些属性的值不同，通过对象字面量创建对象每次都要写那么多东西很费劲，我们可以将创建对象的过程封装进一个函数，只把发生变化的属性作为参数传入，从而简化对象创建的过程。 但是工厂模式只是创建出来一个普通的对象并将其返回，因此无法判断实例的具体类型。 构造函数创建对象\@this和new 利用new 关键字可以声明新的对象。new关键字可以让构造函数中this的指向改变，并让构造函数把this返回。 \@构造函数 构造函数也是函数，只不过会默认返回一个对象。 \@构造函数创建对象 通过构造函数创建对象更方便（不需要创建对象并返回）。更重要的是可以通过instanceof来判断实例的类型了。 对象的动态创建对象的动态特性就是指，在对象创建出来之后，可以随时为对象添加成员的这种特性，就是动态特性 语法: 成员：属性和方法 利用对象动态特性给对象添加成员的方式 点语法 对象名.属性名 = 值 关联数组语法 对象名[“属性名”] = 值 案例 obj[[]] = “我是一个怪物！！”; //相当于做了如下操作 //obj[“[object Object]”] = “我是一个怪物！！”; delete关键字语法：delete 变量名/对象.属性名 返回值：boolean类型 表示是否删除成功 不可信！！！ 删除未使用var声明的变量 (使用var的删不掉)a = 10; console.log(delete a); console.log(a); 删除对象的属性var obj = { // name : “郑天杨” // }console.log(delete obj.name);//Object.defineProperty() 表示是否可以删除对象的属性 后面js高级会学 delete删除数组元素delete删除数组元素的时候，数组原本的其他数据的索引不会变化而且数组的长度也不会变化！！只是删除了索引及其对应的值 其他概念对象字面量\@对象字面量 var o = { name : “zs”, age : 18, sayHi : function() { console.log(this.name); } }; 对象标记法\@对象标记法 JavaScript ObjectNotation（JavaScript对象标记法）是仿照JS中对象字面量的格式去书写的一串用来记录对象数据的字符串，可以用于数据传输。将来学习AJAX会详细学习。 访问属性的两种方式\@访问属性的两种方式 点语法（简单） 对象.属性名 中括号（灵活） 对象[“属性名”] 遍历的两种方式\@遍历的两种方式 通过for可以对集合进行有序的遍历 通过forin可以对集合进行有序的遍历 for(var k in obj) { 语句 } k变量代表的是json中的各个属性（key）和 var i = 0中的i是一个意思 名字不同而已 DOM操作增 删 改 查 (下面有详细介绍)增//document.createElement //innerHTML //cloneNode //appendChild //insertBefore 删//innerHTML 改//innerText //setAttibute //style 查//document.getElementById //document.getElementsByTagName //document.getElemnetsByClassName 异常处理异常的最大特征就是，会报错，后面的代码将不会继续执行 语法异常 语法错误导致的异常 浏览器差异导致的异常 运行时异常 异常处理语句try{ //可能会出错的代码 //1.打开了资源 //2.操作资源 }catch (e){ //e 就是异常信息 //出现异常后的处理代码 }finally{ //不管怎么样，有没有异常出现，都会执行的代码 //3.释放资源 } 手动抛出异常//语法： throw anything //catch(e) 这里的e 就会是你throw的这个东西 try{ throw { errMsg:”您的代码出错了！”, errCode:-1 }; }catch (e){ console.log(e); } DOM基本概念DOMDOM Document Object Model 文档对象模型 就是把HTML文档模型化，当作对象来处理 DOM提供的一系列属性和方法可以视作一个工具箱，极大地方便了我们对文档的处理。 内容概念文档(Document)：就是指HTML或者XML文件 节点(Node)：HTML文档中的所有内容都可以称之为节点，常见的节点有 元素节点 属性节点 文本节点 注释节点 元素(Element)：HTML文档中的标签可以称为元素 结构概念父节点 当前节点的父级 子节点 当前节点的子级 兄弟节点 和当前节点同属一个父级的节点 获取元素getElementById 通过id寻找一个元素（找到的是一个元素对象）该方法只能被document对象调用（同一个文档中id不能重复） getElementsByTagName 通过标签名寻找一类元素（找到的是由元素对象组成的伪数组） 即可以被document调用，又可以被元素对象调用，被元素对象调用时表示在该元素对象内部执行查找 设置属性元素对象.属性名 = “属性值”; 等价于 \&lt;标签 属性名=”属性值”> 绑定事件事件三要素 事件源.事件 = function(){ 事件处理程序 }; 等价于 \&lt;标签 事件=”事件处理程序”> 对象方法中的this永远指的是该方法所属的那个对象 常用属性常用标签属性DOM对象的属性和HTML的标签属性几乎是一致的，常用的有src、title、className、href和style 其中className对应就是标签的class属性，但是由于class在JS中是关键字，所以变成了className 内部文本属性innerHTML 获取和设置标签中的内容，设置的内容会当作节点对象被解析到DOM树上 innerText 获取和设置标签中的内容，设置的内容会被当作普通文本（有兼容性问题，旧版ff不支持） textContent 获取和设置标签中的内容，设置的内容会被当作普通文本（有兼容性问题，旧版IE不支持） 可以通过能力检测封装一个自己的设置内部文本的方法并放到自己的JS工具包中 常用表单属性常见的表单元素属性有： type、value、checked、selected、disabled type可以设置input元素的类型 value可以设置input元素的值 checked可以设置input元素是否选中 selected 可以设置下拉列表select中的option是否被选中 disabled 可以设置input元素是否被禁用 文本框获取焦点和失去焦点 获取焦点事件是onfocus 失去焦点事件是onblur (不是所有的标签都有这个事件)更多详细内容可以查阅w3School 自定义属性对象的自定义属性 可以像给对象设置属性一样，给元素对象设置属性 标签的自定义属性 可以通过getAttribute()和setAttribute()设置和获取标签属性，通过removeAttribute()移除标签的属性 正常浏览器中 HTML中有规定的属性 两种方式才可以相互设置和获取 总之用setAttribute设置的就用getAttribute获取用对象的自定义属性设置的就用对象的自定义属性获取 以免出问题 节点节点类型node.nodeType 1表示元素节点 2表示属性节点 3表示文本节点 8注释 节点层次所有获取节点相关属性都没有兼容性问题 childNodes //子节点 children //子元素 虽然不是早期DOM标准中的方法，但是所有浏览器都支持 nextSibling //下一个兄弟节点 nextElementSibling //下一个兄弟元素 有兼容性问题 previousSibling//上一个兄弟节点 previousElementSibling //上一个兄弟元素 有兼容性问题 firstChild //第一个节点 firstElementChild //第一个子元素 有兼容性问题 lastChild //最后一个子节点 lastElementChild //最后一个子元素 有兼容性问题 parentNode //父节点 （一定是元素节点，所以无需处理） 样式属性style属性是对象，style对象的属性是字符串 style只能获取和设置行内样式 DOM对象中style的属性和标签中style内的值几乎一样 只是带有 -的属性名较为特殊（如background-color变成了backgroundColor），因为在JS中 -不能作为标识符 设置和获取样式 //通过对象的style属性只能设置和获取行内样式 //获取样式的时候 如果行内没有该样式 输出空字符串 //设置样式的时候 赋的值是一个字符串 如果这个属性有单位 一定要节点加单位 什么情况通过class控制样式 什么情况通过style控制样式 不严格的说： //如果样式很多 通过 直接控制类名 的方式加样式 //如果样式比较少 通过直接设置比较方便 严格来说： //从标准的角度讲 即使是样式比较少的时候 设置样式也要用类名 //但是有一类情况 是无论如何也必须直接通过JS加的 那就是涉及到计算的时候 动态创建元素插入和移除节点克隆节点 要克隆的节点.cloneNode(布尔值); 在父元素中的最后追加子元素 father.appendChild(要追加的节点对象); 在父元素中的某个子元素前面插入子元素 father.insertBefore(要插入的节点对象,插到这个节点对象的前面); 从父元素中移除子元素 father.removeChild(要移除的子节点对象); 清空父元素 father.innerHTML=””;在清空内容的时候和事件相关的函数不会被销毁，任然遗留在内存中 因此如果方便的话，建议使用father.removeChild(son)来清除 动态创建结构方式一：直接在文档中书写 document.write(“内容”) 方式二：改变元素对象内部的HTML innerHTML=”内容” 方式三：创建或克隆节点并追加 createElement() cloneNode() 通过这两种方法创建出来的元素只是保存在内存中，必须放到页面上才行! 内置方法字符方法 charAt() //获取指定位置处字符 charCodeAt() //获取指定位置处字符的ASCII码 str[0] //ES5，IE8+支持 和charAt()等效 操作方法 concat() //拼接字符串，和+一样 slice() //从start位置开始，截取到end位置，end取不到 substring() //从start位置开始，截取到end位置，end取不到 substr() //从start位置开始，截取length个字符 trim() //只能去除字符串前后的空白 split() //把字符串切割成字符数组 位置方法 indexOf() //返回指定内容在元字符串中的位置, 在数组中的话,返回的是索引 lastIndexOf() //从后往前找，只找第一个匹配的 匹配方法 search() replace() 大小写转换方法 to(Locale)UpperCase() //转换大写 to(Locale)LowerCase() //转换小写 数组方法 图形属性 offset系列offsetWidth和offsetHeight用来得到对象的大小 \@offsetHeight和style.height的区别 demo.style.height只能获取行内样式，如果样式写到了其他地方，甚至根本就没写，便无法获取 style.height是字符串（而且带单位），offsetHeight是数值 demo.style.height可以设置行内样式，offsetHeight是只读属性 因此，一般用demo.offsetHeight来获取某元素的真实宽度/高度，用style.height来设置宽度/高度 \@offsetHeight的构成 offsetHeight = height+padding+border 包括 自身高度 内边距 边框 不包括 外边距 offsetParent\@offsetParent爸爸去哪 返回该对象距离最近的带有定位的父级 如果当前元素的所有父级元素都没有定位（position为absolute或relative），offsetParent为body 如果当前元素的父级元素中有定位（position为absolute或relative），offsetParent取最近的那个父级元素 另外注意offsetParent与parentNode的区别parentNode只找自己的上一级（亲爹） offsetLeft和offsetTop用来得到对象的位置（注意：没有offsetRight和offsetBottom） \@offsetLeft的构成 到距离自身最近的（带有定位的）父元素的 左侧/顶部 的距离 如果所有父级都没有定位则以body 为准 offsetLeft 是自身border左侧到父级padding左侧的距离 \@offsetLeft和style.left的区别 一、style.left只能获取行内样式 二、offsetLeft只读，style.left可读可写 三、offsetLeft是数值，style.left是字符串并且有单位px 四、如果没有加定位，style.left获取的数值可能是无效的 五、最大区别在于offsetLeft以border左上角为基准，style.left以margin左上角为基准 在行内设置以下属性，并且记得加定位 left:20px; margin:20px; 不用死记，offset是计算偏移的，只要记住和定位有关就行了，实在需要详细区分，用的时候自己写个div试一试或者一查文档就知道了。 Math对象\@Math对象常用方法 天花板 向上取整 负数取更大的 Math.ceil(x) 地板 向下取整 负数取更小的 Math.floor(x) 就近取整 rounds a number to the nearest integer 就近取整 有的地方就翻译成四舍五入了 //四舍五入 只看尾数的最高位 01234舍 56789入 //就近取整 会整体比较 以.5为界限 小于的舍 大于的入 等于的 正数入负数舍 //虽然原则不一样但是实际上差别不大 只有一种情况会产生分歧 就是-1.5 //四舍五入是-2 而就近取整-1 Math.round(x) 取绝对值 Math.abs(x) 动画原理动画原理公式动画原理公式： leader = leader + step leader表示盒子当前位置 step表示步长 box.style.left = box.offsetLeft + 10 + “px”; 让setInterval不断执行某个函数修改盒子的位置属性最后就实现了动画的效果 动画函数封装\@动画函数封装 动画函数较为复杂，却又很常用对于这样的函数，我们一般都会进行封装 需求：能够让任意对象移动到指定位置。 动画函数改进\@动画函数改进 然而封装之后的函数还有很多问题，所以我们要对其进行进一步改进 判断运动方向 完善终点检测 终点清除定时器 手动设置对象位置到终点 调用开始先清理定时器，防止多次调用 图形属性scroll系列scroll系列\@scrollHeight和scrollWidth 对象内部实际内容的高度/宽度 \@scrollTop和scrollLeft 被卷去部分的 顶部/左侧 到可视区域 顶部/左侧 的距离 页面滚动座标\@获取页面滚动座标 页面滚动座标非常常用，但是有很大的兼容性问题，可以合写为 var scrollTop = window.pageYOffset || document.documentElement.scrollTop ||document.body.scrollTop || 0; \@封装自己的scroll() 由于非常常用，每次都写上面那一大堆很麻烦。我们可以封装一个自己的scroll()方法，返回页面滚动座标 固定导航案例\@固定导航案例 当页面向下滚动的时候 进行判断 如果页面向上走的距离 大于导航栏到页面顶部的距离时将导航栏的定位改为固定定位 小问题：当导航栏改为固定定位的一瞬间，后面的元素会塌陷。解决方案：给下面的元素添加数值为导航栏高度的padding-top 缓动动画原理公式动画公式 leader = leader + step 匀速动画公式 step = 定值 leader = leader + step 缓动动画公式 step = ( target - leader ) / 10 leader = leader + step 缓动动画的好处 他的移动是有尽头的。不像基础匀速运动那样无限移动。 有非常逼真的缓动效果，实现的动画效果更细腻。 如果不清除定时器，物体永远跟着目标leader在移动。 \@体验缓动动画 函数封装\@缓动动画改进 多次点击按钮重复开启定时器 永远无法真正到达目标 到达目标后清理定时器 \@缓动函数封装 需求：能够让任意对象移动到指定位置 封装缓动框架详细见html代码 图形属性client系列client系列\@clientWidth和clientHeight： 偏移offsetWidth: width + padding + border 卷曲scrollWidth: width + padding 不包含border 内部内容的大小 可视clientWidth: width + padding 不包含border \@clientTop和clientLeft clientTop和clientLeft没什么用 他们就是borderTop和borderLeft（如果有滚动条会包含滚动条的宽度，但谁见过滚动条在顶部或者左侧的？！） 网页可视区宽高\@网页可视区宽高的兼容写法 页面可视区宽高非常常用，但是有很大的兼容性问题，可以合写为 var clientWidth = window.innerWidth|| document.documentElement.clientWidth||document.body.clientWidth|| 0; 事件对象事件： onclick onmouseover onmouseout onfocus onblure 事件对象简介\@事件对象简介 在触发事件时，会产生一个事件对象event，这个对象中包含着与事件有关的信息。 所有浏览器都支持event对象，但支持的方式不同。 比如鼠标操作时候，会添加鼠标位置的相关信息到事件对象中。 普通浏览器支持 传入参数 ie 678 支持 window.event \@事件对象的兼容性写法 var event = event || window.event; 三个重要座标\@三个重要座标 clientX clientY 当前窗口的左上角为基准点 pageX pageY 以当前文档的左上角为基准点 IE678不支持pageX和pageY 但是我们可以采取另一种方式 var pageY = event.pageY || event.clientY +document.documentElement.scrollTop; var pageX = event.pageX || event.clientX +document.documentElement.scrollLeft; screenX screenY 当前屏幕的左上角为基准点 放大镜特效\@计算鼠标在盒子中的位置 制作方法： 鼠标经过显示盒子 鼠标经过small，让mask和big显示；鼠标离开small，让mask和big隐藏。 鼠标经过遮罩跟随 给small绑定鼠标移动事件 获取鼠标在small 内的坐标 计算鼠标在盒子中的座标（鼠标pageX-box到页面左侧的距离；鼠标pageY-box到页面顶部的距离） 然后赋值给mask的top和left（位置是按照左上角算的，所以top值要减去高度的一半，left值要减去宽度的一半） 限定遮罩运动范围 x 最小为0；最大为200，这个200是 small的宽度 -mask的宽度（mask可以向右移动的最大值） 按比例显示大图片 小盒子移动，大盒子要根据比例来移动，比例为： 大图 在 大盒子 里移动的距离 / 小黄 在 小图 里移动的距离 （大图片 - 大盒子 ） / （小盒子 - 小遮罩 ） 800 - 400 / 350 - 175 因为是反方向移动 计算时记得加负号呦！ 可拖拽特效常用事件： onmouseover 鼠标经过 onmouseout 鼠标离开 onmousedown 鼠标按下 onmouseup 鼠标弹起 onmousemove 鼠标移动 \@可拖拽特效 在拖动区域按下鼠标后，在文档中移动鼠标，盒子跟着鼠标坐标走。 鼠标在文档中弹起后，将事件清空。 盒子的位置要进行调整，当鼠标按下时，记录鼠标在盒子中的位置，鼠标移动计算盒子位置的时候减去。 清除选中的内容 window.getSelection ? window.getSelection().removeAllRanges() :document.selection.empty(); 正常浏览器支持：window.getSelection() IE678以下支持：document.selection 注册事件的三种方式element.addEventListener(“事件类型”,”事件处理函数”,”是否使用捕获”) addEventListener的好处是不会将其他事件覆盖，但是有兼容性问题 removeEventListener可以移除指定事件 addEventListener便于管理事件队列 但一般用on的就可以了比较简单 事件的三个阶段1捕获阶段 2目标阶段 执行当前对象的事件处理程序 3冒泡阶段 鼠标事件和键盘事件常用鼠标事件： mousedown、mouseup、mousemove、mouseover、mouseout、click、dblclick onmousedown鼠标按下 onmouseup鼠标弹起 onmouseclick=onmousedown+onmouseup 常用键盘事件： keydown、keypress、keyup onkeydown键盘按下 onkeyup键盘弹起 onkeypress=onkeydown+onkeyup onkeydown onkeyup 输出的是键盘码 onkeypress输出的是ASCII码表 正则表达式正则表达式在网络上有很多资料和工具，用的时候直接在网上搜即可 声明和使用\@正则的声明和使用 通过构造函数定义 var 变量名= new RegExp(/表达式/); 通过直接量定义（简单方便，我们一般用这个） var 变量名= /表达式/; 常用方法，可用于检测传入的字符串是否符合该规则并返回布尔值 exp.test(“要检测的字符串”) 预定义类\@预定义类和转义符 . [\^\n\r] 除了换行和回车之外的任意字符 \d [0-9] 数字字符digit \D [\^0-9] 非数字字符 \w [a-zA-Z0-9_] 单词字符(所有的字母数字和_) word \W [\^a-zA-Z0-9_] 非单词字符 \s [\f\r\n\t\v] 不可见字符 space \S [\^\f\r\n\t\v] 可见字符 转义符 \f 表示换页 form feed \t 表示水平制表符 table \v 表示垂直制表符 vertical table \r,\n,\r\n的区别 在万恶的旧社会，打字机换行（\nnewline）之后只会下移一行，需要回到一行的开头（\r return）才能继续打字 老式的操作系统也继承了打字机的这一特性，但用户换行之后一般都是要回到开头的，因此新式的操作系统为了方便将键盘上的Enter键的含义修改为\r\n或者直接将\n的含义改为“移动到下一行的开头”。 说到转义字符你有没有想起HTML的转义字符呢？（字符实体） \@基本语法补充 | 表示或 或的优先级最低 可以通过()提升优先级 字符类\@字符类 简单类[abc] 表示该位置可以出现的字符 负向类[\^abc] 表示该位置不可以出现的字符 范围类[a-e] 表示该位置可以出现的字符的范围 组合类[a-xA-E0-9] 范围类的组合 \@验证密码强度 边界 量词 括号\@边界 \^ 会匹配行或者字符串的起始位置 \^只有在[]内才表示非 在外边表示开始 \$ 会匹配行或字符串的结尾位置 \^\$在一起 表示必须是这个（精确匹配） \@量词 “*“ 重复零次或更多 x>=0 “+” 重复一次或更多次 x>=1 “?” 重复零次或一次 x=(0||1) {n} n次 x=n {n,} 重复n次或更多 x>=n {n,m} 重复出现的次数比n多但比m少 n\&lt;=x\&lt;=m \@括号总结 ()表示一组 []表示一个字符的位置 {}表示次数 \@验证座机\@验证姓名\@完整版表单验证 常见项目的匹配常见项目的匹配网上有很多（例如搜索常用正则表达式大全），无需记忆，能看懂即可 匹配国内电话号码： /\^0\d{2,3}-\d{7,8}\$/ 匹配姓名： /\^[\u4e00-\u9fa5]{2,}\$/ 匹配腾讯QQ号： /\^[1-9]\d{4,10}\$/ 匹配手机号： /\^(13[0-9]|14[57]|15[0-9]|18[0-9])\d{8}\$/ 匹配邮箱： /\^\w+([+-.]\w+)*\@\w+([-.]\w+)*\.\w+([-.]\w+)*\$/ 面向对象( 思维方式 )以洗衣服为例 面向过程的思维方式： 把解决问题的关注点放在了解决问题的每一个详细步骤(过程)上 1.收集脏衣服 2.把脏衣服扔到洗衣机中 3.设定洗衣程序 4.开始洗衣服 5.拿出衣服晾晒 面向对象的思维方式： 把解决问题的关注点放在了解决问题所需要的一些列的对象上 1.女朋友 2.洗衣机 什么是对象 万物皆对象 js中的对象是什么？ 无序的键值对儿的集合]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sublime快捷键]]></title>
      <url>%2F2016%2F12%2F15%2FSublime%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F12%2F08%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
